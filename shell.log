2018-11-27 13:47:50 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 13:47:50 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 13:47:50 - For help type #help;;
2018-11-27 13:47:50 - > val it :
2018-11-27 13:47:50 -   ResizeArray<System.Type *
2018-11-27 13:47:50 -               (obj ->
2018-11-27 13:47:50 -                  seq<string *
2018-11-27 13:47:50 -                      string> *
2018-11-27 13:47:50 -                  string)>
2018-11-27 13:47:50 - = seq []
2018-11-27 13:47:50 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 13:47:50 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 13:47:50 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 13:47:52 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 13:47:52 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 13:47:52 - For help type #help;;
2018-11-27 13:47:52 - > val it :
2018-11-27 13:47:52 -   ResizeArray<System.Type *
2018-11-27 13:47:52 -               (obj ->
2018-11-27 13:47:52 -                  seq<string *
2018-11-27 13:47:52 -                      string> *
2018-11-27 13:47:52 -                  string)>
2018-11-27 13:47:52 - = seq []
2018-11-27 13:47:52 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 13:47:52 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 13:47:52 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 13:47:53 - Reporting 0 opened comms
2018-11-27 13:47:55 - printf "%s" "Hello world!"
2018-11-27 13:48:05 - shutdown request
2018-11-27 13:48:09 - Reporting 0 opened comms
2018-11-27 13:48:14 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 13:48:14 - #load "XPlot.Plotly.fsx"
2018-11-27 13:48:14 - open XPlot.Plotly
2018-11-27 13:48:14 - open System
2018-11-27 13:48:31 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 13:48:31 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 13:48:31 - For help type #help;;
2018-11-27 13:48:31 - > val it :
2018-11-27 13:48:31 -   ResizeArray<System.Type *
2018-11-27 13:48:31 -               (obj ->
2018-11-27 13:48:31 -                  seq<string *
2018-11-27 13:48:31 -                      string> *
2018-11-27 13:48:31 -                  string)>
2018-11-27 13:48:31 - = seq []
2018-11-27 13:48:31 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 13:48:31 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 13:48:31 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 13:48:33 - Reporting 0 opened comms
2018-11-27 13:48:38 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 13:48:38 - #load "XPlot.Plotly.fsx"
2018-11-27 13:48:38 - open XPlot.Plotly
2018-11-27 13:48:38 - open System
2018-11-27 13:48:48 - let N = 5.
2018-11-27 13:48:48 - let x0 = -(N % 3.)
2018-11-27 13:48:48 - let xm = x0 + 1.
2018-11-27 13:48:48 - let h = 0.01
2018-11-27 13:48:48 - let points = [x0 .. h .. xm]
2018-11-27 13:48:48 - let f (x : float) = x * exp (x * (N % 2. + 1.)) + sin (x / 2. * (N % 7. + 1.))
2018-11-27 13:48:48 - let finiteDifferencesTable = 
2018-11-27 13:48:48 -     let rec computeCells y acc = 
2018-11-27 13:48:48 -         let computeCol (prevCol : float list) =
2018-11-27 13:48:48 -             let rec computeColInternal x acc =
2018-11-27 13:48:48 -                 match x with
2018-11-27 13:48:48 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-11-27 13:48:48 -                 | _ -> acc
2018-11-27 13:48:48 -             computeColInternal y [] 
2018-11-27 13:48:48 -         match y with
2018-11-27 13:48:48 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-11-27 13:48:48 -         |_ -> List.rev acc
2018-11-27 13:48:48 -     computeCells (points.Length - 1) [points |> List.map f]
2018-11-27 13:48:48 - //first case
2018-11-27 13:48:48 - let polynom n x =
2018-11-27 13:48:48 -     let t = (x - x0) / h
2018-11-27 13:48:48 -     let Nk =
2018-11-27 13:48:48 -         let rec NkInternal prev i = seq{
2018-11-27 13:48:48 -             match i with
2018-11-27 13:48:48 -             | _ when int i = n - 1 -> yield prev * (t - i) /  (i + 1.)
2018-11-27 13:48:48 -             | 0. -> yield t
2018-11-27 13:48:48 -                     yield! NkInternal t (i + 1.)
2018-11-27 13:48:48 -             | _ ->  let cur = prev * (t - i) /  (i + 1.)
2018-11-27 13:48:48 -                     yield cur
2018-11-27 13:48:48 -                     yield! NkInternal cur (i + 1.)
2018-11-27 13:48:48 -         }
2018-11-27 13:48:48 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 13:48:48 -     let rec polynomInternal nki (finiteDifference : float list list) k acc =
2018-11-27 13:48:48 -         match nki, finiteDifference with
2018-11-27 13:48:48 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) when k < n -> polynomInternal tNki tFiniteDifference (k + 1) (acc + hNki * (hFiniteDifference |> List.head)) 
2018-11-27 13:48:48 -         | _ -> acc
2018-11-27 13:48:48 -     polynomInternal Nk finiteDifferencesTable.Tail 0 (f x0)
2018-11-27 13:48:48 - let plotFirstCaseError () =
2018-11-27 13:48:48 -     let trace1 =
2018-11-27 13:48:48 -         let y = points |> List.map f
2018-11-27 13:48:48 -         Scatter(
2018-11-27 13:48:48 -             x = points,
2018-11-27 13:48:48 -             y = y,
2018-11-27 13:48:48 -             name = "Исходная функция"
2018-11-27 13:48:48 -         )
2018-11-27 13:48:48 -     let trace2 =
2018-11-27 13:48:48 -         let y = points |> List.map (polynom 1)
2018-11-27 13:48:48 -         Scatter(
2018-11-27 13:48:48 -             x = points,
2018-11-27 13:48:48 -             y = y,
2018-11-27 13:48:48 -             name = "Интерполяционный полином"
2018-11-27 13:48:48 -         )
2018-11-27 13:48:48 -     [trace1; trace2]
2018-11-27 13:48:48 -     |> Chart.Plot
2018-11-27 13:48:48 -     |> Chart.WithWidth 1000
2018-11-27 13:48:48 -     |> Chart.WithHeight 700
2018-11-27 13:48:48 - plotFirstCaseError()
2018-11-27 13:48:49 - //second case
2018-11-27 13:48:49 - let polynom2 n x =
2018-11-27 13:48:49 -     let t = (x - xm) / h
2018-11-27 13:48:49 -     let Nk =
2018-11-27 13:48:49 -         let rec NkInternal prev i = seq{
2018-11-27 13:48:49 -             match i with
2018-11-27 13:48:49 -             | _ when int i = n - 1 -> yield prev * (t + i) /  (i + 1.)
2018-11-27 13:48:49 -             | 0. -> yield t
2018-11-27 13:48:49 -                     yield! NkInternal t (i + 1.)
2018-11-27 13:48:49 -             | _ ->  let cur = prev * (t + i) /  (i + 1.)
2018-11-27 13:48:49 -                     yield cur
2018-11-27 13:48:49 -                     yield! NkInternal cur (i + 1.)
2018-11-27 13:48:49 -         }
2018-11-27 13:48:49 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 13:48:49 -     
2018-11-27 13:48:49 -     let rec polynom2Internal nki (finiteDifference : float list list) k acc =
2018-11-27 13:48:49 -         match nki, finiteDifference with
2018-11-27 13:48:49 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) when k < n -> polynom2Internal tNki tFiniteDifference (k + 1) (acc + hNki * (hFiniteDifference |> List.last)) 
2018-11-27 13:48:49 -         | _ -> acc
2018-11-27 13:48:49 -     polynom2Internal Nk finiteDifferencesTable.Tail 0 (f xm)
2018-11-27 13:48:49 - let plotSecondCaseError () =
2018-11-27 13:48:49 -     let trace1 =
2018-11-27 13:48:49 -         let y = points |> List.map f
2018-11-27 13:48:49 -         Scatter(
2018-11-27 13:48:49 -             x = points,
2018-11-27 13:48:49 -             y = y,
2018-11-27 13:48:49 -             name = "Исходная функция"
2018-11-27 13:48:49 -         )
2018-11-27 13:48:49 -     let trace2 =
2018-11-27 13:48:49 -         let y = points |> List.map (polynom2 4)
2018-11-27 13:48:49 -         Scatter(
2018-11-27 13:48:49 -             x = points,
2018-11-27 13:48:49 -             y = y,
2018-11-27 13:48:49 -             name = "Интерполяционный полином"
2018-11-27 13:48:49 -         )
2018-11-27 13:48:49 -     [trace1; trace2]
2018-11-27 13:48:49 -     |> Chart.Plot
2018-11-27 13:48:49 -     |> Chart.WithWidth 1000
2018-11-27 13:48:49 -     |> Chart.WithHeight 700
2018-11-27 13:48:49 - plotSecondCaseError()
2018-11-27 13:48:49 - //third case
2018-11-27 13:48:49 - let polynom3 n x =
2018-11-27 13:48:49 -     let startX = points |> List.filter (fun i -> x > i - h / 2. && x <= i + h / 2.) |> List.exactlyOne
2018-11-27 13:48:49 -     let isRightSide = x <= startX + h / 2. && x > startX
2018-11-27 13:48:49 -     let middlePoint = points |> List.findIndex (fun i -> i = startX)
2018-11-27 13:48:49 -     let dependenceOfSide rightSide = 
2018-11-27 13:48:49 -         match rightSide with
2018-11-27 13:48:49 -         | false -> (n + 1) / 2
2018-11-27 13:48:49 -         | true -> n / 2
2018-11-27 13:48:49 -     let startIndex = middlePoint - (dependenceOfSide isRightSide)
2018-11-27 13:48:49 -     let endIndex = middlePoint + (dependenceOfSide <| not isRightSide)
2018-11-27 13:48:49 -     let t = (x - startX) / h
2018-11-27 13:48:49 -     let Nk =
2018-11-27 13:48:49 -         let rec NkInternal prev i =
2018-11-27 13:48:49 -             let deg = 
2018-11-27 13:48:49 -                 match n % 2 = 0 with
2018-11-27 13:48:49 -                 | true -> i + 1.
2018-11-27 13:48:49 -                 | false -> i
2018-11-27 13:48:49 -             seq{
2018-11-27 13:48:49 -                 match i with
2018-11-27 13:48:49 -                 | _ when int i = n - 1 -> yield prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 13:48:49 -                 | 0. -> yield t
2018-11-27 13:48:49 -                         yield! NkInternal t (i + 1.)
2018-11-27 13:48:49 -                 | _ ->  let cur = prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 13:48:49 -                         yield cur
2018-11-27 13:48:49 -                         yield! NkInternal cur (i + 1.)
2018-11-27 13:48:49 -             }
2018-11-27 13:48:49 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 13:48:49 -     
2018-11-27 13:48:49 -     let middle =
2018-11-27 13:48:49 -         let rec truncateFiniteDiff (finiteDifference : float list list) k acc =
2018-11-27 13:48:49 -             match finiteDifference with
2018-11-27 13:48:49 -             | (h :: t) when k <= n -> truncateFiniteDiff t (k + 1) ((h |> List.indexed |> List.filter (fun (i, _) -> i >= startIndex && i <= endIndex - k) |> List.map (snd)) :: acc)
2018-11-27 13:48:49 -             | _ -> acc |> List.rev
2018-11-27 13:48:49 -         truncateFiniteDiff finiteDifferencesTable 0 []
2018-11-27 13:48:49 -     let rec polynom3Internal nki (finiteDifference : float list list) acc =
2018-11-27 13:48:49 -         match nki, finiteDifference with
2018-11-27 13:48:49 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) -> polynom3Internal tNki tFiniteDifference (acc + hNki * hFiniteDifference.[(hFiniteDifference.Length - 1) / 2])
2018-11-27 13:48:49 -         | _ -> acc
2018-11-27 13:48:49 -     
2018-11-27 13:48:49 -     match startIndex, endIndex with
2018-11-27 13:48:49 -     | (s, e) when s >= 0 && e < points.Length -> polynom3Internal Nk middle.Tail (f startX)
2018-11-27 13:48:49 -     | (s, e) when s >= 0 -> polynom2 n x
2018-11-27 13:48:49 -     | (s, e) when e < points.Length -> polynom n x
2018-11-27 13:48:49 -     | _ -> failwith "Incorrect arguments"
2018-11-27 13:48:49 - let plotThirdCaseError () =
2018-11-27 13:48:49 -     let trace1 =
2018-11-27 13:48:49 -         let y = points |> List.map f
2018-11-27 13:48:49 -         Scatter(
2018-11-27 13:48:49 -             x = points,
2018-11-27 13:48:49 -             y = y,
2018-11-27 13:48:49 -             name = "Исходная функция"
2018-11-27 13:48:49 -         )
2018-11-27 13:48:49 -     let trace2 =
2018-11-27 13:48:49 -         let y = points |> List.map (polynom3 1)
2018-11-27 13:48:49 -         Scatter(
2018-11-27 13:48:49 -             x = points,
2018-11-27 13:48:49 -             y = y,
2018-11-27 13:48:49 -             name = "Интерполяционный полином"
2018-11-27 13:48:49 -         )
2018-11-27 13:48:49 -     [trace1; trace2]
2018-11-27 13:48:49 -     |> Chart.Plot
2018-11-27 13:48:49 -     |> Chart.WithWidth 1000
2018-11-27 13:48:49 -     |> Chart.WithHeight 700
2018-11-27 13:48:49 - plotThirdCaseError()
2018-11-27 13:48:49 - let x = -1.455 //значение из отрезка [-2; -1]
2018-11-27 13:48:49 - let n = 8 //степень полинома
2018-11-27 13:48:49 - polynom n x - f x |> abs;;
2018-11-27 13:48:49 - polynom2 n x - f x |> abs;;
2018-11-27 13:48:49 - polynom3 n x - f x |> abs;;
2018-11-27 13:48:54 - let N = 5.
2018-11-27 13:48:54 - let f (x : float) = x * exp (x * (N % 2. + 1.)) + sin (x / 2. * (N % 7. + 1.))
2018-11-27 13:48:54 - let x0 = - (N % 3.)
2018-11-27 13:48:54 - let xPoints = [x0; x0 + 0.3; x0 + 0.5]
2018-11-27 13:48:54 - let rs = [1.; 2.; 3.]
2018-11-27 13:48:54 - let yPoints =
2018-11-27 13:48:54 -     let rec addWhileNotZero x r acc =  if int r > 0 then addWhileNotZero x (r - 1.) (x :: acc)
2018-11-27 13:48:54 -                                        else acc 
2018-11-27 13:48:54 -     let rec yPointInternal x r acc =
2018-11-27 13:48:54 -         match x, r with
2018-11-27 13:48:54 -         | (xh :: xt), (rh :: rt) -> yPointInternal xt rt <| addWhileNotZero xh rh acc
2018-11-27 13:48:54 -         | _ -> List.rev acc
2018-11-27 13:48:54 -     yPointInternal xPoints rs []
2018-11-27 13:48:54 - yPoints, xPoints
2018-11-27 13:48:54 - let f' (x : float) = exp (2. * x) * (1. + 2. * x) + 3. * cos (3. * x)
2018-11-27 13:48:54 - let f'' (x : float) = 4. * exp (2. * x) * (1. + x) - 9. * sin (3. * x)
2018-11-27 13:48:54 - let df j = 
2018-11-27 13:48:54 -     match j with
2018-11-27 13:48:54 -     | 0 -> f
2018-11-27 13:48:54 -     | 1 -> f'
2018-11-27 13:48:54 -     | 2 -> f''
2018-11-27 13:48:54 -     | _ -> failwith "unexpected derivative number"
2018-11-27 13:48:54 - let factorial n = [1 .. n] |> List.reduce (*)
2018-11-27 13:48:54 - let dividedDifferencesTable = 
2018-11-27 13:48:54 -     let rec computeCells y (acc : float list list) = 
2018-11-27 13:48:54 -         let computeCol n (prevCol : float list) =
2018-11-27 13:48:54 -             let rec computeColInternal x acc =
2018-11-27 13:48:54 -                 match x with
2018-11-27 13:48:54 -                 | _ when x > 0 && yPoints.[x + n - 1] - yPoints.[x - 1] <> 0. -> 
2018-11-27 13:48:54 -                                 ((prevCol.[x] - prevCol.[x - 1]) / (yPoints.[x + n - 1] - yPoints.[x - 1])) :: acc |> computeColInternal (x - 1)
2018-11-27 13:48:54 -                 | _ when x > 0 -> (df n yPoints.[x - 1]) / (float <| factorial n)  :: acc |> computeColInternal (x - 1)
2018-11-27 13:48:54 -                 | _ -> acc
2018-11-27 13:48:54 -             computeColInternal (yPoints.Length - n) [] 
2018-11-27 13:48:54 -         match y with
2018-11-27 13:48:54 -         |_ when y > 0 -> (computeCol (yPoints.Length - y) acc.[0]) :: acc |> computeCells (y - 1)
2018-11-27 13:48:54 -         |_ -> List.rev acc
2018-11-27 13:48:54 -     computeCells (yPoints.Length - 1) [yPoints |> List.map f; yPoints]
2018-11-27 13:48:54 - dividedDifferencesTable
2018-11-27 13:48:54 - let P x = 
2018-11-27 13:48:54 -     let multiply = 1. :: ([0 .. yPoints.Length - 2] |> List.mapFold (fun acc k -> ((x - yPoints.[k]) * acc, (x - yPoints.[k]) * acc)) 1. |> fst)
2018-11-27 13:48:54 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 13:48:54 -     [0 .. yPoints.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 13:48:54 - let h = 0.0001
2018-11-27 13:48:54 - let P' x = (P (x + h) - P x) / h
2018-11-27 13:48:54 - let P'' x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.) 
2018-11-27 13:48:54 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 13:48:54 - let trace1 =
2018-11-27 13:48:54 -     Scatter(
2018-11-27 13:48:54 -         x = x,
2018-11-27 13:48:54 -         y = (x |> List.map f),
2018-11-27 13:48:54 -         name = "Исходная функция"
2018-11-27 13:48:54 -     )
2018-11-27 13:48:54 - let trace2 =
2018-11-27 13:48:54 -     Scatter(
2018-11-27 13:48:54 -         x = x,
2018-11-27 13:48:54 -         y = (x |> List.map P),
2018-11-27 13:48:54 -         name = "Полином"
2018-11-27 13:48:54 -     )    
2018-11-27 13:48:54 - [trace1; trace2]
2018-11-27 13:48:54 - |> Chart.Plot
2018-11-27 13:48:54 - |> Chart.WithWidth 1000
2018-11-27 13:48:54 - |> Chart.WithHeight 700
2018-11-27 13:48:54 - let x = -1.33
2018-11-27 13:48:54 - abs (f x - P x)
2018-11-27 13:48:54 - abs (f' x - P' x)
2018-11-27 13:48:54 - abs (f'' x - P'' x)
2018-11-27 13:48:54 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 13:48:54 - let trace =
2018-11-27 13:48:54 -     Scatter(
2018-11-27 13:48:54 -         x = x,
2018-11-27 13:48:54 -         y = (x |> List.map (fun i -> abs (f i - P i))),
2018-11-27 13:48:54 -         name = "Исходная функция"
2018-11-27 13:48:54 -     )   
2018-11-27 13:48:54 - [trace]
2018-11-27 13:48:54 - |> Chart.Plot
2018-11-27 13:48:54 - |> Chart.WithWidth 1000
2018-11-27 13:48:54 - |> Chart.WithHeight 700
2018-11-27 13:48:54 - let trace =
2018-11-27 13:48:54 -     Scatter(
2018-11-27 13:48:54 -         x = x,
2018-11-27 13:48:54 -         y = (x |> List.map (fun i -> abs (f' i - P' i))),
2018-11-27 13:48:54 -         name = "Исходная функция"
2018-11-27 13:48:54 -     )   
2018-11-27 13:48:54 - [trace]
2018-11-27 13:48:54 - |> Chart.Plot
2018-11-27 13:48:54 - |> Chart.WithWidth 1000
2018-11-27 13:48:54 - |> Chart.WithHeight 700
2018-11-27 13:48:54 - let trace =
2018-11-27 13:48:54 -     Scatter(
2018-11-27 13:48:54 -         x = x,
2018-11-27 13:48:54 -         y = (x |> List.map (fun i -> abs (f'' i - P'' i))),
2018-11-27 13:48:54 -         name = "Исходная функция"
2018-11-27 13:48:54 -     )   
2018-11-27 13:48:54 - [trace]
2018-11-27 13:48:54 - |> Chart.Plot
2018-11-27 13:48:54 - |> Chart.WithWidth 1000
2018-11-27 13:48:54 - |> Chart.WithHeight 700
2018-11-27 13:48:54 - 2
2018-11-27 13:49:41 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 13:49:41 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 13:49:41 - For help type #help;;
2018-11-27 13:49:41 - > val it :
2018-11-27 13:49:41 -   ResizeArray<System.Type *
2018-11-27 13:49:41 -               (obj ->
2018-11-27 13:49:41 -                  seq<string *
2018-11-27 13:49:41 -                      string> *
2018-11-27 13:49:41 -                  string)>
2018-11-27 13:49:41 - = seq []
2018-11-27 13:49:41 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 13:49:41 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 13:49:41 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 13:49:42 - Reporting 0 opened comms
2018-11-27 13:57:13 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 13:57:13 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 13:57:13 - For help type #help;;
2018-11-27 13:57:13 - > val it :
2018-11-27 13:57:13 -   ResizeArray<System.Type *
2018-11-27 13:57:13 -               (obj ->
2018-11-27 13:57:13 -                  seq<string *
2018-11-27 13:57:13 -                      string> *
2018-11-27 13:57:13 -                  string)>
2018-11-27 13:57:13 - = seq []
2018-11-27 13:57:13 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 13:57:13 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 13:57:13 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 13:57:15 - Reporting 0 opened comms
2018-11-27 13:59:54 - let NewtonPolynomial (points : float list) x = 
2018-11-27 13:59:54 -     let dividedDifferencesTable = 
2018-11-27 13:59:54 -         let rec computeCells y acc = 
2018-11-27 13:59:54 -             let computeCol n (prevCol : float list) =
2018-11-27 13:59:54 -                 let rec computeColInternal x acc =
2018-11-27 13:59:54 -                     match x with
2018-11-27 13:59:54 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 13:59:54 -                     | _ -> acc
2018-11-27 13:59:54 -                 computeColInternal (points.Length - n) [] 
2018-11-27 13:59:54 -             match y with
2018-11-27 13:59:54 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 13:59:54 -             |_ -> List.rev acc
2018-11-27 13:59:54 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 13:59:54 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 13:59:54 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 13:59:54 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 13:59:54 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-11-27 13:59:54 -    x
2018-11-27 14:01:34 - let f x = sin x / (1. + x ** 2.)
2018-11-27 14:02:44 - let h = 1
2018-11-27 14:02:44 - let points = [-5. .. h .. 5]
2018-11-27 14:02:44 - The type 'int' does not match the type 'float'
2018-11-27 14:02:44 - This expression was expected to have type
2018-11-27 14:02:44 -     'float'    
2018-11-27 14:02:44 - but here has type
2018-11-27 14:02:44 -     'int'    
2018-11-27 14:02:50 - let h = 1.
2018-11-27 14:02:50 - let points = [-5. .. h .. 5.]
2018-11-27 14:02:55 - let NewtonPolynomial (points : float list) x = 
2018-11-27 14:02:55 -     let dividedDifferencesTable = 
2018-11-27 14:02:55 -         let rec computeCells y acc = 
2018-11-27 14:02:55 -             let computeCol n (prevCol : float list) =
2018-11-27 14:02:55 -                 let rec computeColInternal x acc =
2018-11-27 14:02:55 -                     match x with
2018-11-27 14:02:55 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 14:02:55 -                     | _ -> acc
2018-11-27 14:02:55 -                 computeColInternal (points.Length - n) [] 
2018-11-27 14:02:55 -             match y with
2018-11-27 14:02:55 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 14:02:55 -             |_ -> List.rev acc
2018-11-27 14:02:55 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 14:02:55 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 14:02:55 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 14:02:55 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 14:05:23 - let P (points : float list) x = 
2018-11-27 14:05:23 -     let dividedDifferencesTable = 
2018-11-27 14:05:23 -         let rec computeCells y acc = 
2018-11-27 14:05:23 -             let computeCol n (prevCol : float list) =
2018-11-27 14:05:23 -                 let rec computeColInternal x acc =
2018-11-27 14:05:23 -                     match x with
2018-11-27 14:05:23 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 14:05:23 -                     | _ -> acc
2018-11-27 14:05:23 -                 computeColInternal (points.Length - n) [] 
2018-11-27 14:05:23 -             match y with
2018-11-27 14:05:23 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 14:05:23 -             |_ -> List.rev acc
2018-11-27 14:05:23 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 14:05:23 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 14:05:23 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 14:05:23 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 14:06:43 - let P x = 
2018-11-27 14:06:43 -     let dividedDifferencesTable = 
2018-11-27 14:06:43 -         let rec computeCells y acc = 
2018-11-27 14:06:43 -             let computeCol n (prevCol : float list) =
2018-11-27 14:06:43 -                 let rec computeColInternal x acc =
2018-11-27 14:06:43 -                     match x with
2018-11-27 14:06:43 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 14:06:43 -                     | _ -> acc
2018-11-27 14:06:43 -                 computeColInternal (points.Length - n) [] 
2018-11-27 14:06:43 -             match y with
2018-11-27 14:06:43 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 14:06:43 -             |_ -> List.rev acc
2018-11-27 14:06:43 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 14:06:43 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 14:06:43 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 14:06:43 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 14:13:03 - let dP_1 x = (P (x + h) - P x) / h
2018-11-27 14:13:03 - let dP_2 x = (P x - P (x - h)) / h
2018-11-27 14:13:03 - let dP_3 x = (P (x + h) - P (x - h)) / (2. * h)
2018-11-27 14:13:03 - let dP_4 x = (-3. * P x + 4. * P (x + h) - P (x + 2. * h)) / (2. * h)
2018-11-27 14:13:03 - let dP_5 x = (-3. * P x - 4. * P (x - h) + P (x - 2. * h)) / (2. * h)
2018-11-27 14:13:03 - let dP_6 x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.)
2018-11-27 14:22:12 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1 + x ** 2.) ** 2.)
2018-11-27 14:22:12 - The type 'int' does not support the operator 'Pow'
2018-11-27 14:24:14 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-11-27 14:24:14 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-11-27 14:24:14 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-11-27 14:46:09 - let x = [-5. .. 0.01 .. 5]
2018-11-27 14:46:09 - let trace1 =
2018-11-27 14:46:09 -     Scatter(
2018-11-27 14:46:09 -         x = x,
2018-11-27 14:46:09 -         y = (x |> List.map (fun i -> abs (f' i - dP_1 i))),
2018-11-27 14:46:09 -         name = "Погрешность 1)"
2018-11-27 14:46:09 -     )   
2018-11-27 14:46:09 - let trace2 =
2018-11-27 14:46:09 -     Scatter(
2018-11-27 14:46:09 -         x = x,
2018-11-27 14:46:09 -         y = (x |> List.map (fun i -> abs (f' i - dP_2 i))),
2018-11-27 14:46:09 -         name = "Погрешность 2)"
2018-11-27 14:46:09 -     )
2018-11-27 14:46:09 - let trace3 =
2018-11-27 14:46:09 -     Scatter(
2018-11-27 14:46:09 -         x = x,
2018-11-27 14:46:09 -         y = (x |> List.map (fun i -> abs (f' i - dP_3 i))),
2018-11-27 14:46:09 -         name = "Погрешность 3)"
2018-11-27 14:46:09 -     )
2018-11-27 14:46:09 - let trace4 =
2018-11-27 14:46:09 -     Scatter(
2018-11-27 14:46:09 -         x = x,
2018-11-27 14:46:09 -         y = (x |> List.map (fun i -> abs (f' i - dP_4 i))),
2018-11-27 14:46:09 -         name = "Погрешность 4)"
2018-11-27 14:46:09 -     )
2018-11-27 14:46:09 - let trace5 =
2018-11-27 14:46:09 -     Scatter(
2018-11-27 14:46:09 -         x = x,
2018-11-27 14:46:09 -         y = (x |> List.map (fun i -> abs (f' i - dP_5 i))),
2018-11-27 14:46:09 -         name = "Погрешность 5)"
2018-11-27 14:46:09 -     )
2018-11-27 14:46:09 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 14:46:09 - |> Chart.Plot
2018-11-27 14:46:09 - |> Chart.WithWidth 1000
2018-11-27 14:46:09 - |> Chart.WithHeight 700
2018-11-27 14:46:09 - This expression was expected to have type
2018-11-27 14:46:09 -     'float'    
2018-11-27 14:46:09 - but here has type
2018-11-27 14:46:09 -     'int'    
2018-11-27 14:46:09 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:09 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:09 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:09 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:09 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:09 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2018-11-27 14:46:09 -    char
2018-11-27 14:46:09 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2018-11-27 14:46:09 -    char
2018-11-27 14:46:09 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2018-11-27 14:46:09 -    char
2018-11-27 14:46:20 - let x = [-5. .. 0.01 .. 5.]
2018-11-27 14:46:20 - let trace1 =
2018-11-27 14:46:20 -     Scatter(
2018-11-27 14:46:20 -         x = x,
2018-11-27 14:46:20 -         y = (x |> List.map (fun i -> abs (f' i - dP_1 i))),
2018-11-27 14:46:20 -         name = "Погрешность 1)"
2018-11-27 14:46:20 -     )   
2018-11-27 14:46:20 - let trace2 =
2018-11-27 14:46:20 -     Scatter(
2018-11-27 14:46:20 -         x = x,
2018-11-27 14:46:20 -         y = (x |> List.map (fun i -> abs (f' i - dP_2 i))),
2018-11-27 14:46:20 -         name = "Погрешность 2)"
2018-11-27 14:46:20 -     )
2018-11-27 14:46:20 - let trace3 =
2018-11-27 14:46:20 -     Scatter(
2018-11-27 14:46:20 -         x = x,
2018-11-27 14:46:20 -         y = (x |> List.map (fun i -> abs (f' i - dP_3 i))),
2018-11-27 14:46:20 -         name = "Погрешность 3)"
2018-11-27 14:46:20 -     )
2018-11-27 14:46:20 - let trace4 =
2018-11-27 14:46:20 -     Scatter(
2018-11-27 14:46:20 -         x = x,
2018-11-27 14:46:20 -         y = (x |> List.map (fun i -> abs (f' i - dP_4 i))),
2018-11-27 14:46:20 -         name = "Погрешность 4)"
2018-11-27 14:46:20 -     )
2018-11-27 14:46:20 - let trace5 =
2018-11-27 14:46:20 -     Scatter(
2018-11-27 14:46:20 -         x = x,
2018-11-27 14:46:20 -         y = (x |> List.map (fun i -> abs (f' i - dP_5 i))),
2018-11-27 14:46:20 -         name = "Погрешность 5)"
2018-11-27 14:46:20 -     )
2018-11-27 14:46:20 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 14:46:20 - |> Chart.Plot
2018-11-27 14:46:20 - |> Chart.WithWidth 1000
2018-11-27 14:46:20 - |> Chart.WithHeight 700
2018-11-27 14:46:20 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:20 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:20 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:20 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:20 - The value or constructor 'Scatter' is not defined.
2018-11-27 14:46:20 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2018-11-27 14:46:20 -    char
2018-11-27 14:46:20 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2018-11-27 14:46:20 -    char
2018-11-27 14:46:20 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2018-11-27 14:46:20 -    char
2018-11-27 14:46:43 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:46:43 - #load "XPlot.Plotly.fsx"
2018-11-27 14:46:43 - open XPlot.Plotly
2018-11-27 14:46:43 - open System
2018-11-27 14:46:44 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:46:44 - -- CLOSED --
2018-11-27 14:46:44 -    
2018-11-27 14:46:44 - -- OPEN ----
2018-11-27 14:46:44 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:44 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:44 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:46:44 - -- CLOSED --
2018-11-27 14:46:44 -    
2018-11-27 14:46:44 - -- OPEN ----
2018-11-27 14:46:44 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:44 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:44 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at FSI_0016.Paket.add (System.String package, System.String version) [0x00050] in <21dc37aa85bd43b8b0f148cede142696>:0 
2018-11-27 14:46:44 -   at FSI_0016.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <21dc37aa85bd43b8b0f148cede142696>:0 
2018-11-27 14:46:44 -   at <StartupCode$FSI_0016>.$FSI_0016_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <21dc37aa85bd43b8b0f148cede142696>:0 
2018-11-27 14:46:44 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:46:44 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:46:44 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:46:44 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:46:44 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:44 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:46:44 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:44 - WebExceptionError: NameResolutionFailure
2018-11-27 14:46:44 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:44 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:44 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:44 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:44 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:44 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:44 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:46:44 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:46:44 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:46:58 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:46:58 - #load "XPlot.Plotly.fsx"
2018-11-27 14:46:58 - open XPlot.Plotly
2018-11-27 14:46:58 - open System
2018-11-27 14:46:59 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:46:59 - -- CLOSED --
2018-11-27 14:46:59 -    
2018-11-27 14:46:59 - -- OPEN ----
2018-11-27 14:46:59 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:59 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:59 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:46:59 - -- CLOSED --
2018-11-27 14:46:59 -    
2018-11-27 14:46:59 - -- OPEN ----
2018-11-27 14:46:59 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:59 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:46:59 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at FSI_0017.Paket.add (System.String package, System.String version) [0x00050] in <21dc37aa85bd43b8b0f148cede142696>:0 
2018-11-27 14:46:59 -   at FSI_0017.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <21dc37aa85bd43b8b0f148cede142696>:0 
2018-11-27 14:46:59 -   at <StartupCode$FSI_0017>.$FSI_0017_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <21dc37aa85bd43b8b0f148cede142696>:0 
2018-11-27 14:46:59 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:46:59 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:46:59 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:46:59 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:46:59 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:46:59 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:46:59 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:46:59 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:46:59 - WebExceptionError: NameResolutionFailure
2018-11-27 14:46:59 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:59 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:59 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:59 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:59 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:59 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:46:59 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:46:59 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:46:59 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:47:51 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 14:47:51 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 14:47:51 - For help type #help;;
2018-11-27 14:47:51 - > val it :
2018-11-27 14:47:51 -   ResizeArray<System.Type *
2018-11-27 14:47:51 -               (obj ->
2018-11-27 14:47:51 -                  seq<string *
2018-11-27 14:47:51 -                      string> *
2018-11-27 14:47:51 -                  string)>
2018-11-27 14:47:51 - = seq []
2018-11-27 14:47:51 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 14:47:51 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 14:47:51 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 14:47:52 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:47:52 - #load "XPlot.Plotly.fsx"
2018-11-27 14:47:52 - open XPlot.Plotly
2018-11-27 14:47:52 - open System
2018-11-27 14:47:52 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:47:52 - -- CLOSED --
2018-11-27 14:47:52 -    
2018-11-27 14:47:52 - -- OPEN ----
2018-11-27 14:47:52 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:47:52 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:47:52 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:47:52 - -- CLOSED --
2018-11-27 14:47:52 -    
2018-11-27 14:47:52 - -- OPEN ----
2018-11-27 14:47:52 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:47:52 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:47:52 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at FSI_0004.Paket.add (System.String package, System.String version) [0x00050] in <41f6fff356524ab9ba75ab09719f3981>:0 
2018-11-27 14:47:52 -   at FSI_0004.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <41f6fff356524ab9ba75ab09719f3981>:0 
2018-11-27 14:47:52 -   at <StartupCode$FSI_0004>.$FSI_0004_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <41f6fff356524ab9ba75ab09719f3981>:0 
2018-11-27 14:47:52 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:47:52 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:47:52 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:47:52 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:47:52 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:47:52 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:47:52 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:47:52 - WebExceptionError: NameResolutionFailure
2018-11-27 14:47:52 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:47:52 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:47:52 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:47:52 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:47:52 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:47:52 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:47:52 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:47:52 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:47:52 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:47:52 - Reporting 0 opened comms
2018-11-27 14:48:07 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 14:48:07 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 14:48:07 - For help type #help;;
2018-11-27 14:48:07 - > val it :
2018-11-27 14:48:07 -   ResizeArray<System.Type *
2018-11-27 14:48:07 -               (obj ->
2018-11-27 14:48:07 -                  seq<string *
2018-11-27 14:48:07 -                      string> *
2018-11-27 14:48:07 -                  string)>
2018-11-27 14:48:07 - = seq []
2018-11-27 14:48:07 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 14:48:07 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 14:48:07 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 14:48:09 - Reporting 0 opened comms
2018-11-27 14:48:09 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:48:09 - #load "XPlot.Plotly.fsx"
2018-11-27 14:48:09 - open XPlot.Plotly
2018-11-27 14:48:09 - open System
2018-11-27 14:48:10 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:48:10 - -- CLOSED --
2018-11-27 14:48:10 -    
2018-11-27 14:48:10 - -- OPEN ----
2018-11-27 14:48:10 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:48:10 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:48:10 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:48:10 - -- CLOSED --
2018-11-27 14:48:10 -    
2018-11-27 14:48:10 - -- OPEN ----
2018-11-27 14:48:10 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:48:10 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:48:10 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at FSI_0004.Paket.add (System.String package, System.String version) [0x00050] in <cd17678261cf4f2f8cb0e9cdf012a8ac>:0 
2018-11-27 14:48:10 -   at FSI_0004.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <cd17678261cf4f2f8cb0e9cdf012a8ac>:0 
2018-11-27 14:48:10 -   at <StartupCode$FSI_0004>.$FSI_0004_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <cd17678261cf4f2f8cb0e9cdf012a8ac>:0 
2018-11-27 14:48:10 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:48:10 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:48:10 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:48:10 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:48:10 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:48:10 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:48:10 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:48:10 - WebExceptionError: NameResolutionFailure
2018-11-27 14:48:10 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:48:10 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:48:10 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:48:10 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:48:10 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:48:10 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:48:10 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:48:10 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:48:10 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:08 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 14:49:08 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 14:49:08 - For help type #help;;
2018-11-27 14:49:08 - > val it :
2018-11-27 14:49:08 -   ResizeArray<System.Type *
2018-11-27 14:49:08 -               (obj ->
2018-11-27 14:49:08 -                  seq<string *
2018-11-27 14:49:08 -                      string> *
2018-11-27 14:49:08 -                  string)>
2018-11-27 14:49:08 - = seq []
2018-11-27 14:49:08 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 14:49:08 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 14:49:08 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 14:49:09 - Reporting 0 opened comms
2018-11-27 14:49:09 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:49:09 - #load "XPlot.Plotly.fsx"
2018-11-27 14:49:09 - open XPlot.Plotly
2018-11-27 14:49:09 - open System
2018-11-27 14:49:10 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:10 - -- CLOSED --
2018-11-27 14:49:10 -    
2018-11-27 14:49:10 - -- OPEN ----
2018-11-27 14:49:10 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:10 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:10 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:10 - -- CLOSED --
2018-11-27 14:49:10 -    
2018-11-27 14:49:10 - -- OPEN ----
2018-11-27 14:49:10 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:10 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:10 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at FSI_0004.Paket.add (System.String package, System.String version) [0x00050] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:10 -   at FSI_0004.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:10 -   at <StartupCode$FSI_0004>.$FSI_0004_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:10 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:49:10 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:10 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:49:10 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:10 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:10 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:10 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:10 - WebExceptionError: NameResolutionFailure
2018-11-27 14:49:10 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:10 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:10 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:10 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:10 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:10 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:10 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:10 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:10 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:31 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:49:31 - #load "XPlot.Plotly.fsx"
2018-11-27 14:49:31 - open XPlot.Plotly
2018-11-27 14:49:31 - open System
2018-11-27 14:49:31 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:31 - -- CLOSED --
2018-11-27 14:49:31 -    
2018-11-27 14:49:31 - -- OPEN ----
2018-11-27 14:49:31 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:31 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:31 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:31 - -- CLOSED --
2018-11-27 14:49:31 -    
2018-11-27 14:49:31 - -- OPEN ----
2018-11-27 14:49:31 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:31 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:31 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at FSI_0005.Paket.add (System.String package, System.String version) [0x00050] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:31 -   at FSI_0005.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:31 -   at <StartupCode$FSI_0005>.$FSI_0005_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:31 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:49:31 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:31 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:49:31 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:31 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:31 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:31 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:31 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:31 - WebExceptionError: NameResolutionFailure
2018-11-27 14:49:31 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:31 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:31 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:31 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:31 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:31 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:31 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:31 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:31 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:32 - let N = 5.
2018-11-27 14:49:34 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:49:34 - #load "XPlot.Plotly.fsx"
2018-11-27 14:49:34 - open XPlot.Plotly
2018-11-27 14:49:34 - open System
2018-11-27 14:49:34 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:34 - -- CLOSED --
2018-11-27 14:49:34 -    
2018-11-27 14:49:34 - -- OPEN ----
2018-11-27 14:49:34 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:34 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:34 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:34 - -- CLOSED --
2018-11-27 14:49:34 -    
2018-11-27 14:49:34 - -- OPEN ----
2018-11-27 14:49:34 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:34 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:34 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at FSI_0007.Paket.add (System.String package, System.String version) [0x00050] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:34 -   at FSI_0007.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:34 -   at <StartupCode$FSI_0007>.$FSI_0007_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:34 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:49:34 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:34 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:49:34 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:34 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:34 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:34 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:34 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:34 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:34 - WebExceptionError: NameResolutionFailure
2018-11-27 14:49:34 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:34 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:34 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:34 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:34 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:34 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:34 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:34 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:34 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:35 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:49:35 - #load "XPlot.Plotly.fsx"
2018-11-27 14:49:35 - open XPlot.Plotly
2018-11-27 14:49:35 - open System
2018-11-27 14:49:35 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:35 - -- CLOSED --
2018-11-27 14:49:35 -    
2018-11-27 14:49:35 - -- OPEN ----
2018-11-27 14:49:35 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:35 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:35 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:35 - -- CLOSED --
2018-11-27 14:49:35 -    
2018-11-27 14:49:35 - -- OPEN ----
2018-11-27 14:49:35 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:35 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:35 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at FSI_0008.Paket.add (System.String package, System.String version) [0x00050] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:35 -   at FSI_0008.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:35 -   at <StartupCode$FSI_0008>.$FSI_0008_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <85f884ee24ca4f77830d6799118bd718>:0 
2018-11-27 14:49:35 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:49:35 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:35 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:49:35 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:35 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:35 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:35 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:35 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:35 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:35 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:35 - WebExceptionError: NameResolutionFailure
2018-11-27 14:49:35 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:35 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:35 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:35 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:35 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:35 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:35 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:35 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:35 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:44 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:49:44 - #load "XPlot.Plotly.fsx"
2018-11-27 14:49:44 - open XPlot.Plotly
2018-11-27 14:49:44 - open System
2018-11-27 14:49:44 - Expression evaluation failed: Unable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:44 - -- CLOSED --
2018-11-27 14:49:44 -    
2018-11-27 14:49:44 - -- OPEN ----
2018-11-27 14:49:44 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:44 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:44 - ExceptionUnable to retrieve package versions for 'FSharp.Core'
2018-11-27 14:49:44 - -- CLOSED --
2018-11-27 14:49:44 -    
2018-11-27 14:49:44 - -- OPEN ----
2018-11-27 14:49:44 -    FSharp.Core 4.5.2 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:44 -    XPlot.Plotly >= 1.4.2 < 1.5 (from /home/max/Загрузки/IfSharp.v3.0.1/paket.dependencies)
2018-11-27 14:49:44 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x0015f] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.SeqModule.oneStepTo@979[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i) [0x00045] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.SeqModule.action@4251-1[T] (System.Collections.Generic.IEnumerable`1[T] source, System.Collections.Generic.List`1[T] prefix, Microsoft.FSharp.Core.FSharpRef`1[T] enumeratorR, System.Int32 i, Microsoft.FSharp.Core.Unit unitVar0) [0x0001e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.SeqModule+result@995[T].Invoke (System.Int32 i) [0x0000f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+unfold@199[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator.next@187[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f, System.Collections.Generic.IEnumerator`1[T] e, Microsoft.FSharp.Core.FSharpRef`1[T] started, Microsoft.FSharp.Core.Unit unitVar0) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+filter@182[T].System-Collections-IEnumerator-MoveNext () [0x00015] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.SeqModule.IsEmpty[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00062] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Paket.PackageResolver.getCompatibleVersions (Paket.PackageResolver+ResolverStep currentStep, Paket.Domain+GroupName groupName, Paket.Requirements+PackageRequirement currentRequirement, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependencies, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, System.Boolean globalOverride, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives) [0x00189] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.PackageResolver.step@1113 (Paket.PackageResolver+UpdateMode updateMode, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Microsoft.FSharp.Collections.FSharpSet`1[T] cliToolSettings, Paket.PackageResolver+ResolverRequestQueue workerQueue, System.Int32 taskTimeout, System.TimeSpan loopTimeout, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetPackageDetailsRequests, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsBlock, System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue] startedGetVersionsRequests, Microsoft.FSharp.Core.FSharpOption`1[T] packageFilter, System.Collections.Generic.IDictionary`2[TKey,TValue] rootDependenciesDict, Microsoft.FSharp.Collections.FSharpSet`1[T] lockedPackages, System.DateTime loopTime, Paket.PackageResolver+Stage stage, Paket.PackageResolver+StackPack stackpack, System.Collections.Generic.IEnumerable`1[T] compatibleVersions, Paket.PackageResolver+StepFlags flags) [0x00343] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.PackageResolver.Resolve (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPreferredVersionsRaw, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsRaw, Paket.Domain+GroupName groupName, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForDirectDependencies, Microsoft.FSharp.Core.FSharpOption`1[T] globalStrategyForTransitives, Paket.Requirements+FrameworkRestrictions globalFrameworkRestrictions, Microsoft.FSharp.Collections.FSharpSet`1[T] rootDependencies, Paket.PackageResolver+UpdateMode updateMode) [0x00443] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at <StartupCode$Paket-Core>.$DependenciesFile+resolveGroup@222-1[b].Invoke (Paket.Domain+GroupName groupName, b _arg1) [0x000ff] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.MapTreeModule.mapiOpt[a,b,c] (Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.MapTree`2[TKey,TValue] m) [0x00029] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue].Map[b] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00013] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Collections.MapModule.Map[TKey,T,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpMap`2[TKey,TValue] table) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Paket.UpdateProcess.selectiveUpdate (System.Boolean force, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getSha1, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getVersionsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getPackageDetailsF, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] getRuntimeGraphFromPackage, Paket.LockFile lockFile, Paket.DependenciesFile dependenciesFile, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode) [0x00330] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.UpdateProcess.SelectiveUpdate (Paket.DependenciesFile dependenciesFile, Microsoft.FSharp.Core.FSharpOption`1[T] alternativeProjectRoot, Paket.PackageResolver+UpdateMode updateMode, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean force) [0x000e6] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.AddProcess.add$cont@53-1 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, Paket.InstallerOptions options, System.Boolean installAfter, Microsoft.FSharp.Core.FSharpRef`1[T] lockFile, System.Boolean lockFileHasPackage, Paket.DependenciesFile dependenciesFile, System.Collections.Generic.IEnumerable`1[T] projects, Microsoft.FSharp.Core.Unit unitVar) [0x00068] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.AddProcess.add$cont@27 (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind, Paket.DependenciesFile existingDependenciesFile, Microsoft.FSharp.Core.Unit unitVar) [0x000f5] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.AddProcess.add (System.Boolean installToProjects, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] addToProjectsF, System.String dependenciesFileName, Paket.Domain+GroupName groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00050] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.AddProcess.Add (System.String dependenciesFileName, Microsoft.FSharp.Core.FSharpOption`1[T] groupName, Paket.Domain+PackageName package, System.String version, Paket.InstallerOptions options, System.Boolean interactive, System.Boolean installAfter, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00011] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at <StartupCode$Paket-Core>.$PublicAPI+Add@184-16.Invoke (Microsoft.FSharp.Core.Unit unitVar0) [0x0005d] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.Utils.RunInLockedAccessMode[a] (System.String lockedFolder, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action) [0x00077] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver, Paket.Requirements+PackageRequirementKind packageKind) [0x00045] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs, System.Boolean runResolver) [0x0001c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.Dependencies.Add (Microsoft.FSharp.Core.FSharpOption`1[T] groupName, System.String package, System.String version, System.Boolean force, System.Boolean withBindingRedirects, System.Boolean cleanBindingRedirects, System.Boolean createNewBindingFiles, System.Boolean interactive, System.Boolean installAfter, Paket.SemVerUpdateMode semVerUpdateMode, System.Boolean touchAffectedRefs) [0x00001] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at FSI_0005.Paket.add (System.String package, System.String version) [0x00050] in <41f6fff356524ab9ba75ab09719f3981>:0 
2018-11-27 14:49:44 -   at FSI_0005.Paket.Version (System.Collections.Generic.IEnumerable`1[T] list) [0x0003a] in <41f6fff356524ab9ba75ab09719f3981>:0 
2018-11-27 14:49:44 -   at <StartupCode$FSI_0005>.$FSI_0005_XPlot.Plotly.Paket$fsx.main@ () [0x00029] in <41f6fff356524ab9ba75ab09719f3981>:0 
2018-11-27 14:49:44 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:49:44 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:44 - HttpRequestExceptionAn error occurred while sending the request
2018-11-27 14:49:44 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x00478] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:49:44 -   at Paket.NetUtils+_safeGetFromUrl@576-9.Invoke (System.Exception _arg5) [0x0015c] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at <StartupCode$FSharp-Core>.$Async+TryWith@1113-1[T].Invoke (System.Exception exn) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Control.AsyncPrimitives.CallFilterThenInvoke[T] (Microsoft.FSharp.Control.AsyncActivation`1[T] ctxt, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] catchFilter, System.Runtime.ExceptionServices.ExceptionDispatchInfo edi) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 -   at Microsoft.FSharp.Control.Trampoline.Execute (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] firstAction) [0x00020] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:49:44 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:44 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:44 -   at Paket.PackageResolver.getAndReport@994[a] (System.Int32 taskTimeout, Microsoft.FSharp.Collections.FSharpList`1[T] sources, Paket.Profile+BlockReason blockReason, Paket.PackageResolver+ResolverTaskMemory`1[a] mem) [0x0019a] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 -   at Paket.PackageResolver+getVersionsBlock@1057-1.GenerateNext (System.Collections.Generic.IEnumerable`1[System.Tuple`2[Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList`1[Paket.PackageSources+PackageSource]]]& next) [0x00101] in <5b8275d9a970bee8a7450383d975825b>:0 
2018-11-27 14:49:44 - WebExceptionError: NameResolutionFailure
2018-11-27 14:49:44 -   at System.Net.WebConnection.Connect (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x00044] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:44 -   at System.Net.WebConnection.InitConnection (System.Net.WebOperation operation, System.Threading.CancellationToken cancellationToken) [0x000cc] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:44 -   at System.Net.WebOperation.Run () [0x0009a] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:44 -   at System.Net.WebCompletionSource`1[T].WaitForCompletion () [0x00094] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:44 -   at System.Net.HttpWebRequest.RunWithTimeoutWorker[T] (System.Threading.Tasks.Task`1[TResult] workerTask, System.Int32 timeout, System.Action abort, System.Func`1[TResult] aborted, System.Threading.CancellationTokenSource cts) [0x000f8] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:44 -   at System.Net.HttpWebRequest.EndGetResponse (System.IAsyncResult asyncResult) [0x00020] in <c0e40d34c25e4827874530676d4126b9>:0 
2018-11-27 14:49:44 -   at System.Threading.Tasks.TaskFactory`1[TResult].FromAsyncCoreLogic (System.IAsyncResult iar, System.Func`2[T,TResult] endFunction, System.Action`1[T] endAction, System.Threading.Tasks.Task`1[TResult] promise, System.Boolean requiresSynchronization) [0x0000f] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 14:49:44 - --- End of stack trace from previous location where exception was thrown ---
2018-11-27 14:49:44 -   at System.Net.Http.HttpClientHandler.SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken) [0x0041d] in <c2f27c2d4962416e9d4b77597ba7a62e>:0 
2018-11-27 14:50:20 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 14:50:20 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 14:50:20 - For help type #help;;
2018-11-27 14:50:20 - > val it :
2018-11-27 14:50:20 -   ResizeArray<System.Type *
2018-11-27 14:50:20 -               (obj ->
2018-11-27 14:50:20 -                  seq<string *
2018-11-27 14:50:20 -                      string> *
2018-11-27 14:50:20 -                  string)>
2018-11-27 14:50:20 - = seq []
2018-11-27 14:50:20 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 14:50:20 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 14:50:20 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 14:50:21 - Reporting 0 opened comms
2018-11-27 14:50:21 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 14:50:21 - #load "XPlot.Plotly.fsx"
2018-11-27 14:50:21 - open XPlot.Plotly
2018-11-27 14:50:21 - open System
2018-11-27 14:50:30 - let f x = sin x / (1. + x ** 2.)
2018-11-27 14:50:31 - let h = 1.
2018-11-27 14:50:31 - let points = [-5. .. h .. 5.]
2018-11-27 14:50:33 - let P x = 
2018-11-27 14:50:33 -     let dividedDifferencesTable = 
2018-11-27 14:50:33 -         let rec computeCells y acc = 
2018-11-27 14:50:33 -             let computeCol n (prevCol : float list) =
2018-11-27 14:50:33 -                 let rec computeColInternal x acc =
2018-11-27 14:50:33 -                     match x with
2018-11-27 14:50:33 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 14:50:33 -                     | _ -> acc
2018-11-27 14:50:33 -                 computeColInternal (points.Length - n) [] 
2018-11-27 14:50:33 -             match y with
2018-11-27 14:50:33 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 14:50:33 -             |_ -> List.rev acc
2018-11-27 14:50:33 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 14:50:33 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 14:50:33 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 14:50:33 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 14:50:44 - let dP_1 x = (P (x + h) - P x) / h
2018-11-27 14:50:44 - let dP_2 x = (P x - P (x - h)) / h
2018-11-27 14:50:44 - let dP_3 x = (P (x + h) - P (x - h)) / (2. * h)
2018-11-27 14:50:44 - let dP_4 x = (-3. * P x + 4. * P (x + h) - P (x + 2. * h)) / (2. * h)
2018-11-27 14:50:44 - let dP_5 x = (-3. * P x - 4. * P (x - h) + P (x - 2. * h)) / (2. * h)
2018-11-27 14:50:44 - let dP_6 x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.)
2018-11-27 14:51:39 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-11-27 14:51:39 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-11-27 14:51:39 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-11-27 14:51:40 - let x = [-5. .. 0.01 .. 5.]
2018-11-27 14:51:40 - let trace1 =
2018-11-27 14:51:40 -     Scatter(
2018-11-27 14:51:40 -         x = x,
2018-11-27 14:51:40 -         y = (x |> List.map (fun i -> abs (f' i - dP_1 i))),
2018-11-27 14:51:40 -         name = "Погрешность 1)"
2018-11-27 14:51:40 -     )   
2018-11-27 14:51:40 - let trace2 =
2018-11-27 14:51:40 -     Scatter(
2018-11-27 14:51:40 -         x = x,
2018-11-27 14:51:40 -         y = (x |> List.map (fun i -> abs (f' i - dP_2 i))),
2018-11-27 14:51:40 -         name = "Погрешность 2)"
2018-11-27 14:51:40 -     )
2018-11-27 14:51:40 - let trace3 =
2018-11-27 14:51:40 -     Scatter(
2018-11-27 14:51:40 -         x = x,
2018-11-27 14:51:40 -         y = (x |> List.map (fun i -> abs (f' i - dP_3 i))),
2018-11-27 14:51:40 -         name = "Погрешность 3)"
2018-11-27 14:51:40 -     )
2018-11-27 14:51:40 - let trace4 =
2018-11-27 14:51:40 -     Scatter(
2018-11-27 14:51:40 -         x = x,
2018-11-27 14:51:40 -         y = (x |> List.map (fun i -> abs (f' i - dP_4 i))),
2018-11-27 14:51:40 -         name = "Погрешность 4)"
2018-11-27 14:51:40 -     )
2018-11-27 14:51:40 - let trace5 =
2018-11-27 14:51:40 -     Scatter(
2018-11-27 14:51:40 -         x = x,
2018-11-27 14:51:40 -         y = (x |> List.map (fun i -> abs (f' i - dP_5 i))),
2018-11-27 14:51:40 -         name = "Погрешность 5)"
2018-11-27 14:51:40 -     )
2018-11-27 14:51:40 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 14:51:40 - |> Chart.Plot
2018-11-27 14:51:40 - |> Chart.WithWidth 1000
2018-11-27 14:51:40 - |> Chart.WithHeight 700
2018-11-27 14:52:48 - let trace =
2018-11-27 14:52:48 -     Scatter(
2018-11-27 14:52:48 -         x = x,
2018-11-27 14:52:48 -         y = (x |> List.map (fun i -> abs (f'' i - dP_6 i))),
2018-11-27 14:52:48 -         name = "Погрешность 1)"
2018-11-27 14:52:48 -     )
2018-11-27 14:52:48 - [trace]
2018-11-27 14:52:48 - |> Chart.Plot
2018-11-27 14:52:48 - |> Chart.WithWidth 1000
2018-11-27 14:52:48 - |> Chart.WithHeight 700
2018-11-27 14:52:52 - let trace =
2018-11-27 14:52:52 -     Scatter(
2018-11-27 14:52:52 -         x = x,
2018-11-27 14:52:52 -         y = (x |> List.map (fun i -> abs (f'' i - dP_6 i))),
2018-11-27 14:52:52 -         name = "Погрешность 6)"
2018-11-27 14:52:52 -     )
2018-11-27 14:52:52 - [trace]
2018-11-27 14:52:52 - |> Chart.Plot
2018-11-27 14:52:52 - |> Chart.WithWidth 1000
2018-11-27 14:52:52 - |> Chart.WithHeight 700
2018-11-27 14:56:48 - P 1.5
2018-11-27 14:57:41 - let h = 0.1
2018-11-27 14:57:41 - let points = [-5. .. h .. 5.]
2018-11-27 14:57:41 - P 1.5
2018-11-27 14:59:36 - let newtonPoly x (points : float list) = 
2018-11-27 14:59:36 -     let dividedDifferencesTable = 
2018-11-27 14:59:36 -         let rec computeCells y acc = 
2018-11-27 14:59:36 -             let computeCol n (prevCol : float list) =
2018-11-27 14:59:36 -                 let rec computeColInternal x acc =
2018-11-27 14:59:36 -                     match x with
2018-11-27 14:59:36 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 14:59:36 -                     | _ -> acc
2018-11-27 14:59:36 -                 computeColInternal (points.Length - n) [] 
2018-11-27 14:59:36 -             match y with
2018-11-27 14:59:36 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 14:59:36 -             |_ -> List.rev acc
2018-11-27 14:59:36 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 14:59:36 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 14:59:36 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 14:59:36 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 14:59:36 - let P = newtonPoly points
2018-11-27 14:59:36 - This expression was expected to have type
2018-11-27 14:59:36 -     'float'    
2018-11-27 14:59:36 - but here has type
2018-11-27 14:59:36 -     'float list'    
2018-11-27 14:59:52 - let newtonPoly (points : float list) x = 
2018-11-27 14:59:52 -     let dividedDifferencesTable = 
2018-11-27 14:59:52 -         let rec computeCells y acc = 
2018-11-27 14:59:52 -             let computeCol n (prevCol : float list) =
2018-11-27 14:59:52 -                 let rec computeColInternal x acc =
2018-11-27 14:59:52 -                     match x with
2018-11-27 14:59:52 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 14:59:52 -                     | _ -> acc
2018-11-27 14:59:52 -                 computeColInternal (points.Length - n) [] 
2018-11-27 14:59:52 -             match y with
2018-11-27 14:59:52 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 14:59:52 -             |_ -> List.rev acc
2018-11-27 14:59:52 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 14:59:52 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 14:59:52 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 14:59:52 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 14:59:52 - let P = newtonPoly points
2018-11-27 14:59:55 - let dP_1 x = (P (x + h) - P x) / h
2018-11-27 14:59:55 - let dP_2 x = (P x - P (x - h)) / h
2018-11-27 14:59:55 - let dP_3 x = (P (x + h) - P (x - h)) / (2. * h)
2018-11-27 14:59:55 - let dP_4 x = (-3. * P x + 4. * P (x + h) - P (x + 2. * h)) / (2. * h)
2018-11-27 14:59:55 - let dP_5 x = (-3. * P x - 4. * P (x - h) + P (x - 2. * h)) / (2. * h)
2018-11-27 14:59:55 - let dP_6 x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.)
2018-11-27 14:59:56 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-11-27 14:59:56 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-11-27 14:59:56 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-11-27 14:59:57 - let x = [-5. .. 0.01 .. 5.]
2018-11-27 14:59:57 - let trace1 =
2018-11-27 14:59:57 -     Scatter(
2018-11-27 14:59:57 -         x = x,
2018-11-27 14:59:57 -         y = (x |> List.map (fun i -> abs (f' i - dP_1 i))),
2018-11-27 14:59:57 -         name = "Погрешность 1)"
2018-11-27 14:59:57 -     )   
2018-11-27 14:59:57 - let trace2 =
2018-11-27 14:59:57 -     Scatter(
2018-11-27 14:59:57 -         x = x,
2018-11-27 14:59:57 -         y = (x |> List.map (fun i -> abs (f' i - dP_2 i))),
2018-11-27 14:59:57 -         name = "Погрешность 2)"
2018-11-27 14:59:57 -     )
2018-11-27 14:59:57 - let trace3 =
2018-11-27 14:59:57 -     Scatter(
2018-11-27 14:59:57 -         x = x,
2018-11-27 14:59:57 -         y = (x |> List.map (fun i -> abs (f' i - dP_3 i))),
2018-11-27 14:59:57 -         name = "Погрешность 3)"
2018-11-27 14:59:57 -     )
2018-11-27 14:59:57 - let trace4 =
2018-11-27 14:59:57 -     Scatter(
2018-11-27 14:59:57 -         x = x,
2018-11-27 14:59:57 -         y = (x |> List.map (fun i -> abs (f' i - dP_4 i))),
2018-11-27 14:59:57 -         name = "Погрешность 4)"
2018-11-27 14:59:57 -     )
2018-11-27 14:59:57 - let trace5 =
2018-11-27 14:59:57 -     Scatter(
2018-11-27 14:59:57 -         x = x,
2018-11-27 14:59:57 -         y = (x |> List.map (fun i -> abs (f' i - dP_5 i))),
2018-11-27 14:59:57 -         name = "Погрешность 5)"
2018-11-27 14:59:57 -     )
2018-11-27 14:59:57 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 14:59:57 - |> Chart.Plot
2018-11-27 14:59:57 - |> Chart.WithWidth 1000
2018-11-27 14:59:57 - |> Chart.WithHeight 700
2018-11-27 15:00:15 - let trace =
2018-11-27 15:00:15 -     Scatter(
2018-11-27 15:00:15 -         x = x,
2018-11-27 15:00:15 -         y = (x |> List.map (fun i -> abs (f'' i - dP_6 i))),
2018-11-27 15:00:15 -         name = "Погрешность 6)"
2018-11-27 15:00:15 -     )
2018-11-27 15:00:15 - [trace]
2018-11-27 15:00:15 - |> Chart.Plot
2018-11-27 15:00:15 - |> Chart.WithWidth 1000
2018-11-27 15:00:15 - |> Chart.WithHeight 700
2018-11-27 15:00:30 - let f x = sin x / (1. + x ** 2.)
2018-11-27 15:00:30 - let h = 1.
2018-11-27 15:00:30 - let points = [-5. .. h .. 5.]
2018-11-27 15:00:31 - let newtonPoly (points : float list) x = 
2018-11-27 15:00:31 -     let dividedDifferencesTable = 
2018-11-27 15:00:31 -         let rec computeCells y acc = 
2018-11-27 15:00:31 -             let computeCol n (prevCol : float list) =
2018-11-27 15:00:31 -                 let rec computeColInternal x acc =
2018-11-27 15:00:31 -                     match x with
2018-11-27 15:00:31 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 15:00:31 -                     | _ -> acc
2018-11-27 15:00:31 -                 computeColInternal (points.Length - n) [] 
2018-11-27 15:00:31 -             match y with
2018-11-27 15:00:31 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 15:00:31 -             |_ -> List.rev acc
2018-11-27 15:00:31 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 15:00:31 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 15:00:31 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 15:00:31 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 15:00:31 - let P = newtonPoly points
2018-11-27 15:00:32 - let dP_1 x = (P (x + h) - P x) / h
2018-11-27 15:00:32 - let dP_2 x = (P x - P (x - h)) / h
2018-11-27 15:00:32 - let dP_3 x = (P (x + h) - P (x - h)) / (2. * h)
2018-11-27 15:00:32 - let dP_4 x = (-3. * P x + 4. * P (x + h) - P (x + 2. * h)) / (2. * h)
2018-11-27 15:00:32 - let dP_5 x = (-3. * P x - 4. * P (x - h) + P (x - 2. * h)) / (2. * h)
2018-11-27 15:00:32 - let dP_6 x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.)
2018-11-27 15:00:33 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-11-27 15:00:33 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-11-27 15:00:33 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-11-27 15:00:34 - let x = [-5. .. 0.01 .. 5.]
2018-11-27 15:00:34 - let trace1 =
2018-11-27 15:00:34 -     Scatter(
2018-11-27 15:00:34 -         x = x,
2018-11-27 15:00:34 -         y = (x |> List.map (fun i -> abs (f' i - dP_1 i))),
2018-11-27 15:00:34 -         name = "Погрешность 1)"
2018-11-27 15:00:34 -     )   
2018-11-27 15:00:34 - let trace2 =
2018-11-27 15:00:34 -     Scatter(
2018-11-27 15:00:34 -         x = x,
2018-11-27 15:00:34 -         y = (x |> List.map (fun i -> abs (f' i - dP_2 i))),
2018-11-27 15:00:34 -         name = "Погрешность 2)"
2018-11-27 15:00:34 -     )
2018-11-27 15:00:34 - let trace3 =
2018-11-27 15:00:34 -     Scatter(
2018-11-27 15:00:34 -         x = x,
2018-11-27 15:00:34 -         y = (x |> List.map (fun i -> abs (f' i - dP_3 i))),
2018-11-27 15:00:34 -         name = "Погрешность 3)"
2018-11-27 15:00:34 -     )
2018-11-27 15:00:34 - let trace4 =
2018-11-27 15:00:34 -     Scatter(
2018-11-27 15:00:34 -         x = x,
2018-11-27 15:00:34 -         y = (x |> List.map (fun i -> abs (f' i - dP_4 i))),
2018-11-27 15:00:34 -         name = "Погрешность 4)"
2018-11-27 15:00:34 -     )
2018-11-27 15:00:34 - let trace5 =
2018-11-27 15:00:34 -     Scatter(
2018-11-27 15:00:34 -         x = x,
2018-11-27 15:00:34 -         y = (x |> List.map (fun i -> abs (f' i - dP_5 i))),
2018-11-27 15:00:34 -         name = "Погрешность 5)"
2018-11-27 15:00:34 -     )
2018-11-27 15:00:34 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 15:00:34 - |> Chart.Plot
2018-11-27 15:00:34 - |> Chart.WithWidth 1000
2018-11-27 15:00:34 - |> Chart.WithHeight 700
2018-11-27 15:00:35 - let trace =
2018-11-27 15:00:35 -     Scatter(
2018-11-27 15:00:35 -         x = x,
2018-11-27 15:00:35 -         y = (x |> List.map (fun i -> abs (f'' i - dP_6 i))),
2018-11-27 15:00:35 -         name = "Погрешность 6)"
2018-11-27 15:00:35 -     )
2018-11-27 15:00:35 - [trace]
2018-11-27 15:00:35 - |> Chart.Plot
2018-11-27 15:00:35 - |> Chart.WithWidth 1000
2018-11-27 15:00:35 - |> Chart.WithHeight 700
2018-11-27 15:01:17 - let h = 0.1
2018-11-27 15:01:17 - let points = [-5. .. h .. 5.]
2018-11-27 15:01:17 - newtonPoly points 1.5
2018-11-27 15:01:24 - let h = 0.01
2018-11-27 15:01:24 - let points = [-5. .. h .. 5.]
2018-11-27 15:01:24 - newtonPoly points 1.5
2018-11-27 15:03:54 - let h = 0.1
2018-11-27 15:03:54 - let points = [-5. .. h .. 5.]
2018-11-27 15:03:54 - newtonPoly points 1.5
2018-11-27 15:03:59 - let h = 1
2018-11-27 15:03:59 - let points = [-5. .. h .. 5.]
2018-11-27 15:03:59 - newtonPoly points 1.5
2018-11-27 15:03:59 - The type 'int' does not match the type 'float'
2018-11-27 15:04:02 - let h = 1.
2018-11-27 15:04:02 - let points = [-5. .. h .. 5.]
2018-11-27 15:04:02 - newtonPoly points 1.5
2018-11-27 15:04:05 - let h = 0.1.
2018-11-27 15:04:05 - let points = [-5. .. h .. 5.]
2018-11-27 15:04:05 - newtonPoly points 1.5
2018-11-27 15:04:05 - Missing qualification after '.'
2018-11-27 15:04:10 - let h = 0.1
2018-11-27 15:04:10 - let points = [-5. .. h .. 5.]
2018-11-27 15:04:10 - newtonPoly points 1.5
2018-11-27 15:04:17 - let h = 0.5
2018-11-27 15:04:17 - let points = [-5. .. h .. 5.]
2018-11-27 15:04:17 - newtonPoly points 1.5
2018-11-27 15:05:03 - let h = 0.5
2018-11-27 15:05:03 - let points = [-5. .. h .. 5.]
2018-11-27 15:05:03 - newtonPoly points 1.5, f 1.5
2018-11-27 15:05:12 - let h = 0.1
2018-11-27 15:05:12 - let points = [-5. .. h .. 5.]
2018-11-27 15:05:12 - newtonPoly points 1.5, f 1.5
2018-11-27 15:07:07 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 15:07:07 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 15:07:07 - For help type #help;;
2018-11-27 15:07:07 - > val it :
2018-11-27 15:07:07 -   ResizeArray<System.Type *
2018-11-27 15:07:07 -               (obj ->
2018-11-27 15:07:07 -                  seq<string *
2018-11-27 15:07:07 -                      string> *
2018-11-27 15:07:07 -                  string)>
2018-11-27 15:07:07 - = seq []
2018-11-27 15:07:07 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 15:07:07 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 15:07:07 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 15:07:08 - Reporting 0 opened comms
2018-11-27 15:08:27 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 15:08:27 - #load "XPlot.Plotly.fsx"
2018-11-27 15:08:27 - open XPlot.Plotly
2018-11-27 15:08:27 - open System
2018-11-27 15:08:31 - let N = 5.
2018-11-27 15:08:31 - let f (x : float) = x * exp (x * (N % 2. + 1.)) + sin (x / 2. * (N % 7. + 1.))
2018-11-27 15:08:31 - let x0 = - (N % 3.)
2018-11-27 15:08:31 - let points = [x0; x0 + 0.1; x0 + 0.3; x0 + 0.45; x0 + 0.5]
2018-11-27 15:08:39 - let NewtonPolynomial (points : float list) x = 
2018-11-27 15:08:39 -     let dividedDifferencesTable = 
2018-11-27 15:08:39 -         let rec computeCells y acc = 
2018-11-27 15:08:39 -             let computeCol n (prevCol : float list) =
2018-11-27 15:08:39 -                 let rec computeColInternal x acc =
2018-11-27 15:08:39 -                     match x with
2018-11-27 15:08:39 -                     | _ when x > 0 -> computeColInternal (x - 1) (((prevCol.[x] - prevCol.[x - 1]) / (points.[x + n - 1] - points.[x - 1])) :: acc)
2018-11-27 15:08:39 -                     | _ -> acc
2018-11-27 15:08:39 -                 computeColInternal (points.Length - n) [] 
2018-11-27 15:08:39 -             match y with
2018-11-27 15:08:39 -             |_ when y > 0 -> computeCells (y - 1) ((computeCol (points.Length - y) acc.[0]) :: acc)
2018-11-27 15:08:39 -             |_ -> List.rev acc
2018-11-27 15:08:39 -         computeCells (points.Length - 1) [points |> List.map f; points]
2018-11-27 15:08:39 -     let multiply = 1. :: ([0 .. points.Length - 2] |> List.mapFold (fun acc k -> ((x - points.[k]) * acc, (x - points.[k]) * acc)) 1. |> fst)
2018-11-27 15:08:39 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 15:08:39 -     [0 .. points.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 15:08:39 - let NewtonPolynomialPoints = NewtonPolynomial points
2018-11-27 15:10:39 - let h = 0.1
2018-11-27 15:10:39 - let points = [-5. .. h .. 5.]
2018-11-27 15:10:39 - NewtonPolynomial points 1.5, f 1.5 
2018-11-27 15:10:54 - let h = 0.5
2018-11-27 15:10:54 - let points = [-5. .. h .. 5.]
2018-11-27 15:10:54 - NewtonPolynomial points 1.5, f 1.5 
2018-11-27 15:11:13 - let h = 0.1
2018-11-27 15:11:13 - let points = [-5. .. h .. 5.]
2018-11-27 15:11:13 - NewtonPolynomial points 1.5, f 1.5 
2018-11-27 15:11:33 - let h = 0.01
2018-11-27 15:11:33 - let points = [-5. .. h .. 5.]
2018-11-27 15:11:33 - NewtonPolynomial points 1.5, f 1.5 
2018-11-27 15:31:39 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 15:31:39 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 15:31:39 - For help type #help;;
2018-11-27 15:31:39 - > val it :
2018-11-27 15:31:39 -   ResizeArray<System.Type *
2018-11-27 15:31:39 -               (obj ->
2018-11-27 15:31:39 -                  seq<string *
2018-11-27 15:31:39 -                      string> *
2018-11-27 15:31:39 -                  string)>
2018-11-27 15:31:39 - = seq []
2018-11-27 15:31:39 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 15:31:39 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 15:31:39 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 15:31:40 - Reporting 0 opened comms
2018-11-27 15:46:30 - ## Метод Эйлера
2018-11-27 15:46:30 - Считаем интерграл по формуле левых прямоугольников.
2018-11-27 15:46:30 - $y_{i+1} = y_i + \int_x_i^{x_i+h} f(t, y(t))dt = y_i + h f(x_i,y_i), \, i = 0, \dots N-1$
2018-11-27 15:46:30 - Погрешность h:
2018-11-27 15:46:30 - $max_{i=1,\dots N-1}|y(x_i)-y_i| <= C h$
2018-11-27 15:46:30 - Unexpected symbol # in directive. Expected identifier or other token.
2018-11-27 15:46:30 - parse error
2018-11-27 16:03:19 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 16:03:19 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 16:03:19 - For help type #help;;
2018-11-27 16:03:19 - > val it :
2018-11-27 16:03:19 -   ResizeArray<System.Type *
2018-11-27 16:03:19 -               (obj ->
2018-11-27 16:03:19 -                  seq<string *
2018-11-27 16:03:19 -                      string> *
2018-11-27 16:03:19 -                  string)>
2018-11-27 16:03:19 - = seq []
2018-11-27 16:03:19 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 16:03:19 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 16:03:19 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 16:03:21 - Reporting 0 opened comms
2018-11-27 16:24:04 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 16:24:04 - #load "XPlot.Plotly.fsx"
2018-11-27 16:24:04 - open XPlot.Plotly
2018-11-27 16:24:04 - open System
2018-11-27 16:24:09 - let N = 5.
2018-11-27 16:24:09 - let x0 = -(N % 3.)
2018-11-27 16:24:09 - let xm = x0 + 1.
2018-11-27 16:24:09 - let h = 0.01
2018-11-27 16:24:09 - let points = [x0 .. h .. xm]
2018-11-27 16:24:09 - let f (x : float) = x * exp (x * (N % 2. + 1.)) + sin (x / 2. * (N % 7. + 1.))
2018-11-27 16:24:09 - let finiteDifferencesTable = 
2018-11-27 16:24:09 -     let rec computeCells y acc = 
2018-11-27 16:24:09 -         let computeCol (prevCol : float list) =
2018-11-27 16:24:09 -             let rec computeColInternal x acc =
2018-11-27 16:24:09 -                 match x with
2018-11-27 16:24:09 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-11-27 16:24:09 -                 | _ -> acc
2018-11-27 16:24:09 -             computeColInternal y [] 
2018-11-27 16:24:09 -         match y with
2018-11-27 16:24:09 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-11-27 16:24:09 -         |_ -> List.rev acc
2018-11-27 16:24:09 -     computeCells (points.Length - 1) [points |> List.map f]
2018-11-27 16:24:09 - //first case
2018-11-27 16:24:09 - let polynom n x =
2018-11-27 16:24:09 -     let t = (x - x0) / h
2018-11-27 16:24:09 -     let Nk =
2018-11-27 16:24:09 -         let rec NkInternal prev i = seq{
2018-11-27 16:24:09 -             match i with
2018-11-27 16:24:09 -             | _ when int i = n - 1 -> yield prev * (t - i) /  (i + 1.)
2018-11-27 16:24:09 -             | 0. -> yield t
2018-11-27 16:24:09 -                     yield! NkInternal t (i + 1.)
2018-11-27 16:24:09 -             | _ ->  let cur = prev * (t - i) /  (i + 1.)
2018-11-27 16:24:09 -                     yield cur
2018-11-27 16:24:09 -                     yield! NkInternal cur (i + 1.)
2018-11-27 16:24:09 -         }
2018-11-27 16:24:09 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 16:24:09 -     let rec polynomInternal nki (finiteDifference : float list list) k acc =
2018-11-27 16:24:09 -         match nki, finiteDifference with
2018-11-27 16:24:09 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) when k < n -> polynomInternal tNki tFiniteDifference (k + 1) (acc + hNki * (hFiniteDifference |> List.head)) 
2018-11-27 16:24:09 -         | _ -> acc
2018-11-27 16:24:09 -     polynomInternal Nk finiteDifferencesTable.Tail 0 (f x0)
2018-11-27 16:24:09 - let plotFirstCaseError () =
2018-11-27 16:24:09 -     let trace1 =
2018-11-27 16:24:09 -         let y = points |> List.map f
2018-11-27 16:24:09 -         Scatter(
2018-11-27 16:24:09 -             x = points,
2018-11-27 16:24:09 -             y = y,
2018-11-27 16:24:09 -             name = "Исходная функция"
2018-11-27 16:24:09 -         )
2018-11-27 16:24:09 -     let trace2 =
2018-11-27 16:24:09 -         let y = points |> List.map (polynom 1)
2018-11-27 16:24:09 -         Scatter(
2018-11-27 16:24:09 -             x = points,
2018-11-27 16:24:09 -             y = y,
2018-11-27 16:24:09 -             name = "Интерполяционный полином"
2018-11-27 16:24:09 -         )
2018-11-27 16:24:09 -     [trace1; trace2]
2018-11-27 16:24:09 -     |> Chart.Plot
2018-11-27 16:24:09 -     |> Chart.WithWidth 1000
2018-11-27 16:24:09 -     |> Chart.WithHeight 700
2018-11-27 16:24:09 - plotFirstCaseError()
2018-11-27 16:24:09 - //second case
2018-11-27 16:24:09 - let polynom2 n x =
2018-11-27 16:24:09 -     let t = (x - xm) / h
2018-11-27 16:24:09 -     let Nk =
2018-11-27 16:24:09 -         let rec NkInternal prev i = seq{
2018-11-27 16:24:09 -             match i with
2018-11-27 16:24:09 -             | _ when int i = n - 1 -> yield prev * (t + i) /  (i + 1.)
2018-11-27 16:24:09 -             | 0. -> yield t
2018-11-27 16:24:09 -                     yield! NkInternal t (i + 1.)
2018-11-27 16:24:09 -             | _ ->  let cur = prev * (t + i) /  (i + 1.)
2018-11-27 16:24:09 -                     yield cur
2018-11-27 16:24:09 -                     yield! NkInternal cur (i + 1.)
2018-11-27 16:24:09 -         }
2018-11-27 16:24:09 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 16:24:09 -     
2018-11-27 16:24:09 -     let rec polynom2Internal nki (finiteDifference : float list list) k acc =
2018-11-27 16:24:09 -         match nki, finiteDifference with
2018-11-27 16:24:09 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) when k < n -> polynom2Internal tNki tFiniteDifference (k + 1) (acc + hNki * (hFiniteDifference |> List.last)) 
2018-11-27 16:24:09 -         | _ -> acc
2018-11-27 16:24:09 -     polynom2Internal Nk finiteDifferencesTable.Tail 0 (f xm)
2018-11-27 16:24:09 - let plotSecondCaseError () =
2018-11-27 16:24:09 -     let trace1 =
2018-11-27 16:24:09 -         let y = points |> List.map f
2018-11-27 16:24:09 -         Scatter(
2018-11-27 16:24:09 -             x = points,
2018-11-27 16:24:09 -             y = y,
2018-11-27 16:24:09 -             name = "Исходная функция"
2018-11-27 16:24:09 -         )
2018-11-27 16:24:09 -     let trace2 =
2018-11-27 16:24:09 -         let y = points |> List.map (polynom2 4)
2018-11-27 16:24:09 -         Scatter(
2018-11-27 16:24:09 -             x = points,
2018-11-27 16:24:09 -             y = y,
2018-11-27 16:24:09 -             name = "Интерполяционный полином"
2018-11-27 16:24:09 -         )
2018-11-27 16:24:09 -     [trace1; trace2]
2018-11-27 16:24:09 -     |> Chart.Plot
2018-11-27 16:24:09 -     |> Chart.WithWidth 1000
2018-11-27 16:24:09 -     |> Chart.WithHeight 700
2018-11-27 16:24:09 - plotSecondCaseError()
2018-11-27 16:24:09 - //third case
2018-11-27 16:24:09 - let polynom3 n x =
2018-11-27 16:24:09 -     let startX = points |> List.filter (fun i -> x > i - h / 2. && x <= i + h / 2.) |> List.exactlyOne
2018-11-27 16:24:09 -     let isRightSide = x <= startX + h / 2. && x > startX
2018-11-27 16:24:09 -     let middlePoint = points |> List.findIndex (fun i -> i = startX)
2018-11-27 16:24:09 -     let dependenceOfSide rightSide = 
2018-11-27 16:24:09 -         match rightSide with
2018-11-27 16:24:09 -         | false -> (n + 1) / 2
2018-11-27 16:24:09 -         | true -> n / 2
2018-11-27 16:24:09 -     let startIndex = middlePoint - (dependenceOfSide isRightSide)
2018-11-27 16:24:09 -     let endIndex = middlePoint + (dependenceOfSide <| not isRightSide)
2018-11-27 16:24:09 -     let t = (x - startX) / h
2018-11-27 16:24:09 -     let Nk =
2018-11-27 16:24:09 -         let rec NkInternal prev i =
2018-11-27 16:24:09 -             let deg = 
2018-11-27 16:24:09 -                 match n % 2 = 0 with
2018-11-27 16:24:09 -                 | true -> i + 1.
2018-11-27 16:24:09 -                 | false -> i
2018-11-27 16:24:09 -             seq{
2018-11-27 16:24:09 -                 match i with
2018-11-27 16:24:09 -                 | _ when int i = n - 1 -> yield prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 16:24:09 -                 | 0. -> yield t
2018-11-27 16:24:09 -                         yield! NkInternal t (i + 1.)
2018-11-27 16:24:09 -                 | _ ->  let cur = prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 16:24:09 -                         yield cur
2018-11-27 16:24:09 -                         yield! NkInternal cur (i + 1.)
2018-11-27 16:24:09 -             }
2018-11-27 16:24:09 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 16:24:09 -     
2018-11-27 16:24:09 -     let middle =
2018-11-27 16:24:09 -         let rec truncateFiniteDiff (finiteDifference : float list list) k acc =
2018-11-27 16:24:09 -             match finiteDifference with
2018-11-27 16:24:09 -             | (h :: t) when k <= n -> truncateFiniteDiff t (k + 1) ((h |> List.indexed |> List.filter (fun (i, _) -> i >= startIndex && i <= endIndex - k) |> List.map (snd)) :: acc)
2018-11-27 16:24:09 -             | _ -> acc |> List.rev
2018-11-27 16:24:09 -         truncateFiniteDiff finiteDifferencesTable 0 []
2018-11-27 16:24:09 -     let rec polynom3Internal nki (finiteDifference : float list list) acc =
2018-11-27 16:24:09 -         match nki, finiteDifference with
2018-11-27 16:24:09 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) -> polynom3Internal tNki tFiniteDifference (acc + hNki * hFiniteDifference.[(hFiniteDifference.Length - 1) / 2])
2018-11-27 16:24:09 -         | _ -> acc
2018-11-27 16:24:09 -     
2018-11-27 16:24:09 -     match startIndex, endIndex with
2018-11-27 16:24:09 -     | (s, e) when s >= 0 && e < points.Length -> polynom3Internal Nk middle.Tail (f startX)
2018-11-27 16:24:09 -     | (s, e) when s >= 0 -> polynom2 n x
2018-11-27 16:24:09 -     | (s, e) when e < points.Length -> polynom n x
2018-11-27 16:24:09 -     | _ -> failwith "Incorrect arguments"
2018-11-27 16:24:09 - let plotThirdCaseError () =
2018-11-27 16:24:09 -     let trace1 =
2018-11-27 16:24:09 -         let y = points |> List.map f
2018-11-27 16:24:09 -         Scatter(
2018-11-27 16:24:09 -             x = points,
2018-11-27 16:24:09 -             y = y,
2018-11-27 16:24:09 -             name = "Исходная функция"
2018-11-27 16:24:09 -         )
2018-11-27 16:24:09 -     let trace2 =
2018-11-27 16:24:09 -         let y = points |> List.map (polynom3 1)
2018-11-27 16:24:09 -         Scatter(
2018-11-27 16:24:09 -             x = points,
2018-11-27 16:24:09 -             y = y,
2018-11-27 16:24:09 -             name = "Интерполяционный полином"
2018-11-27 16:24:09 -         )
2018-11-27 16:24:09 -     [trace1; trace2]
2018-11-27 16:24:09 -     |> Chart.Plot
2018-11-27 16:24:09 -     |> Chart.WithWidth 1000
2018-11-27 16:24:09 -     |> Chart.WithHeight 700
2018-11-27 16:24:09 - plotThirdCaseError()
2018-11-27 16:24:09 - let x = -1.455 //значение из отрезка [-2; -1]
2018-11-27 16:24:09 - let n = 8 //степень полинома
2018-11-27 16:24:09 - polynom n x - f x |> abs;;
2018-11-27 16:24:09 - polynom2 n x - f x |> abs;;
2018-11-27 16:24:09 - polynom3 n x - f x |> abs;;
2018-11-27 16:26:20 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 16:26:20 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 16:26:20 - For help type #help;;
2018-11-27 16:26:20 - > val it :
2018-11-27 16:26:20 -   ResizeArray<System.Type *
2018-11-27 16:26:20 -               (obj ->
2018-11-27 16:26:20 -                  seq<string *
2018-11-27 16:26:20 -                      string> *
2018-11-27 16:26:20 -                  string)>
2018-11-27 16:26:20 - = seq []
2018-11-27 16:26:20 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-27 16:26:20 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 16:26:20 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 16:26:22 - Reporting 0 opened comms
2018-11-27 16:26:25 - #load "XPlot.Plotly.Paket.fsx"
2018-11-27 16:26:25 - #load "XPlot.Plotly.fsx"
2018-11-27 16:26:25 - open XPlot.Plotly
2018-11-27 16:26:25 - open System
2018-11-27 16:26:31 - let N = 5.
2018-11-27 16:26:31 - let f (x : float) = x * exp (x * (N % 2. + 1.)) + sin (x / 2. * (N % 7. + 1.))
2018-11-27 16:26:31 - let x0 = - (N % 3.)
2018-11-27 16:26:31 - let xPoints = [x0; x0 + 0.3; x0 + 0.5]
2018-11-27 16:26:31 - let rs = [1.; 2.; 3.]
2018-11-27 16:26:31 - let yPoints =
2018-11-27 16:26:31 -     let rec addWhileNotZero x r acc =  if int r > 0 then addWhileNotZero x (r - 1.) (x :: acc)
2018-11-27 16:26:31 -                                        else acc 
2018-11-27 16:26:31 -     let rec yPointInternal x r acc =
2018-11-27 16:26:31 -         match x, r with
2018-11-27 16:26:31 -         | (xh :: xt), (rh :: rt) -> yPointInternal xt rt <| addWhileNotZero xh rh acc
2018-11-27 16:26:31 -         | _ -> List.rev acc
2018-11-27 16:26:31 -     yPointInternal xPoints rs []
2018-11-27 16:26:31 - yPoints, xPoints
2018-11-27 16:26:31 - let f' (x : float) = exp (2. * x) * (1. + 2. * x) + 3. * cos (3. * x)
2018-11-27 16:26:31 - let f'' (x : float) = 4. * exp (2. * x) * (1. + x) - 9. * sin (3. * x)
2018-11-27 16:26:31 - let df j = 
2018-11-27 16:26:31 -     match j with
2018-11-27 16:26:31 -     | 0 -> f
2018-11-27 16:26:31 -     | 1 -> f'
2018-11-27 16:26:31 -     | 2 -> f''
2018-11-27 16:26:31 -     | _ -> failwith "unexpected derivative number"
2018-11-27 16:26:31 - let factorial n = [1 .. n] |> List.reduce (*)
2018-11-27 16:26:31 - let dividedDifferencesTable = 
2018-11-27 16:26:31 -     let rec computeCells y (acc : float list list) = 
2018-11-27 16:26:31 -         let computeCol n (prevCol : float list) =
2018-11-27 16:26:31 -             let rec computeColInternal x acc =
2018-11-27 16:26:31 -                 match x with
2018-11-27 16:26:31 -                 | _ when x > 0 && yPoints.[x + n - 1] - yPoints.[x - 1] <> 0. -> 
2018-11-27 16:26:31 -                                 ((prevCol.[x] - prevCol.[x - 1]) / (yPoints.[x + n - 1] - yPoints.[x - 1])) :: acc |> computeColInternal (x - 1)
2018-11-27 16:26:31 -                 | _ when x > 0 -> (df n yPoints.[x - 1]) / (float <| factorial n)  :: acc |> computeColInternal (x - 1)
2018-11-27 16:26:31 -                 | _ -> acc
2018-11-27 16:26:31 -             computeColInternal (yPoints.Length - n) [] 
2018-11-27 16:26:31 -         match y with
2018-11-27 16:26:31 -         |_ when y > 0 -> (computeCol (yPoints.Length - y) acc.[0]) :: acc |> computeCells (y - 1)
2018-11-27 16:26:31 -         |_ -> List.rev acc
2018-11-27 16:26:31 -     computeCells (yPoints.Length - 1) [yPoints |> List.map f; yPoints]
2018-11-27 16:26:31 - dividedDifferencesTable
2018-11-27 16:26:31 - let P x = 
2018-11-27 16:26:31 -     let multiply = 1. :: ([0 .. yPoints.Length - 2] |> List.mapFold (fun acc k -> ((x - yPoints.[k]) * acc, (x - yPoints.[k]) * acc)) 1. |> fst)
2018-11-27 16:26:31 -     let term k = dividedDifferencesTable.[k + 1].[0] * multiply.[k]
2018-11-27 16:26:31 -     [0 .. yPoints.Length - 1] |> List.sumBy (fun k -> term k)
2018-11-27 16:26:31 - let h = 0.0001
2018-11-27 16:26:31 - let P' x = (P (x + h) - P x) / h
2018-11-27 16:26:31 - let P'' x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.) 
2018-11-27 16:26:31 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 16:26:31 - let trace1 =
2018-11-27 16:26:31 -     Scatter(
2018-11-27 16:26:31 -         x = x,
2018-11-27 16:26:31 -         y = (x |> List.map f),
2018-11-27 16:26:31 -         name = "Исходная функция"
2018-11-27 16:26:31 -     )
2018-11-27 16:26:31 - let trace2 =
2018-11-27 16:26:31 -     Scatter(
2018-11-27 16:26:31 -         x = x,
2018-11-27 16:26:31 -         y = (x |> List.map P),
2018-11-27 16:26:31 -         name = "Полином"
2018-11-27 16:26:31 -     )    
2018-11-27 16:26:31 - [trace1; trace2]
2018-11-27 16:26:31 - |> Chart.Plot
2018-11-27 16:26:31 - |> Chart.WithWidth 1000
2018-11-27 16:26:31 - |> Chart.WithHeight 700
2018-11-27 16:26:32 - let x = -1.33
2018-11-27 16:26:32 - abs (f x - P x)
2018-11-27 16:26:32 - abs (f' x - P' x)
2018-11-27 16:26:32 - abs (f'' x - P'' x)
2018-11-27 16:26:32 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 16:26:32 - let trace =
2018-11-27 16:26:32 -     Scatter(
2018-11-27 16:26:32 -         x = x,
2018-11-27 16:26:32 -         y = (x |> List.map (fun i -> abs (f i - P i))),
2018-11-27 16:26:32 -         name = "Исходная функция"
2018-11-27 16:26:32 -     )   
2018-11-27 16:26:32 - [trace]
2018-11-27 16:26:32 - |> Chart.Plot
2018-11-27 16:26:32 - |> Chart.WithWidth 1000
2018-11-27 16:26:32 - |> Chart.WithHeight 700
2018-11-27 16:26:32 - let trace =
2018-11-27 16:26:32 -     Scatter(
2018-11-27 16:26:32 -         x = x,
2018-11-27 16:26:32 -         y = (x |> List.map (fun i -> abs (f' i - P' i))),
2018-11-27 16:26:32 -         name = "Исходная функция"
2018-11-27 16:26:32 -     )   
2018-11-27 16:26:32 - [trace]
2018-11-27 16:26:32 - |> Chart.Plot
2018-11-27 16:26:32 - |> Chart.WithWidth 1000
2018-11-27 16:26:32 - |> Chart.WithHeight 700
2018-11-27 16:26:32 - let trace =
2018-11-27 16:26:32 -     Scatter(
2018-11-27 16:26:32 -         x = x,
2018-11-27 16:26:32 -         y = (x |> List.map (fun i -> abs (f'' i - P'' i))),
2018-11-27 16:26:32 -         name = "Исходная функция"
2018-11-27 16:26:32 -     )   
2018-11-27 16:26:32 - [trace]
2018-11-27 16:26:32 - |> Chart.Plot
2018-11-27 16:26:32 - |> Chart.WithWidth 1000
2018-11-27 16:26:32 - |> Chart.WithHeight 700
2018-11-27 16:28:20 - let df_1 x = (f (x + h) - f x) / h
2018-11-27 16:28:20 - let df_2 x = (f x - f (x - h)) / h
2018-11-27 16:28:20 - let df_3 x = (f (x + h) - f (x - h)) / (2. * h)
2018-11-27 16:28:20 - let df_4 x = (-3. * f x + 4. * f (x + h) - f (x + 2. * h)) / (2. * h)
2018-11-27 16:28:20 - let df_5 x = (-3. * f x - 4. * f (x - h) + f (x - 2. * h)) / (2. * h)
2018-11-27 16:28:20 - let df_6 x = (f (x + h) - 2. * f x + f (x - h)) / (h ** 2.)
2018-11-27 16:28:34 - let x = [-5. .. 0.01 .. 5.]
2018-11-27 16:28:34 - let trace1 =
2018-11-27 16:28:34 -     Scatter(
2018-11-27 16:28:34 -         x = x,
2018-11-27 16:28:34 -         y = (x |> List.map (fun i -> abs (f' i - df_1 i))),
2018-11-27 16:28:34 -         name = "Погрешность 1)"
2018-11-27 16:28:34 -     )   
2018-11-27 16:28:34 - let trace2 =
2018-11-27 16:28:34 -     Scatter(
2018-11-27 16:28:34 -         x = x,
2018-11-27 16:28:34 -         y = (x |> List.map (fun i -> abs (f' i - df_2 i))),
2018-11-27 16:28:34 -         name = "Погрешность 2)"
2018-11-27 16:28:34 -     )
2018-11-27 16:28:34 - let trace3 =
2018-11-27 16:28:34 -     Scatter(
2018-11-27 16:28:34 -         x = x,
2018-11-27 16:28:34 -         y = (x |> List.map (fun i -> abs (f' i - df_3 i))),
2018-11-27 16:28:34 -         name = "Погрешность 3)"
2018-11-27 16:28:34 -     )
2018-11-27 16:28:34 - let trace4 =
2018-11-27 16:28:34 -     Scatter(
2018-11-27 16:28:34 -         x = x,
2018-11-27 16:28:34 -         y = (x |> List.map (fun i -> abs (f' i - df_4 i))),
2018-11-27 16:28:34 -         name = "Погрешность 4)"
2018-11-27 16:28:34 -     )
2018-11-27 16:28:34 - let trace5 =
2018-11-27 16:28:34 -     Scatter(
2018-11-27 16:28:34 -         x = x,
2018-11-27 16:28:34 -         y = (x |> List.map (fun i -> abs (f' i - df_5 i))),
2018-11-27 16:28:34 -         name = "Погрешность 5)"
2018-11-27 16:28:34 -     )
2018-11-27 16:28:34 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 16:28:34 - |> Chart.Plot
2018-11-27 16:28:34 - |> Chart.WithWidth 1000
2018-11-27 16:28:34 - |> Chart.WithHeight 700
2018-11-27 16:29:08 - let trace =
2018-11-27 16:29:08 -     Scatter(
2018-11-27 16:29:08 -         x = x,
2018-11-27 16:29:08 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 i))),
2018-11-27 16:29:08 -         name = "Погрешность 6)"
2018-11-27 16:29:08 -     )
2018-11-27 16:29:08 - [trace]
2018-11-27 16:29:08 - |> Chart.Plot
2018-11-27 16:29:08 - |> Chart.WithWidth 1000
2018-11-27 16:29:08 - |> Chart.WithHeight 700
2018-11-27 16:34:48 - let x = [-5. .. 0.01 .. 5.]
2018-11-27 16:34:48 - let trace1 =
2018-11-27 16:34:48 -     Scatter(
2018-11-27 16:34:48 -         x = x,
2018-11-27 16:34:48 -         y = (x |> List.map (fun i -> abs (f' i - df_1 1. i))),
2018-11-27 16:34:48 -         name = "Погрешность 1)"
2018-11-27 16:34:48 -     )   
2018-11-27 16:34:48 - let trace2 =
2018-11-27 16:34:48 -     Scatter(
2018-11-27 16:34:48 -         x = x,
2018-11-27 16:34:48 -         y = (x |> List.map (fun i -> abs (f' i - df_2 1. i))),
2018-11-27 16:34:48 -         name = "Погрешность 2)"
2018-11-27 16:34:48 -     )
2018-11-27 16:34:48 - let trace3 =
2018-11-27 16:34:48 -     Scatter(
2018-11-27 16:34:48 -         x = x,
2018-11-27 16:34:48 -         y = (x |> List.map (fun i -> abs (f' i - df_3 1. i))),
2018-11-27 16:34:48 -         name = "Погрешность 3)"
2018-11-27 16:34:48 -     )
2018-11-27 16:34:48 - let trace4 =
2018-11-27 16:34:48 -     Scatter(
2018-11-27 16:34:48 -         x = x,
2018-11-27 16:34:48 -         y = (x |> List.map (fun i -> abs (f' i - df_4 1. i))),
2018-11-27 16:34:48 -         name = "Погрешность 4)"
2018-11-27 16:34:48 -     )
2018-11-27 16:34:48 - let trace5 =
2018-11-27 16:34:48 -     Scatter(
2018-11-27 16:34:48 -         x = x,
2018-11-27 16:34:48 -         y = (x |> List.map (fun i -> abs (f' i - df_5 1. i))),
2018-11-27 16:34:48 -         name = "Погрешность 5)"
2018-11-27 16:34:48 -     )
2018-11-27 16:34:48 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 16:34:48 - |> Chart.Plot
2018-11-27 16:34:48 - |> Chart.WithWidth 1000
2018-11-27 16:34:48 - |> Chart.WithHeight 700
2018-11-27 16:34:48 - This value is not a function and cannot be applied.
2018-11-27 16:34:48 - This value is not a function and cannot be applied.
2018-11-27 16:34:48 - This value is not a function and cannot be applied.
2018-11-27 16:34:48 - This value is not a function and cannot be applied.
2018-11-27 16:34:48 - This value is not a function and cannot be applied.
2018-11-27 16:34:53 - let f x = sin x / (1. + x ** 2.)
2018-11-27 16:34:54 - let df_1 h x = (f (x + h) - f x) / h
2018-11-27 16:34:54 - let df_2 h x = (f x - f (x - h)) / h
2018-11-27 16:34:54 - let df_3 h x = (f (x + h) - f (x - h)) / (2. * h)
2018-11-27 16:34:54 - let df_4 h x = (-3. * f x + 4. * f (x + h) - f (x + 2. * h)) / (2. * h)
2018-11-27 16:34:54 - let df_5 h x = (-3. * f x - 4. * f (x - h) + f (x - 2. * h)) / (2. * h)
2018-11-27 16:34:54 - let df_6 h x = (f (x + h) - 2. * f x + f (x - h)) / (h ** 2.)
2018-11-27 16:34:56 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-11-27 16:34:56 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-11-27 16:34:56 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-11-27 16:34:57 - let x = [-5. .. 0.01 .. 5.]
2018-11-27 16:34:57 - let trace1 =
2018-11-27 16:34:57 -     Scatter(
2018-11-27 16:34:57 -         x = x,
2018-11-27 16:34:57 -         y = (x |> List.map (fun i -> abs (f' i - df_1 1. i))),
2018-11-27 16:34:57 -         name = "Погрешность 1)"
2018-11-27 16:34:57 -     )   
2018-11-27 16:34:57 - let trace2 =
2018-11-27 16:34:57 -     Scatter(
2018-11-27 16:34:57 -         x = x,
2018-11-27 16:34:57 -         y = (x |> List.map (fun i -> abs (f' i - df_2 1. i))),
2018-11-27 16:34:57 -         name = "Погрешность 2)"
2018-11-27 16:34:57 -     )
2018-11-27 16:34:57 - let trace3 =
2018-11-27 16:34:57 -     Scatter(
2018-11-27 16:34:57 -         x = x,
2018-11-27 16:34:57 -         y = (x |> List.map (fun i -> abs (f' i - df_3 1. i))),
2018-11-27 16:34:57 -         name = "Погрешность 3)"
2018-11-27 16:34:57 -     )
2018-11-27 16:34:57 - let trace4 =
2018-11-27 16:34:57 -     Scatter(
2018-11-27 16:34:57 -         x = x,
2018-11-27 16:34:57 -         y = (x |> List.map (fun i -> abs (f' i - df_4 1. i))),
2018-11-27 16:34:57 -         name = "Погрешность 4)"
2018-11-27 16:34:57 -     )
2018-11-27 16:34:57 - let trace5 =
2018-11-27 16:34:57 -     Scatter(
2018-11-27 16:34:57 -         x = x,
2018-11-27 16:34:57 -         y = (x |> List.map (fun i -> abs (f' i - df_5 1. i))),
2018-11-27 16:34:57 -         name = "Погрешность 5)"
2018-11-27 16:34:57 -     )
2018-11-27 16:34:57 - [trace1; trace2; trace3; trace4; trace5]
2018-11-27 16:34:57 - |> Chart.Plot
2018-11-27 16:34:57 - |> Chart.WithWidth 1000
2018-11-27 16:34:57 - |> Chart.WithHeight 700
2018-11-27 16:34:59 - let trace =
2018-11-27 16:34:59 -     Scatter(
2018-11-27 16:34:59 -         x = x,
2018-11-27 16:34:59 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 i))),
2018-11-27 16:34:59 -         name = "Погрешность 6)"
2018-11-27 16:34:59 -     )
2018-11-27 16:34:59 - [trace]
2018-11-27 16:34:59 - |> Chart.Plot
2018-11-27 16:34:59 - |> Chart.WithWidth 1000
2018-11-27 16:34:59 - |> Chart.WithHeight 700
2018-11-27 16:34:59 - The type 'float -> float' does not match the type 'float'
2018-11-27 16:35:04 - let trace =
2018-11-27 16:35:04 -     Scatter(
2018-11-27 16:35:04 -         x = x,
2018-11-27 16:35:04 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 1 i))),
2018-11-27 16:35:04 -         name = "Погрешность 6)"
2018-11-27 16:35:04 -     )
2018-11-27 16:35:04 - [trace]
2018-11-27 16:35:04 - |> Chart.Plot
2018-11-27 16:35:04 - |> Chart.WithWidth 1000
2018-11-27 16:35:04 - |> Chart.WithHeight 700
2018-11-27 16:35:04 - This expression was expected to have type
2018-11-27 16:35:04 -     'float'    
2018-11-27 16:35:04 - but here has type
2018-11-27 16:35:04 -     'int'    
2018-11-27 16:35:06 - let trace =
2018-11-27 16:35:06 -     Scatter(
2018-11-27 16:35:06 -         x = x,
2018-11-27 16:35:06 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 1. i))),
2018-11-27 16:35:06 -         name = "Погрешность 6)"
2018-11-27 16:35:06 -     )
2018-11-27 16:35:06 - [trace]
2018-11-27 16:35:06 - |> Chart.Plot
2018-11-27 16:35:06 - |> Chart.WithWidth 1000
2018-11-27 16:35:06 - |> Chart.WithHeight 700
2018-11-27 16:39:30 - let x = -1.998 //значение из отрезка [-2; -1]
2018-11-27 16:39:30 - let n = 3 //степень полинома
2018-11-27 16:39:30 - polynom3 n x - f x |> abs;;
2018-11-27 16:39:35 - let x = -1.998 //значение из отрезка [-2; -1]
2018-11-27 16:39:35 - let n = 4 //степень полинома
2018-11-27 16:39:35 - polynom3 n x - f x |> abs;;
2018-11-27 16:39:41 - let x = -1.998 //значение из отрезка [-2; -1]
2018-11-27 16:39:41 - let n = 7 //степень полинома
2018-11-27 16:39:42 - polynom3 n x - f x |> abs;;
2018-11-27 16:43:14 - Reporting 0 opened comms
2018-11-27 16:43:31 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:43:31 - let n = 7 //степень полинома
2018-11-27 16:43:32 - polynom3 n x - f x |> abs;;
2018-11-27 16:43:34 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:43:34 - let n = 3 //степень полинома
2018-11-27 16:43:35 - polynom3 n x - f x |> abs;;
2018-11-27 16:43:38 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:43:38 - let n = 4 //степень полинома
2018-11-27 16:43:38 - polynom3 n x - f x |> abs;;
2018-11-27 16:43:42 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:43:42 - let n = 6 //степень полинома
2018-11-27 16:43:42 - polynom3 n x - f x |> abs;;
2018-11-27 16:43:55 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:43:55 - let n = 3 //степень полинома
2018-11-27 16:43:55 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:04 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:44:04 - let n = 4 //степень полинома
2018-11-27 16:44:04 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:08 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:44:08 - let n = 5 //степень полинома
2018-11-27 16:44:08 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:12 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:44:12 - let n = 7 //степень полинома
2018-11-27 16:44:12 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:39 - let x = -1.003 //значение из отрезка [-2; -1]
2018-11-27 16:44:39 - let n = 3 //степень полинома
2018-11-27 16:44:39 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:43 - let x = -1.003 //значение из отрезка [-2; -1]
2018-11-27 16:44:43 - let n = 4 //степень полинома
2018-11-27 16:44:43 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:45 - let x = -1.003 //значение из отрезка [-2; -1]
2018-11-27 16:44:45 - let n = 5 //степень полинома
2018-11-27 16:44:45 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:48 - let x = -1.003 //значение из отрезка [-2; -1]
2018-11-27 16:44:48 - let n = 7 //степень полинома
2018-11-27 16:44:49 - polynom3 n x - f x |> abs;;
2018-11-27 16:44:57 - let x = -1.023 //значение из отрезка [-2; -1]
2018-11-27 16:44:57 - let n = 7 //степень полинома
2018-11-27 16:45:00 - let x = -1.023 //значение из отрезка [-2; -1]
2018-11-27 16:45:00 - let n = 3 //степень полинома
2018-11-27 16:45:01 - polynom3 n x - f x |> abs;;
2018-11-27 16:45:05 - let x = -1.023 //значение из отрезка [-2; -1]
2018-11-27 16:45:05 - let n = 4 //степень полинома
2018-11-27 16:45:05 - polynom3 n x - f x |> abs;;
2018-11-27 16:45:08 - let x = -1.023 //значение из отрезка [-2; -1]
2018-11-27 16:45:08 - let n = 5 //степень полинома
2018-11-27 16:45:08 - polynom3 n x - f x |> abs;;
2018-11-27 16:46:39 - let x = -1.455 //значение из отрезка [-2; -1]
2018-11-27 16:46:39 - let n = 5 //степень полинома
2018-11-27 16:46:39 - polynom3 n x - f x |> abs;;
2018-11-27 16:46:42 - let x = -1.455 //значение из отрезка [-2; -1]
2018-11-27 16:46:42 - let n = 3 //степень полинома
2018-11-27 16:46:42 - polynom3 n x - f x |> abs;;
2018-11-27 16:46:44 - let x = -1.455 //значение из отрезка [-2; -1]
2018-11-27 16:46:44 - let n = 2 //степень полинома
2018-11-27 16:46:44 - polynom3 n x - f x |> abs;;
2018-11-27 16:46:47 - let x = -1.455 //значение из отрезка [-2; -1]
2018-11-27 16:46:47 - let n = 4 //степень полинома
2018-11-27 16:46:47 - polynom3 n x - f x |> abs;;
2018-11-27 16:46:54 - let x = -1.457 //значение из отрезка [-2; -1]
2018-11-27 16:46:54 - let n = 4 //степень полинома
2018-11-27 16:46:54 - polynom3 n x - f x |> abs;;
2018-11-27 16:46:57 - let x = -1.457 //значение из отрезка [-2; -1]
2018-11-27 16:46:57 - let n = 5 //степень полинома
2018-11-27 16:46:57 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:00 - let x = -1.457 //значение из отрезка [-2; -1]
2018-11-27 16:47:00 - let n = 7 //степень полинома
2018-11-27 16:47:00 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:03 - let x = -1.457 //значение из отрезка [-2; -1]
2018-11-27 16:47:03 - let n = 8 //степень полинома
2018-11-27 16:47:04 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:15 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:47:15 - let n = 8 //степень полинома
2018-11-27 16:47:15 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:21 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:47:21 - let n = 2 //степень полинома
2018-11-27 16:47:21 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:23 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:47:23 - let n = 3 //степень полинома
2018-11-27 16:47:23 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:26 - let x = -1.553 //значение из отрезка [-2; -1]
2018-11-27 16:47:26 - let n = 5 //степень полинома
2018-11-27 16:47:26 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:34 - let x = -1.658 //значение из отрезка [-2; -1]
2018-11-27 16:47:34 - let n = 3 //степень полинома
2018-11-27 16:47:35 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:37 - let x = -1.658 //значение из отрезка [-2; -1]
2018-11-27 16:47:37 - let n = 4 //степень полинома
2018-11-27 16:47:37 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:40 - let x = -1.658 //значение из отрезка [-2; -1]
2018-11-27 16:47:40 - let n = 5 //степень полинома
2018-11-27 16:47:40 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:43 - let x = -1.658 //значение из отрезка [-2; -1]
2018-11-27 16:47:43 - let n = 7 //степень полинома
2018-11-27 16:47:43 - polynom3 n x - f x |> abs;;
2018-11-27 16:47:59 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:47:59 - let n = 3 //степень полинома
2018-11-27 16:47:59 - polynom3 n x - f x |> abs;;
2018-11-27 16:48:02 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:48:02 - let n = 4 //степень полинома
2018-11-27 16:48:02 - polynom3 n x - f x |> abs;;
2018-11-27 16:48:04 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:48:04 - let n = 5 //степень полинома
2018-11-27 16:48:05 - polynom3 n x - f x |> abs;;
2018-11-27 16:48:08 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:48:08 - let n = 6 //степень полинома
2018-11-27 16:48:09 - polynom3 n x - f x |> abs;;
2018-11-27 16:48:12 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 16:48:12 - let n = 7 //степень полинома
2018-11-27 16:48:12 - polynom3 n x - f x |> abs;;
2018-11-27 16:48:36 - s
2018-11-27 16:48:37 - The value or constructor 's' is not defined. Maybe you want one of the following:
2018-11-27 16:48:37 -    SR
2018-11-27 16:48:37 -    rs
2018-11-27 16:48:37 -    MS
2018-11-27 16:48:37 -    N
2018-11-27 16:48:37 -    P
2018-11-27 16:48:39 - x
2018-11-27 16:56:37 - let trace =
2018-11-27 16:56:37 -     Scatter(
2018-11-27 16:56:37 -         x = x,
2018-11-27 16:56:37 -         y = (x |> List.map (fun i -> abs (f' i - P' i))),
2018-11-27 16:56:37 -         name = "Исходная функция"
2018-11-27 16:56:37 -     )   
2018-11-27 16:56:37 - [trace]
2018-11-27 16:56:37 - |> Chart.Plot
2018-11-27 16:56:37 - |> Chart.WithWidth 1000
2018-11-27 16:56:37 - |> Chart.WithHeight 700
2018-11-27 16:57:09 - let h = 0.001
2018-11-27 16:57:09 - let P' x = (P (x + h) - P x) / h
2018-11-27 16:57:09 - let P'' x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.) 
2018-11-27 16:57:10 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 16:57:10 - let trace1 =
2018-11-27 16:57:10 -     Scatter(
2018-11-27 16:57:10 -         x = x,
2018-11-27 16:57:10 -         y = (x |> List.map f),
2018-11-27 16:57:10 -         name = "Исходная функция"
2018-11-27 16:57:10 -     )
2018-11-27 16:57:10 - let trace2 =
2018-11-27 16:57:10 -     Scatter(
2018-11-27 16:57:10 -         x = x,
2018-11-27 16:57:10 -         y = (x |> List.map P),
2018-11-27 16:57:10 -         name = "Полином"
2018-11-27 16:57:10 -     )    
2018-11-27 16:57:10 - [trace1; trace2]
2018-11-27 16:57:10 - |> Chart.Plot
2018-11-27 16:57:10 - |> Chart.WithWidth 1000
2018-11-27 16:57:10 - |> Chart.WithHeight 700
2018-11-27 16:57:15 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 16:57:15 - let trace =
2018-11-27 16:57:15 -     Scatter(
2018-11-27 16:57:15 -         x = x,
2018-11-27 16:57:15 -         y = (x |> List.map (fun i -> abs (f i - P i))),
2018-11-27 16:57:15 -         name = "Исходная функция"
2018-11-27 16:57:15 -     )   
2018-11-27 16:57:15 - [trace]
2018-11-27 16:57:15 - |> Chart.Plot
2018-11-27 16:57:15 - |> Chart.WithWidth 1000
2018-11-27 16:57:15 - |> Chart.WithHeight 700
2018-11-27 16:57:16 - let trace =
2018-11-27 16:57:16 -     Scatter(
2018-11-27 16:57:16 -         x = x,
2018-11-27 16:57:16 -         y = (x |> List.map (fun i -> abs (f' i - P' i))),
2018-11-27 16:57:16 -         name = "Исходная функция"
2018-11-27 16:57:16 -     )   
2018-11-27 16:57:16 - [trace]
2018-11-27 16:57:16 - |> Chart.Plot
2018-11-27 16:57:16 - |> Chart.WithWidth 1000
2018-11-27 16:57:16 - |> Chart.WithHeight 700
2018-11-27 16:57:45 - let h = 0.000001
2018-11-27 16:57:47 - let P' x = (P (x + h) - P x) / h
2018-11-27 16:57:47 - let P'' x = (P (x + h) - 2. * P x + P (x - h)) / (h ** 2.) 
2018-11-27 16:57:47 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 16:57:47 - let trace1 =
2018-11-27 16:57:47 -     Scatter(
2018-11-27 16:57:47 -         x = x,
2018-11-27 16:57:47 -         y = (x |> List.map f),
2018-11-27 16:57:47 -         name = "Исходная функция"
2018-11-27 16:57:47 -     )
2018-11-27 16:57:47 - let trace2 =
2018-11-27 16:57:47 -     Scatter(
2018-11-27 16:57:47 -         x = x,
2018-11-27 16:57:47 -         y = (x |> List.map P),
2018-11-27 16:57:47 -         name = "Полином"
2018-11-27 16:57:47 -     )    
2018-11-27 16:57:47 - [trace1; trace2]
2018-11-27 16:57:47 - |> Chart.Plot
2018-11-27 16:57:47 - |> Chart.WithWidth 1000
2018-11-27 16:57:47 - |> Chart.WithHeight 700
2018-11-27 16:57:52 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 16:57:52 - let trace =
2018-11-27 16:57:52 -     Scatter(
2018-11-27 16:57:52 -         x = x,
2018-11-27 16:57:52 -         y = (x |> List.map (fun i -> abs (f i - P i))),
2018-11-27 16:57:52 -         name = "Исходная функция"
2018-11-27 16:57:52 -     )   
2018-11-27 16:57:52 - [trace]
2018-11-27 16:57:52 - |> Chart.Plot
2018-11-27 16:57:52 - |> Chart.WithWidth 1000
2018-11-27 16:57:52 - |> Chart.WithHeight 700
2018-11-27 16:57:57 - let x = [-2. .. 0.01 .. -1.5]
2018-11-27 16:57:57 - let trace =
2018-11-27 16:57:57 -     Scatter(
2018-11-27 16:57:57 -         x = x,
2018-11-27 16:57:57 -         y = (x |> List.map (fun i -> abs (f i - P i))),
2018-11-27 16:57:57 -         name = "Исходная функция"
2018-11-27 16:57:57 -     )   
2018-11-27 16:57:57 - [trace]
2018-11-27 16:57:57 - |> Chart.Plot
2018-11-27 16:57:57 - |> Chart.WithWidth 1000
2018-11-27 16:57:57 - |> Chart.WithHeight 700
2018-11-27 16:57:57 - let trace =
2018-11-27 16:57:57 -     Scatter(
2018-11-27 16:57:57 -         x = x,
2018-11-27 16:57:57 -         y = (x |> List.map (fun i -> abs (f' i - P' i))),
2018-11-27 16:57:57 -         name = "Исходная функция"
2018-11-27 16:57:57 -     )   
2018-11-27 16:57:57 - [trace]
2018-11-27 16:57:57 - |> Chart.Plot
2018-11-27 16:57:57 - |> Chart.WithWidth 1000
2018-11-27 16:57:57 - |> Chart.WithHeight 700
2018-11-27 16:58:52 - let trace =
2018-11-27 16:58:52 -     Scatter(
2018-11-27 16:58:52 -         x = x,
2018-11-27 16:58:52 -         y = (x |> List.map (fun i -> abs (f'' i - P'' i))),
2018-11-27 16:58:52 -         name = "Исходная функция"
2018-11-27 16:58:52 -     )   
2018-11-27 16:58:52 - [trace]
2018-11-27 16:58:52 - |> Chart.Plot
2018-11-27 16:58:52 - |> Chart.WithWidth 1000
2018-11-27 16:58:52 - |> Chart.WithHeight 700
2018-11-27 16:59:49 - let trace =
2018-11-27 16:59:49 -     Scatter(
2018-11-27 16:59:49 -         x = x,
2018-11-27 16:59:49 -         y = (x |> List.map (fun i -> abs (f'' i - P'' i))),
2018-11-27 16:59:49 -         name = "Исходная функция"
2018-11-27 16:59:49 -     )   
2018-11-27 16:59:49 - [trace]
2018-11-27 16:59:49 - |> Chart.Plot
2018-11-27 16:59:49 - |> Chart.WithWidth 1000
2018-11-27 16:59:49 - |> Chart.WithHeight 700
2018-11-27 17:00:01 - let trace =
2018-11-27 17:00:01 -     Scatter(
2018-11-27 17:00:01 -         x = x,
2018-11-27 17:00:01 -         y = (x |> List.map (fun i -> abs (f'' i - P'' i))),
2018-11-27 17:00:01 -         name = "Исходная функция"
2018-11-27 17:00:01 -     )   
2018-11-27 17:00:01 - [trace]
2018-11-27 17:00:01 - |> Chart.Plot
2018-11-27 17:00:01 - |> Chart.WithWidth 1000
2018-11-27 17:00:01 - |> Chart.WithHeight 700
2018-11-27 19:11:43 - //third case
2018-11-27 19:11:43 - let polynom3 n x =
2018-11-27 19:11:43 -     let startX = points |> List.filter (fun i -> x > i - h / 2. && x <= i + h / 2.) |> List.exactlyOne
2018-11-27 19:11:43 -     let isRightSide = x <= startX + h / 2. && x > startX
2018-11-27 19:11:43 -     let middlePoint = points |> List.findIndex (fun i -> i = startX)
2018-11-27 19:11:43 -     let dependenceOfSide rightSide = 
2018-11-27 19:11:43 -         match rightSide with
2018-11-27 19:11:43 -         | false -> (n + 1) / 2
2018-11-27 19:11:43 -         | true -> n / 2
2018-11-27 19:11:43 -     let startIndex = middlePoint - (dependenceOfSide isRightSide)
2018-11-27 19:11:43 -     let endIndex = middlePoint + (dependenceOfSide <| not isRightSide)
2018-11-27 19:11:43 -     let t = (x - startX) / h
2018-11-27 19:11:43 -     let Nk =
2018-11-27 19:11:43 -         let rec NkInternal prev i =
2018-11-27 19:11:43 -             let deg = 
2018-11-27 19:11:43 -                 match n % 2 = 0 && isRightSide with
2018-11-27 19:11:43 -                 | true -> i + 1.
2018-11-27 19:11:43 -                 | false -> i
2018-11-27 19:11:43 -             seq{
2018-11-27 19:11:43 -                 match i with
2018-11-27 19:11:43 -                 | _ when int i = n - 1 -> yield prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 19:11:43 -                 | 0. -> yield t
2018-11-27 19:11:43 -                         yield! NkInternal t (i + 1.)
2018-11-27 19:11:43 -                 | _ ->  let cur = prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 19:11:43 -                         yield cur
2018-11-27 19:11:43 -                         yield! NkInternal cur (i + 1.)
2018-11-27 19:11:43 -             }
2018-11-27 19:11:43 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 19:11:43 -     
2018-11-27 19:11:43 -     let middle =
2018-11-27 19:11:43 -         let rec truncateFiniteDiff (finiteDifference : float list list) k acc =
2018-11-27 19:11:43 -             match finiteDifference with
2018-11-27 19:11:43 -             | (h :: t) when k <= n -> truncateFiniteDiff t (k + 1) ((h |> List.indexed |> List.filter (fun (i, _) -> i >= startIndex && i <= endIndex - k) |> List.map (snd)) :: acc)
2018-11-27 19:11:43 -             | _ -> acc |> List.rev
2018-11-27 19:11:43 -         truncateFiniteDiff finiteDifferencesTable 0 []
2018-11-27 19:11:43 -     let rec polynom3Internal nki (finiteDifference : float list list) acc =
2018-11-27 19:11:43 -         match nki, finiteDifference with
2018-11-27 19:11:43 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) -> polynom3Internal tNki tFiniteDifference (acc + hNki * hFiniteDifference.[(hFiniteDifference.Length - 1) / 2])
2018-11-27 19:11:43 -         | _ -> acc
2018-11-27 19:11:43 -     
2018-11-27 19:11:43 -     match startIndex, endIndex with
2018-11-27 19:11:43 -     | (s, e) when s >= 0 && e < points.Length -> polynom3Internal Nk middle.Tail (f startX)
2018-11-27 19:11:43 -     | (s, e) when s >= 0 -> polynom2 n x
2018-11-27 19:11:43 -     | (s, e) when e < points.Length -> polynom n x
2018-11-27 19:11:43 -     | _ -> failwith "Incorrect arguments"
2018-11-27 19:11:47 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 19:11:47 - let n = 7 //степень полинома
2018-11-27 19:11:47 - polynom3 n x - f x |> abs;;
2018-11-27 19:12:00 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 19:12:00 - let n = 8 //степень полинома
2018-11-27 19:12:00 - polynom3 n x - f x |> abs;;
2018-11-27 19:12:04 - let x = -1.978 //значение из отрезка [-2; -1]
2018-11-27 19:12:04 - let n = 2 //степень полинома
2018-11-27 19:12:04 - polynom3 n x - f x |> abs;;
2018-11-27 19:12:52 - let x = -1.405 //значение из отрезка [-2; -1]
2018-11-27 19:12:52 - let n = 2 //степень полинома
2018-11-27 19:12:52 - polynom3 n x - f x |> abs;;
2018-11-27 19:12:52 - Expression evaluation failed: The input sequence was empty.
2018-11-27 19:12:52 - Parameter name: source
2018-11-27 19:12:52 - ArgumentExceptionThe input sequence was empty.
2018-11-27 19:12:52 - Parameter name: source
2018-11-27 19:12:52 -   at Microsoft.FSharp.Collections.ListModule.ExactlyOne[T] (Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x0000d] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 19:12:52 -   at FSI_0143.polynom3 (System.Int32 n, System.Double x) [0x00013] in <c0ae58c173a547d08e0bbbcddf506a43>:0 
2018-11-27 19:12:52 -   at <StartupCode$FSI_0154>.$FSI_0154.main@ () [0x00000] in <c0ae58c173a547d08e0bbbcddf506a43>:0 
2018-11-27 19:12:52 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 19:12:52 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 19:17:35 - //third case
2018-11-27 19:17:35 - let polynom3 n x =
2018-11-27 19:17:35 -     let startX = points |> List.filter (fun i -> x > i - h / 2. && x <= i + h / 2.) |> List.exactlyOne
2018-11-27 19:17:35 -     let isRightSide = x <= startX + h / 2. && x > startX
2018-11-27 19:17:35 -     let middlePoint = points |> List.findIndex (fun i -> i = startX)
2018-11-27 19:17:35 -     let dependenceOfSide rightSide = 
2018-11-27 19:17:35 -         match rightSide with
2018-11-27 19:17:35 -         | false -> (n + 1) / 2
2018-11-27 19:17:35 -         | true -> n / 2
2018-11-27 19:17:35 -     let startIndex = middlePoint - (dependenceOfSide isRightSide)
2018-11-27 19:17:35 -     let endIndex = middlePoint + (dependenceOfSide <| not isRightSide)
2018-11-27 19:17:35 -     let t = (x - startX) / h
2018-11-27 19:17:35 -     let Nk =
2018-11-27 19:17:35 -         let rec NkInternal prev i =
2018-11-27 19:17:35 -             let deg = 
2018-11-27 19:17:35 -                 match n % 2 = 0 = isRightSide with
2018-11-27 19:17:35 -                 | true -> i + 1.
2018-11-27 19:17:35 -                 | false -> i
2018-11-27 19:17:35 -             seq{
2018-11-27 19:17:35 -                 match i with
2018-11-27 19:17:35 -                 | _ when int i = n - 1 -> yield prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 19:17:35 -                 | 0. -> yield t
2018-11-27 19:17:35 -                         yield! NkInternal t (i + 1.)
2018-11-27 19:17:35 -                 | _ ->  let cur = prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-27 19:17:35 -                         yield cur
2018-11-27 19:17:35 -                         yield! NkInternal cur (i + 1.)
2018-11-27 19:17:35 -             }
2018-11-27 19:17:35 -         NkInternal 1. 0. |> Seq.toList
2018-11-27 19:17:35 -     
2018-11-27 19:17:35 -     let middle =
2018-11-27 19:17:35 -         let rec truncateFiniteDiff (finiteDifference : float list list) k acc =
2018-11-27 19:17:35 -             match finiteDifference with
2018-11-27 19:17:35 -             | (h :: t) when k <= n -> truncateFiniteDiff t (k + 1) ((h |> List.indexed |> List.filter (fun (i, _) -> i >= startIndex && i <= endIndex - k) |> List.map (snd)) :: acc)
2018-11-27 19:17:35 -             | _ -> acc |> List.rev
2018-11-27 19:17:35 -         truncateFiniteDiff finiteDifferencesTable 0 []
2018-11-27 19:17:35 -     let rec polynom3Internal nki (finiteDifference : float list list) acc =
2018-11-27 19:17:35 -         match nki, finiteDifference with
2018-11-27 19:17:35 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) -> polynom3Internal tNki tFiniteDifference (acc + hNki * hFiniteDifference.[(hFiniteDifference.Length - 1) / 2])
2018-11-27 19:17:35 -         | _ -> acc
2018-11-27 19:17:35 -     
2018-11-27 19:17:35 -     match startIndex, endIndex with
2018-11-27 19:17:35 -     | (s, e) when s >= 0 && e < points.Length -> polynom3Internal Nk middle.Tail (f startX)
2018-11-27 19:17:35 -     | (s, e) when s >= 0 -> polynom2 n x
2018-11-27 19:17:35 -     | (s, e) when e < points.Length -> polynom n x
2018-11-27 19:17:35 -     | _ -> failwith "Incorrect arguments"
2018-11-27 19:17:36 - let plotThirdCaseError () =
2018-11-27 19:17:36 -     let trace1 =
2018-11-27 19:17:36 -         let y = points |> List.map f
2018-11-27 19:17:36 -         Scatter(
2018-11-27 19:17:36 -             x = points,
2018-11-27 19:17:36 -             y = y,
2018-11-27 19:17:36 -             name = "Исходная функция"
2018-11-27 19:17:36 -         )
2018-11-27 19:17:36 -     let trace2 =
2018-11-27 19:17:36 -         let y = points |> List.map (polynom3 1)
2018-11-27 19:17:36 -         Scatter(
2018-11-27 19:17:36 -             x = points,
2018-11-27 19:17:36 -             y = y,
2018-11-27 19:17:36 -             name = "Интерполяционный полином"
2018-11-27 19:17:36 -         )
2018-11-27 19:17:36 -     [trace1; trace2]
2018-11-27 19:17:36 -     |> Chart.Plot
2018-11-27 19:17:36 -     |> Chart.WithWidth 1000
2018-11-27 19:17:36 -     |> Chart.WithHeight 700
2018-11-27 19:17:36 - plotThirdCaseError()
2018-11-27 19:17:38 - let x = -1.405 //значение из отрезка [-2; -1]
2018-11-27 19:17:38 - let n = 2 //степень полинома
2018-11-27 19:17:38 - polynom3 n x - f x |> abs;;
2018-11-27 19:17:38 - Expression evaluation failed: The input sequence was empty.
2018-11-27 19:17:38 - Parameter name: source
2018-11-27 19:17:38 - ArgumentExceptionThe input sequence was empty.
2018-11-27 19:17:38 - Parameter name: source
2018-11-27 19:17:38 -   at Microsoft.FSharp.Collections.ListModule.ExactlyOne[T] (Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x0000d] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 19:17:38 -   at FSI_0155.polynom3 (System.Int32 n, System.Double x) [0x00013] in <c0ae58c173a547d08e0bbbcddf506a43>:0 
2018-11-27 19:17:38 -   at <StartupCode$FSI_0159>.$FSI_0159.main@ () [0x00000] in <c0ae58c173a547d08e0bbbcddf506a43>:0 
2018-11-27 19:17:38 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 19:17:38 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-27 19:17:48 - let x = -1.988 //значение из отрезка [-2; -1]
2018-11-27 19:17:48 - let n = 2 //степень полинома
2018-11-27 19:17:48 - polynom3 n x - f x |> abs;;
2018-11-27 19:17:52 - let x = -1.988 //значение из отрезка [-2; -1]
2018-11-27 19:17:52 - let n = 3 //степень полинома
2018-11-27 19:18:02 - let x = -1.505 //значение из отрезка [-2; -1]
2018-11-27 19:18:02 - let n = 3 //степень полинома
2018-11-27 19:18:03 - polynom3 n x - f x |> abs;;
2018-11-27 19:18:03 - Expression evaluation failed: The input sequence was empty.
2018-11-27 19:18:03 - Parameter name: source
2018-11-27 19:18:03 - ArgumentExceptionThe input sequence was empty.
2018-11-27 19:18:03 - Parameter name: source
2018-11-27 19:18:03 -   at Microsoft.FSharp.Collections.ListModule.ExactlyOne[T] (Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x0000d] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 19:18:03 -   at FSI_0155.polynom3 (System.Int32 n, System.Double x) [0x00013] in <c0ae58c173a547d08e0bbbcddf506a43>:0 
2018-11-27 19:18:03 -   at <StartupCode$FSI_0165>.$FSI_0165.main@ () [0x00000] in <c0ae58c173a547d08e0bbbcddf506a43>:0 
2018-11-27 19:18:03 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 19:18:03 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-11-28 01:23:20 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-28 01:23:20 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-28 01:23:20 - For help type #help;;
2018-11-28 01:23:20 - > val it :
2018-11-28 01:23:20 -   ResizeArray<System.Type *
2018-11-28 01:23:20 -               (obj ->
2018-11-28 01:23:20 -                  seq<string *
2018-11-28 01:23:20 -                      string> *
2018-11-28 01:23:20 -                  string)>
2018-11-28 01:23:20 - = seq []
2018-11-28 01:23:20 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-28 01:23:20 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-28 01:23:20 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-28 01:23:22 - Reporting 0 opened comms
2018-11-28 01:23:41 - //third case
2018-11-28 01:23:41 - let polynom3 n x =
2018-11-28 01:23:41 -     let startX = points |> List.filter (fun i -> x > i - h / 2. && x <= i + h / 2.) |> List.exactlyOne
2018-11-28 01:23:41 -     let isRightSide = x <= startX + h / 2. && x > startX
2018-11-28 01:23:41 -     let middlePoint = points |> List.findIndex (fun i -> i = startX)
2018-11-28 01:23:41 -     let dependenceOfSide rightSide = 
2018-11-28 01:23:41 -         match rightSide with
2018-11-28 01:23:41 -         | false -> (n + 1) / 2
2018-11-28 01:23:41 -         | true -> n / 2
2018-11-28 01:23:41 -     let startIndex = middlePoint - (dependenceOfSide isRightSide)
2018-11-28 01:23:41 -     let endIndex = middlePoint + (dependenceOfSide <| not isRightSide)
2018-11-28 01:23:41 -     let t = (x - startX) / h
2018-11-28 01:23:41 -     let Nk =
2018-11-28 01:23:41 -         let rec NkInternal prev i =
2018-11-28 01:23:41 -             let deg = 
2018-11-28 01:23:41 -                 match n % 2 = 0 with
2018-11-28 01:23:41 -                 | true -> i + 1.
2018-11-28 01:23:41 -                 | false -> i
2018-11-28 01:23:41 -             seq{
2018-11-28 01:23:41 -                 match i with
2018-11-28 01:23:41 -                 | _ when int i = n - 1 -> yield prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-28 01:23:41 -                 | 0. -> yield t
2018-11-28 01:23:41 -                         yield! NkInternal t (i + 1.)
2018-11-28 01:23:41 -                 | _ ->  let cur = prev * (t + ((-1.) ** deg) * Math.Truncate((i + 1.) / 2.)) / (i + 1.)
2018-11-28 01:23:41 -                         yield cur
2018-11-28 01:23:41 -                         yield! NkInternal cur (i + 1.)
2018-11-28 01:23:41 -             }
2018-11-28 01:23:41 -         NkInternal 1. 0. |> Seq.toList
2018-11-28 01:23:41 -     
2018-11-28 01:23:41 -     let middle =
2018-11-28 01:23:41 -         let rec truncateFiniteDiff (finiteDifference : float list list) k acc =
2018-11-28 01:23:41 -             match finiteDifference with
2018-11-28 01:23:41 -             | (h :: t) when k <= n -> truncateFiniteDiff t (k + 1) ((h |> List.indexed |> List.filter (fun (i, _) -> i >= startIndex && i <= endIndex - k) |> List.map (snd)) :: acc)
2018-11-28 01:23:41 -             | _ -> acc |> List.rev
2018-11-28 01:23:41 -         truncateFiniteDiff finiteDifferencesTable 0 []
2018-11-28 01:23:41 -     let rec polynom3Internal nki (finiteDifference : float list list) acc =
2018-11-28 01:23:41 -         match nki, finiteDifference with
2018-11-28 01:23:41 -         | (hNki :: tNki, hFiniteDifference :: tFiniteDifference) -> polynom3Internal tNki tFiniteDifference (acc + hNki * hFiniteDifference.[(hFiniteDifference.Length - 1) / 2])
2018-11-28 01:23:41 -         | _ -> acc
2018-11-28 01:23:41 -     
2018-11-28 01:23:41 -     match startIndex, endIndex with
2018-11-28 01:23:41 -     | (s, e) when s >= 0 && e < points.Length -> polynom3Internal Nk middle.Tail (f startX)
2018-11-28 01:23:41 -     | (s, e) when s >= 0 -> polynom2 n x
2018-11-28 01:23:41 -     | (s, e) when e < points.Length -> polynom n x
2018-11-28 01:23:41 -     | _ -> failwith "Incorrect arguments"
2018-11-28 01:23:41 - The value or constructor 'points' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    printf
2018-11-28 01:23:41 -    Printf
2018-11-28 01:23:41 - The value or constructor 'h' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    i
2018-11-28 01:23:41 -    n
2018-11-28 01:23:41 -    x
2018-11-28 01:23:41 - The value or constructor 'h' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    i
2018-11-28 01:23:41 -    n
2018-11-28 01:23:41 -    x
2018-11-28 01:23:41 - The value or constructor 'h' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    n
2018-11-28 01:23:41 -    x
2018-11-28 01:23:41 - The value or constructor 'points' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    printf
2018-11-28 01:23:41 -    Printf
2018-11-28 01:23:41 - The value or constructor 'h' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    n
2018-11-28 01:23:41 -    x
2018-11-28 01:23:41 - The value, constructor, namespace or type 'Truncate' is not defined.
2018-11-28 01:23:41 - The value, constructor, namespace or type 'Truncate' is not defined.
2018-11-28 01:23:41 - The value or constructor 'finiteDifferencesTable' is not defined.
2018-11-28 01:23:41 - The value, namespace, type or module 'points' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    Printf
2018-11-28 01:23:41 -    printf
2018-11-28 01:23:41 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    e
2018-11-28 01:23:41 -    n
2018-11-28 01:23:41 -    s
2018-11-28 01:23:41 -    t
2018-11-28 01:23:41 -    x
2018-11-28 01:23:41 - The value or constructor 'polynom2' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    polynom3Internal
2018-11-28 01:23:41 - The value, namespace, type or module 'points' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    Printf
2018-11-28 01:23:41 -    printf
2018-11-28 01:23:41 - The value or constructor 'polynom' is not defined. Maybe you want one of the following:
2018-11-28 01:23:41 -    polynom3Internal
2018-11-28 01:23:53 - shutdown request
2018-11-28 01:24:02 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-28 01:24:02 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-28 01:24:02 - For help type #help;;
2018-11-28 01:24:02 - > val it :
2018-11-28 01:24:02 -   ResizeArray<System.Type *
2018-11-28 01:24:02 -               (obj ->
2018-11-28 01:24:02 -                  seq<string *
2018-11-28 01:24:02 -                      string> *
2018-11-28 01:24:02 -                  string)>
2018-11-28 01:24:02 - = seq []
2018-11-28 01:24:02 - --> Added '/home/max/Загрузки/IfSharp.v3.0.1' to library include path
2018-11-28 01:24:02 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-28 01:24:02 - --> Referenced '/home/max/Загрузки/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-28 01:24:03 - Reporting 0 opened comms
2018-11-28 01:24:09 - shutdown request
2018-12-03 21:38:14 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-03 21:38:14 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-03 21:38:14 - For help type #help;;
2018-12-03 21:38:14 - > val it :
2018-12-03 21:38:14 -   ResizeArray<System.Type *
2018-12-03 21:38:14 -               (obj ->
2018-12-03 21:38:14 -                  seq<string *
2018-12-03 21:38:14 -                      string> *
2018-12-03 21:38:14 -                  string)>
2018-12-03 21:38:14 - = seq []
2018-12-03 21:38:14 - --> Added '/home/max/IfSharp.v3.0.1' to library include path
2018-12-03 21:38:14 - --> Referenced '/home/max/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-03 21:38:14 - --> Referenced '/home/max/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-03 21:38:15 - #load "XPlot.Plotly.Paket.fsx"
2018-12-03 21:38:15 - #load "XPlot.Plotly.fsx"
2018-12-03 21:38:15 - open XPlot.Plotly
2018-12-03 21:38:15 - open System
2018-12-03 21:38:25 - Reporting 0 opened comms
2018-12-03 21:38:27 - let f x = sin x / (1. + x ** 2.)
2018-12-03 21:38:29 - let df_1 h x = (f (x + h) - f x) / h
2018-12-03 21:38:29 - let df_2 h x = (f x - f (x - h)) / h
2018-12-03 21:38:29 - let df_3 h x = (f (x + h) - f (x - h)) / (2. * h)
2018-12-03 21:38:29 - let df_4 h x = (-3. * f x + 4. * f (x + h) - f (x + 2. * h)) / (2. * h)
2018-12-03 21:38:29 - let df_5 h x = (-3. * f x - 4. * f (x - h) + f (x - 2. * h)) / (2. * h)
2018-12-03 21:38:29 - let df_6 h x = (f (x + h) - 2. * f x + f (x - h)) / (h ** 2.)
2018-12-03 21:38:31 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-12-03 21:38:31 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-12-03 21:38:31 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-12-03 21:38:32 - let x = [-5. .. 0.01 .. 5.]
2018-12-03 21:38:32 - let trace1 =
2018-12-03 21:38:32 -     Scatter(
2018-12-03 21:38:32 -         x = x,
2018-12-03 21:38:32 -         y = (x |> List.map (fun i -> abs (f' i - df_1 1. i))),
2018-12-03 21:38:32 -         name = "Погрешность 1)"
2018-12-03 21:38:32 -     )   
2018-12-03 21:38:32 - let trace2 =
2018-12-03 21:38:32 -     Scatter(
2018-12-03 21:38:32 -         x = x,
2018-12-03 21:38:32 -         y = (x |> List.map (fun i -> abs (f' i - df_2 1. i))),
2018-12-03 21:38:32 -         name = "Погрешность 2)"
2018-12-03 21:38:32 -     )
2018-12-03 21:38:32 - let trace3 =
2018-12-03 21:38:32 -     Scatter(
2018-12-03 21:38:32 -         x = x,
2018-12-03 21:38:32 -         y = (x |> List.map (fun i -> abs (f' i - df_3 1. i))),
2018-12-03 21:38:32 -         name = "Погрешность 3)"
2018-12-03 21:38:32 -     )
2018-12-03 21:38:32 - let trace4 =
2018-12-03 21:38:32 -     Scatter(
2018-12-03 21:38:32 -         x = x,
2018-12-03 21:38:32 -         y = (x |> List.map (fun i -> abs (f' i - df_4 1. i))),
2018-12-03 21:38:32 -         name = "Погрешность 4)"
2018-12-03 21:38:32 -     )
2018-12-03 21:38:32 - let trace5 =
2018-12-03 21:38:32 -     Scatter(
2018-12-03 21:38:32 -         x = x,
2018-12-03 21:38:32 -         y = (x |> List.map (fun i -> abs (f' i - df_5 1. i))),
2018-12-03 21:38:32 -         name = "Погрешность 5)"
2018-12-03 21:38:32 -     )
2018-12-03 21:38:32 - [trace1; trace2; trace3; trace4; trace5]
2018-12-03 21:38:32 - |> Chart.Plot
2018-12-03 21:38:32 - |> Chart.WithWidth 1000
2018-12-03 21:38:32 - |> Chart.WithHeight 700
2018-12-03 21:38:35 - let trace =
2018-12-03 21:38:35 -     Scatter(
2018-12-03 21:38:35 -         x = x,
2018-12-03 21:38:35 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 1. i))),
2018-12-03 21:38:35 -         name = "Погрешность 6)"
2018-12-03 21:38:35 -     )
2018-12-03 21:38:35 - [trace]
2018-12-03 21:38:35 - |> Chart.Plot
2018-12-03 21:38:35 - |> Chart.WithWidth 1000
2018-12-03 21:38:35 - |> Chart.WithHeight 700
2018-12-03 21:38:39 - let x = 2.
2018-12-03 21:38:39 - let optimalStep =
2018-12-03 21:38:39 -     let rec optimalStepInternal h acc = 
2018-12-03 21:38:39 -         match h with
2018-12-03 21:38:39 -         | _ when h > 0. -> optimalStepInternal (h / 2.) <| (abs (f' x - df_5 h x), h)  :: acc
2018-12-03 21:38:39 -         | _ -> acc
2018-12-03 21:38:39 -     optimalStepInternal 2. [] |> List.minBy (fun (fx, h) -> fx) |> snd
2018-12-03 21:39:04 - optimalStep
2018-12-03 21:40:17 - let x = 2.
2018-12-03 21:40:17 - let optimalStep =
2018-12-03 21:40:17 -     let rec optimalStepInternal h acc = 
2018-12-03 21:40:17 -         match h with
2018-12-03 21:40:17 -         | _ when h > 0. -> optimalStepInternal (h / 2.) <| (abs (f' x - df_5 h x), h) :: acc
2018-12-03 21:40:17 -         | _ -> acc
2018-12-03 21:40:17 -     optimalStepInternal 2. [] |> List.minBy (fun (fx, h) -> fx) |> snd
2018-12-03 21:40:18 - optimalStep
2018-12-03 21:41:10 - let x = 1.0076
2018-12-03 21:41:10 - let optimalStep =
2018-12-03 21:41:10 -     let rec optimalStepInternal h acc = 
2018-12-03 21:41:10 -         match h with
2018-12-03 21:41:10 -         | _ when h > 0. -> optimalStepInternal (h / 2.) <| (abs (f' x - df_5 h x), h) :: acc
2018-12-03 21:41:10 -         | _ -> acc
2018-12-03 21:41:10 -     optimalStepInternal 2. [] |> List.minBy (fun (fx, h) -> fx) |> snd
2018-12-03 21:41:10 - optimalStep
2018-12-03 22:16:32 - let trace =
2018-12-03 22:16:32 -     let delta h x = abs (f' x - df_5 h x)
2018-12-03 22:16:32 -     let hs = [0.00000000001 .. 0.000001 .. 5.]
2018-12-03 22:16:32 -     let r = new Random()
2018-12-03 22:16:32 -     let x = r.NextDouble() * 10. - 5.
2018-12-03 22:16:32 -     Scatter(
2018-12-03 22:16:32 -         x = hs,
2018-12-03 22:16:32 -         y = (hs |> List.map (fun i -> delta i x),
2018-12-03 22:16:32 -         name = "График оптимального шага"
2018-12-03 22:16:32 -     )
2018-12-03 22:16:32 - [trace]
2018-12-03 22:16:32 - |> Chart.Plot
2018-12-03 22:16:32 - |> Chart.WithWidth 1000
2018-12-03 22:16:32 - |> Chart.WithHeight 700
2018-12-03 22:16:32 - Possible incorrect indentation: this token is offside of context started at position (8:9). Try indenting this token further or using standard formatting conventions.
2018-12-03 22:16:32 - Possible incorrect indentation: this token is offside of context started at position (8:9). Try indenting this token further or using standard formatting conventions.
2018-12-03 22:16:32 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 22:16:32 - Unmatched '('
2018-12-03 22:16:51 - let trace =
2018-12-03 22:16:51 -     let delta h x = abs (f' x - df_5 h x)
2018-12-03 22:16:51 -     let hs = [0.00000000001 .. 0.000001 .. 5.]
2018-12-03 22:16:51 -     let r = new Random()
2018-12-03 22:16:51 -     let x = r.NextDouble() * 10. - 5.
2018-12-03 22:16:51 -     Scatter(
2018-12-03 22:16:51 -         x = hs,
2018-12-03 22:16:51 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-03 22:16:51 -         name = "График оптимального шага"
2018-12-03 22:16:51 -     )
2018-12-03 22:16:51 - [trace]
2018-12-03 22:16:51 - |> Chart.Plot
2018-12-03 22:16:51 - |> Chart.WithWidth 1000
2018-12-03 22:16:51 - |> Chart.WithHeight 700
2018-12-03 22:31:25 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-03 22:31:25 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-03 22:31:25 - For help type #help;;
2018-12-03 22:31:25 - > val it :
2018-12-03 22:31:25 -   ResizeArray<System.Type *
2018-12-03 22:31:25 -               (obj ->
2018-12-03 22:31:25 -                  seq<string *
2018-12-03 22:31:25 -                      string> *
2018-12-03 22:31:25 -                  string)>
2018-12-03 22:31:25 - = seq []
2018-12-03 22:31:25 - --> Added '/home/max/IfSharp.v3.0.1' to library include path
2018-12-03 22:31:25 - --> Referenced '/home/max/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-03 22:31:25 - --> Referenced '/home/max/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-03 22:31:27 - Reporting 0 opened comms
2018-12-03 22:31:27 - #load "XPlot.Plotly.Paket.fsx"
2018-12-03 22:31:27 - #load "XPlot.Plotly.fsx"
2018-12-03 22:31:27 - open XPlot.Plotly
2018-12-03 22:31:27 - open System
2018-12-03 22:31:32 - let f x = sin x / (1. + x ** 2.)
2018-12-03 22:31:32 - let df_1 h x = (f (x + h) - f x) / h
2018-12-03 22:31:32 - let df_2 h x = (f x - f (x - h)) / h
2018-12-03 22:31:32 - let df_3 h x = (f (x + h) - f (x - h)) / (2. * h)
2018-12-03 22:31:32 - let df_4 h x = (-3. * f x + 4. * f (x + h) - f (x + 2. * h)) / (2. * h)
2018-12-03 22:31:32 - let df_5 h x = (-3. * f x - 4. * f (x - h) + f (x - 2. * h)) / (2. * h)
2018-12-03 22:31:32 - let df_6 h x = (f (x + h) - 2. * f x + f (x - h)) / (h ** 2.)
2018-12-03 22:31:34 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-12-03 22:31:34 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-12-03 22:31:34 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-12-03 22:31:35 - let x = [-5. .. 0.01 .. 5.]
2018-12-03 22:31:35 - let trace1 =
2018-12-03 22:31:35 -     Scatter(
2018-12-03 22:31:35 -         x = x,
2018-12-03 22:31:35 -         y = (x |> List.map (fun i -> abs (f' i - df_1 1. i))),
2018-12-03 22:31:35 -         name = "Погрешность 1)"
2018-12-03 22:31:35 -     )   
2018-12-03 22:31:35 - let trace2 =
2018-12-03 22:31:35 -     Scatter(
2018-12-03 22:31:35 -         x = x,
2018-12-03 22:31:35 -         y = (x |> List.map (fun i -> abs (f' i - df_2 1. i))),
2018-12-03 22:31:35 -         name = "Погрешность 2)"
2018-12-03 22:31:35 -     )
2018-12-03 22:31:35 - let trace3 =
2018-12-03 22:31:35 -     Scatter(
2018-12-03 22:31:35 -         x = x,
2018-12-03 22:31:35 -         y = (x |> List.map (fun i -> abs (f' i - df_3 1. i))),
2018-12-03 22:31:35 -         name = "Погрешность 3)"
2018-12-03 22:31:35 -     )
2018-12-03 22:31:35 - let trace4 =
2018-12-03 22:31:35 -     Scatter(
2018-12-03 22:31:35 -         x = x,
2018-12-03 22:31:35 -         y = (x |> List.map (fun i -> abs (f' i - df_4 1. i))),
2018-12-03 22:31:35 -         name = "Погрешность 4)"
2018-12-03 22:31:35 -     )
2018-12-03 22:31:35 - let trace5 =
2018-12-03 22:31:35 -     Scatter(
2018-12-03 22:31:35 -         x = x,
2018-12-03 22:31:35 -         y = (x |> List.map (fun i -> abs (f' i - df_5 1. i))),
2018-12-03 22:31:35 -         name = "Погрешность 5)"
2018-12-03 22:31:35 -     )
2018-12-03 22:31:35 - [trace1; trace2; trace3; trace4; trace5]
2018-12-03 22:31:35 - |> Chart.Plot
2018-12-03 22:31:35 - |> Chart.WithWidth 1000
2018-12-03 22:31:35 - |> Chart.WithHeight 700
2018-12-03 22:31:36 - let trace =
2018-12-03 22:31:36 -     Scatter(
2018-12-03 22:31:36 -         x = x,
2018-12-03 22:31:36 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 1. i))),
2018-12-03 22:31:36 -         name = "Погрешность 6)"
2018-12-03 22:31:36 -     )
2018-12-03 22:31:36 - [trace]
2018-12-03 22:31:36 - |> Chart.Plot
2018-12-03 22:31:36 - |> Chart.WithWidth 1000
2018-12-03 22:31:36 - |> Chart.WithHeight 700
2018-12-03 22:32:03 - let trace =
2018-12-03 22:32:03 -     let delta h x = abs (f' x - df_5 h x)
2018-12-03 22:32:03 -     let hs = [0.01 .. 0.01 .. 5.]
2018-12-03 22:32:03 -     let r = new Random()
2018-12-03 22:32:03 -     let x = r.NextDouble() * 10. - 5.
2018-12-03 22:32:03 -     Scatter(
2018-12-03 22:32:03 -         x = hs,
2018-12-03 22:32:03 -         y = (x |> List.map (fun i -> delta ),
2018-12-03 22:32:03 -         name = "Погрешность 6)"
2018-12-03 22:32:03 -     )
2018-12-03 22:32:03 - [trace]
2018-12-03 22:32:03 - |> Chart.Plot
2018-12-03 22:32:03 - |> Chart.WithWidth 1000
2018-12-03 22:32:03 - |> Chart.WithHeight 700
2018-12-03 22:32:03 - Possible incorrect indentation: this token is offside of context started at position (8:9). Try indenting this token further or using standard formatting conventions.
2018-12-03 22:32:03 - Possible incorrect indentation: this token is offside of context started at position (8:9). Try indenting this token further or using standard formatting conventions.
2018-12-03 22:32:03 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 22:32:03 - Unmatched '('
2018-12-03 22:32:33 - let trace =
2018-12-03 22:32:33 -     let delta h x = abs (f' x - df_5 h x)
2018-12-03 22:32:33 -     let hs = [0.01 .. 0.01 .. 5.]
2018-12-03 22:32:33 -     let r = new Random()
2018-12-03 22:32:33 -     let x = r.NextDouble() * 10. - 5.
2018-12-03 22:32:33 -     Scatter(
2018-12-03 22:32:33 -         x = hs,
2018-12-03 22:32:33 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-03 22:32:33 -         name = "Погрешность 6)"
2018-12-03 22:32:33 -     )
2018-12-03 22:32:33 - [trace]
2018-12-03 22:32:33 - |> Chart.Plot
2018-12-03 22:32:33 - |> Chart.WithWidth 1000
2018-12-03 22:32:33 - |> Chart.WithHeight 700
2018-12-03 22:34:17 - let trace =
2018-12-03 22:34:17 -     let delta h x = abs (f' x - df_5 h x)
2018-12-03 22:34:17 -     let hs = [0.01 .. 0.01 .. 5.]
2018-12-03 22:34:17 -     let r = new Random()
2018-12-03 22:34:17 -     let x = r.NextDouble() * 10. - 5.
2018-12-03 22:34:17 -     Scatter(
2018-12-03 22:34:17 -         x = hs,
2018-12-03 22:34:17 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-03 22:34:17 -         name = "Погрешность 6)"
2018-12-03 22:34:17 -     )
2018-12-03 22:34:17 - [trace]
2018-12-03 22:34:17 - |> Chart.Plot
2018-12-03 22:34:17 - |> Chart.WithWidth 1000
2018-12-03 22:34:17 - |> Chart.WithHeight 700
2018-12-03 22:37:38 - let x = [-5. .. 0.01 .. 5.]
2018-12-03 22:37:38 - let trace1 =
2018-12-03 22:37:38 -     Scatter(
2018-12-03 22:37:38 -         x = x,
2018-12-03 22:37:38 -         y = (x |> List.map f),
2018-12-03 22:37:38 -         name = "f"
2018-12-03 22:37:38 -     )   
2018-12-03 22:37:38 - let trace2 =
2018-12-03 22:37:38 -     Scatter(
2018-12-03 22:37:38 -         x = x,
2018-12-03 22:37:38 -         y = (x |> List.map f'),
2018-12-03 22:37:38 -         name = "f'"
2018-12-03 22:37:38 -     )
2018-12-03 22:37:38 - let trace3 =
2018-12-03 22:37:38 -     Scatter(
2018-12-03 22:37:38 -         x = x,
2018-12-03 22:37:38 -         y = (x |> List.map f''),
2018-12-03 22:37:38 -         name = "f''"
2018-12-03 22:37:38 -     )
2018-12-03 22:37:38 - [trace1; trace2; trace3]
2018-12-03 22:37:38 - |> Chart.Plot
2018-12-03 22:37:38 - |> Chart.WithWidth 1000
2018-12-03 22:37:38 - |> Chart.WithHeight 700
2018-12-03 22:37:50 - let x = [-5. .. 0.01 .. 5.]
2018-12-03 22:37:50 - let trace1 =
2018-12-03 22:37:50 -     Scatter(
2018-12-03 22:37:50 -         x = x,
2018-12-03 22:37:50 -         y = (x |> List.map f),
2018-12-03 22:37:50 -         name = "f"
2018-12-03 22:37:50 -     )   
2018-12-03 22:37:50 - let trace2 =
2018-12-03 22:37:50 -     Scatter(
2018-12-03 22:37:50 -         x = x,
2018-12-03 22:37:50 -         y = (x |> List.map f'),
2018-12-03 22:37:50 -         name = "f'"
2018-12-03 22:37:50 -     )
2018-12-03 22:37:50 - let trace3 =
2018-12-03 22:37:50 -     Scatter(
2018-12-03 22:37:50 -         x = x,
2018-12-03 22:37:50 -         y = (x |> List.map f''),
2018-12-03 22:37:50 -         name = "f''"
2018-12-03 22:37:50 -     )
2018-12-03 22:37:50 - [trace1; trace2; trace3]
2018-12-03 22:37:50 - |> Chart.Plot
2018-12-03 22:37:50 - |> Chart.WithWidth 1000
2018-12-03 22:37:50 - |> Chart.WithHeight 700
2018-12-03 22:37:58 - let x = [-5. .. 0.01 .. 5.]
2018-12-03 22:37:58 - let trace1 =
2018-12-03 22:37:58 -     Scatter(
2018-12-03 22:37:58 -         x = x,
2018-12-03 22:37:58 -         y = (x |> List.map f),
2018-12-03 22:37:58 -         name = "f"
2018-12-03 22:37:58 -     )   
2018-12-03 22:37:58 - let trace2 =
2018-12-03 22:37:58 -     Scatter(
2018-12-03 22:37:58 -         x = x,
2018-12-03 22:37:58 -         y = (x |> List.map f'),
2018-12-03 22:37:58 -         name = "f'"
2018-12-03 22:37:58 -     )
2018-12-03 22:37:58 - let trace3 =
2018-12-03 22:37:58 -     Scatter(
2018-12-03 22:37:58 -         x = x,
2018-12-03 22:37:58 -         y = (x |> List.map f''),
2018-12-03 22:37:58 -         name = "f''"
2018-12-03 22:37:58 -     )
2018-12-03 22:37:58 - [trace1; trace2; trace3]
2018-12-03 22:37:58 - |> Chart.Plot
2018-12-03 22:37:58 - |> Chart.WithWidth 700
2018-12-03 22:37:58 - |> Chart.WithHeight 700
2018-12-03 22:38:09 - let x = [-5. .. 0.01 .. 5.]
2018-12-03 22:38:09 - let trace1 =
2018-12-03 22:38:09 -     Scatter(
2018-12-03 22:38:09 -         x = x,
2018-12-03 22:38:09 -         y = (x |> List.map f),
2018-12-03 22:38:09 -         name = "f"
2018-12-03 22:38:09 -     )   
2018-12-03 22:38:09 - let trace2 =
2018-12-03 22:38:09 -     Scatter(
2018-12-03 22:38:09 -         x = x,
2018-12-03 22:38:09 -         y = (x |> List.map f'),
2018-12-03 22:38:09 -         name = "f'"
2018-12-03 22:38:09 -     )
2018-12-03 22:38:09 - let trace3 =
2018-12-03 22:38:09 -     Scatter(
2018-12-03 22:38:09 -         x = x,
2018-12-03 22:38:09 -         y = (x |> List.map f''),
2018-12-03 22:38:09 -         name = "f''"
2018-12-03 22:38:09 -     )
2018-12-03 22:38:09 - [trace1; trace2; trace3]
2018-12-03 22:38:09 - |> Chart.Plot
2018-12-03 22:38:09 - |> Chart.WithWidth 900
2018-12-03 22:38:09 - |> Chart.WithHeight 700
2018-12-03 22:43:54 - let trace =
2018-12-03 22:43:54 -     let delta h x = abs (f' x - df_3 h x)
2018-12-03 22:43:54 -     let hs = [0.01 .. 0.01 .. 5.]
2018-12-03 22:43:54 -     let r = new Random()
2018-12-03 22:43:54 -     let x = r.NextDouble() * 10. - 5.
2018-12-03 22:43:54 -     Scatter(
2018-12-03 22:43:54 -         x = hs,
2018-12-03 22:43:54 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-03 22:43:54 -         name = "Погрешность 6)"
2018-12-03 22:43:54 -     )
2018-12-03 22:43:54 - [trace]
2018-12-03 22:43:54 - |> Chart.Plot
2018-12-03 22:43:54 - |> Chart.WithWidth 1000
2018-12-03 22:43:54 - |> Chart.WithHeight 700
2018-12-03 22:45:41 - let trace =
2018-12-03 22:45:41 -     let delta h x = abs (f' x - df_3 h x)
2018-12-03 22:45:41 -     let hs = [0.00001 .. 0.00001 .. 5.]
2018-12-03 22:45:41 -     let r = new Random()
2018-12-03 22:45:41 -     let x = r.NextDouble() * 10. - 5.
2018-12-03 22:45:41 -     Scatter(
2018-12-03 22:45:41 -         x = hs,
2018-12-03 22:45:41 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-03 22:45:41 -         name = "Погрешность 6)"
2018-12-03 22:45:41 -     )
2018-12-03 22:45:41 - [trace]
2018-12-03 22:45:41 - |> Chart.Plot
2018-12-03 22:45:41 - |> Chart.WithWidth 1000
2018-12-03 22:45:41 - |> Chart.WithHeight 700
2018-12-03 22:47:48 - let r = new Random()
2018-12-03 22:47:48 - let x = r.NextDouble() * 10. - 5.
2018-12-03 22:47:48 - let trace =
2018-12-03 22:47:48 -     let delta h x = abs (f' x - df_3 h x)
2018-12-03 22:47:48 -     let hs = [0.00001 .. 0.00001 .. 5.]
2018-12-03 22:47:48 -     Scatter(
2018-12-03 22:47:48 -         x = hs,
2018-12-03 22:47:48 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-03 22:47:48 -         name = "Погрешность 6)"
2018-12-03 22:47:48 -     )
2018-12-03 22:47:48 - [trace]
2018-12-03 22:47:48 - |> Chart.Plot
2018-12-03 22:47:48 - |> Chart.WithWidth 1000
2018-12-03 22:47:48 - |> Chart.WithHeight 700
2018-12-03 22:47:57 - let optimalStep start_h = 
2018-12-03 22:47:57 -     let rec optimalStepInternal h acc = 
2018-12-03 22:47:57 -         match h with
2018-12-03 22:47:57 -         | _ when h > 0. -> optimalStepInternal (h / 10.) ((abs (f' x - df_5 h x), h) :: acc)
2018-12-03 22:47:57 -         | _ -> acc
2018-12-03 22:47:57 -     optimalStepInternal start_h [] 
2018-12-03 22:47:57 -     |> List.minBy (fun (fx, _) -> fx) 
2018-12-03 22:47:57 -     |> snd
2018-12-03 22:48:12 - optimalStep
2018-12-03 22:48:26 - x, optimalStep 5.
2018-12-03 22:49:07 - let optimalStep start_h = 
2018-12-03 22:49:07 -     let rec optimalStepInternal h acc = 
2018-12-03 22:49:07 -         match h with
2018-12-03 22:49:07 -         | _ when h > 0.0000000001 -> optimalStepInternal (h / 10.) ((abs (f' x - df_5 h x), h) :: acc)
2018-12-03 22:49:07 -         | _ -> acc
2018-12-03 22:49:07 -     optimalStepInternal start_h [] 
2018-12-03 22:49:07 -     |> List.minBy (fun (fx, _) -> fx) 
2018-12-03 22:49:07 -     |> snd
2018-12-03 22:49:07 - x, optimalStep 5.
2018-12-03 22:49:56 - let optimalStep start_h = 
2018-12-03 22:49:56 -     let rec optimalStepInternal h acc = 
2018-12-03 22:49:56 -         match h with
2018-12-03 22:49:56 -         | _ when h > 0. -> optimalStepInternal (h / 10.) ((abs (f' x - df_5 h x), h) :: acc)
2018-12-03 22:49:56 -         | _ -> acc
2018-12-03 22:49:56 -     optimalStepInternal start_h [] 
2018-12-03 22:49:56 -     |> List.minBy fst
2018-12-03 22:49:56 -     |> snd
2018-12-03 22:49:57 - x, optimalStep 5.
2018-12-03 22:50:16 - let optimalStep start_h = 
2018-12-03 22:50:16 -     let rec optimalStepInternal h acc = 
2018-12-03 22:50:16 -         match h with
2018-12-03 22:50:16 -         | _ when h > 0. -> optimalStepInternal (h / 10.) ((abs (f' x - df_3 h x), h) :: acc)
2018-12-03 22:50:16 -         | _ -> acc
2018-12-03 22:50:16 -     optimalStepInternal start_h [] 
2018-12-03 22:50:16 -     |> List.minBy fst
2018-12-03 22:50:16 -     |> snd
2018-12-03 22:50:16 - x, optimalStep 5.
2018-12-03 22:50:55 - let optimalStep start_h = 
2018-12-03 22:50:55 -     let rec optimalStepInternal h acc = 
2018-12-03 22:50:55 -         match h with
2018-12-03 22:50:55 -         | _ when h > 0. -> optimalStepInternal (h / 2.) ((abs (f' x - df_3 h x), h) :: acc)
2018-12-03 22:50:55 -         | _ -> acc
2018-12-03 22:50:55 -     optimalStepInternal start_h [] 
2018-12-03 22:50:55 -     |> List.minBy fst
2018-12-03 22:50:55 -     |> snd
2018-12-03 22:50:56 - x, optimalStep 5.
2018-12-03 23:02:20 - let a = 0
2018-12-03 23:02:20 - let b = 1
2018-12-03 23:02:47 - let N = 10 //параметр
2018-12-03 23:07:02 - let a = 0
2018-12-03 23:07:02 - let b = 1
2018-12-03 23:07:02 - let f x = 1. / (x ** 2. + 4.)
2018-12-03 23:07:04 - let N = 10 //параметр
2018-12-03 23:07:44 - let a = 0.
2018-12-03 23:07:44 - let b = 1.
2018-12-03 23:07:44 - let f x = 1. / (x ** 2. + 4.)
2018-12-03 23:07:46 - let N = 10. //параметр
2018-12-03 23:07:57 - let h = (b - a) / N
2018-12-03 23:07:57 - let quadrature delta x = h * ([1. .. N] |> List.fold (fun acc k -> acc + f (delta + (k  - 1.) * h)) 0.)
2018-12-03 23:09:20 - let left_quadrature = quadrature a
2018-12-03 23:09:20 - Value restriction. The value 'left_quadrature' has been inferred to have generic type
2018-12-03 23:09:20 -     val left_quadrature : (obj -> float)    
2018-12-03 23:09:20 - Either make the arguments to 'left_quadrature' explicit or, if you do not intend for it to be generic, add a type annotation.
2018-12-03 23:11:49 - let h = (b - a) / N
2018-12-03 23:11:49 - let quadrature delta x = h * ([1. .. N] |> List.fold (fun acc k -> acc + f (delta + (k - 1.) * h)) 0.)
2018-12-03 23:12:47 - let left_quadrature x = quadrature a
2018-12-03 23:12:47 - let midle_quadrature x = quadrature (a + h / 2.)
2018-12-03 23:12:47 - let right_quadrature x = quadrature (a + h)
2018-12-03 23:27:07 - let x k = a + k * h
2018-12-03 23:30:37 - let trapezium x =
2018-12-03 23:30:37 -     let rec trapeziumInternal startIdx endIdx i = 
2018-12-03 23:30:37 -         match startIdx = endIdx with
2018-12-03 23:30:37 -         | false -> f (x startIdx) + f (x endIdx) + i * (trapeziumInternal (startIdx + 1.) (endIdx - 1.) (i + 1.))
2018-12-03 23:30:37 -         | true  -> f (x startIdx)
2018-12-03 23:30:37 -     h / 2. * (trapeziumInternal 0. N 1.)
2018-12-03 23:32:29 - let xk k = a + k * h
2018-12-03 23:32:30 - let trapezium x =
2018-12-03 23:32:30 -     let rec trapeziumInternal startIdx endIdx i = 
2018-12-03 23:32:30 -         match startIdx = endIdx with
2018-12-03 23:32:30 -         | false -> f (xk startIdx) + f (xk endIdx) + i * (trapeziumInternal (startIdx + 1.) (endIdx - 1.) (i + 1.))
2018-12-03 23:32:30 -         | true  -> f (xk startIdx)
2018-12-03 23:32:30 -     h / 2. * (trapeziumInternal 0. N 1.)
2018-12-03 23:39:49 - let h = (b - a) / N / 2.
2018-12-03 23:39:49 - let xk k = a + k * h
2018-12-03 23:43:47 - let simpson x = 
2018-12-03 23:43:47 -     let isEven n =
2018-12-03 23:43:47 -     match n % 2 with
2018-12-03 23:43:47 -     
2018-12-03 23:43:47 -     h / 3. * 
2018-12-03 23:43:47 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 23:43:47 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 23:43:47 - Unexpected infix operator in pattern
2018-12-03 23:43:47 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-12-03 23:49:12 - let simpson x = 
2018-12-03 23:49:12 -     let term n =
2018-12-03 23:49:12 -     match n % 2 = 1 with
2018-12-03 23:49:12 -     | true  -> 2. * f (xk float n)
2018-12-03 23:49:12 -     | false -> 4. * f (xk float n)
2018-12-03 23:49:12 -     h / 3. * (f (xk 0.) + f (xk (2. * N)) + ([1 .. 2 * int(N) - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-03 23:49:12 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 23:49:12 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 23:49:12 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 23:49:12 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-12-03 23:49:12 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-12-03 23:49:37 - let simpson x = 
2018-12-03 23:49:37 -     let term n =
2018-12-03 23:49:37 -         match n % 2 = 1 with
2018-12-03 23:49:37 -         | true  -> 2. * f (xk float n)
2018-12-03 23:49:37 -         | false -> 4. * f (xk float n)
2018-12-03 23:49:37 -     h / 3. * (f (xk 0.) + f (xk (2. * N)) + ([1 .. 2 * int(N) - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-03 23:49:37 - This value is not a function and cannot be applied.
2018-12-03 23:49:37 - This value is not a function and cannot be applied.
2018-12-03 23:49:51 - let simpson x = 
2018-12-03 23:49:51 -     let term n =
2018-12-03 23:49:51 -         match n % 2 = 1 with
2018-12-03 23:49:51 -         | true  -> 2. * f (xk (float n))
2018-12-03 23:49:51 -         | false -> 4. * f (xk (float n))
2018-12-03 23:49:51 -     h / 3. * (f (xk 0.) + f (xk (2. * N)) + ([1 .. 2 * int(N) - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-03 23:52:43 - let h = (b - a) / N
2018-12-03 23:52:43 - let quadrature delta = h * ([1. .. N] |> List.fold (fun acc k -> acc + f (delta + (k - 1.) * h)) 0.)
2018-12-03 23:52:43 - let left_quadrature = quadrature a
2018-12-03 23:52:43 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-03 23:52:43 - let right_quadrature = quadrature (a + h)
2018-12-03 23:52:49 - let xk k = a + k * h
2018-12-03 23:52:50 - let trapezium =
2018-12-03 23:52:50 -     let rec trapeziumInternal startIdx endIdx i = 
2018-12-03 23:52:50 -         match startIdx = endIdx with
2018-12-03 23:52:50 -         | false -> f (xk startIdx) + f (xk endIdx) + i * (trapeziumInternal (startIdx + 1.) (endIdx - 1.) (i + 1.))
2018-12-03 23:52:50 -         | true  -> f (xk startIdx)
2018-12-03 23:52:50 -     h / 2. * (trapeziumInternal 0. N 1.)
2018-12-03 23:52:58 - let h = (b - a) / N / 2.
2018-12-03 23:52:58 - let xk k = a + k * h
2018-12-03 23:53:00 - let simpson = 
2018-12-03 23:53:00 -     let term n =
2018-12-03 23:53:00 -         match n % 2 = 1 with
2018-12-03 23:53:00 -         | true  -> 2. * f (xk (float n))
2018-12-03 23:53:00 -         | false -> 4. * f (xk (float n))
2018-12-03 23:53:00 -     h / 3. * (f (xk 0.) + f (xk (2. * N)) + ([1 .. 2 * int(N) - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-03 23:53:37 - left_quadrature, midle_quadrature, right_quadrature
2018-12-03 23:53:48 - trapezium
2018-12-03 23:53:56 - let h = (b - a) / N
2018-12-03 23:53:56 - let quadrature delta = h * ([1. .. N] |> List.fold (fun acc k -> acc + f (delta + (k - 1.) * h)) 0.)
2018-12-03 23:53:56 - let left_quadrature = quadrature a
2018-12-03 23:53:56 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-03 23:53:56 - let right_quadrature = quadrature (a + h)
2018-12-03 23:53:57 - left_quadrature, midle_quadrature, right_quadrature
2018-12-03 23:53:58 - let xk k = a + k * h
2018-12-03 23:53:58 - let trapezium =
2018-12-03 23:53:58 -     let rec trapeziumInternal startIdx endIdx i = 
2018-12-03 23:53:58 -         match startIdx = endIdx with
2018-12-03 23:53:58 -         | false -> f (xk startIdx) + f (xk endIdx) + i * (trapeziumInternal (startIdx + 1.) (endIdx - 1.) (i + 1.))
2018-12-03 23:53:58 -         | true  -> f (xk startIdx)
2018-12-03 23:53:58 -     h / 2. * (trapeziumInternal 0. N 1.)
2018-12-03 23:53:58 - trapezium
2018-12-03 23:54:02 - let h = (b - a) / N / 2.
2018-12-03 23:54:02 - let xk k = a + k * h
2018-12-03 23:54:02 - let simpson = 
2018-12-03 23:54:02 -     let term n =
2018-12-03 23:54:02 -         match n % 2 = 1 with
2018-12-03 23:54:02 -         | true  -> 2. * f (xk (float n))
2018-12-03 23:54:02 -         | false -> 4. * f (xk (float n))
2018-12-03 23:54:02 -     h / 3. * (f (xk 0.) + f (xk (2. * N)) + ([1 .. 2 * int(N) - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-03 23:54:07 - simpson
2018-12-04 00:06:02 - let xk k = a + k * h
2018-12-04 00:06:02 - let trapezium = h / 2. * (f (xk 0.) + f (xk N) 
2018-12-04 00:06:02 -                     + 2. * ([1. .. N - 1.] |> List.fold (fun acc i -> acc + f (xk i)) 0.)
2018-12-04 00:06:02 - Unmatched '('
2018-12-04 00:06:37 - let trapezium = h / 2. * (f (xk 0.) + f (xk N) 
2018-12-04 00:06:37 -                     + 2. * ([1. .. N - 1.] |> List.fold (fun acc i -> acc + f (xk i)) 0.))
2018-12-04 00:06:38 - trapezium
2018-12-04 00:07:17 - let a = 0.
2018-12-04 00:07:17 - let b = 1.
2018-12-04 00:07:17 - let f x = 1. / (x ** 2. + 4.)
2018-12-04 00:07:18 - let N = 10. //параметр
2018-12-04 00:07:19 - let h = (b - a) / N
2018-12-04 00:07:19 - let quadrature delta = h * ([1. .. N] |> List.fold (fun acc k -> acc + f (delta + (k - 1.) * h)) 0.)
2018-12-04 00:07:20 - let left_quadrature = quadrature a
2018-12-04 00:07:20 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-04 00:07:20 - let right_quadrature = quadrature (a + h)
2018-12-04 00:07:21 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 00:07:23 - let xk k = a + k * h
2018-12-04 00:07:23 - let trapezium = h / 2. * (f (xk 0.) + f (xk N) 
2018-12-04 00:07:23 -                     + 2. * ([1. .. N - 1.] |> List.fold (fun acc i -> acc + f (xk i)) 0.))
2018-12-04 00:07:24 - trapezium
2018-12-04 00:07:28 - let h = (b - a) / N / 2.
2018-12-04 00:07:28 - let xk k = a + k * h
2018-12-04 00:07:29 - let simpson = 
2018-12-04 00:07:29 -     let term n =
2018-12-04 00:07:29 -         match n % 2 = 1 with
2018-12-04 00:07:29 -         | true  -> 2. * f (xk (float n))
2018-12-04 00:07:29 -         | false -> 4. * f (xk (float n))
2018-12-04 00:07:29 -     h / 3. * (f (xk 0.) + f (xk (2. * N)) + ([1 .. 2 * int(N) - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-04 00:07:30 - simpson
2018-12-04 00:14:32 - arctg 1
2018-12-04 00:14:32 - The value or constructor 'arctg' is not defined.
2018-12-04 00:14:37 - arctan 1
2018-12-04 00:14:37 - The value or constructor 'arctan' is not defined. Maybe you want one of the following:
2018-12-04 00:14:37 -    atan
2018-12-04 00:14:40 - atan 1
2018-12-04 00:14:40 - The type 'int' does not support the operator 'Atan'
2018-12-04 00:14:44 - atan 1.
2018-12-04 00:14:49 - atan 1. / 2.
2018-12-04 00:14:55 - atan (1. / 2.)
2018-12-04 00:15:51 - atan (1. / 2.) / 2.
2018-12-04 00:16:08 - atan 0.
2018-12-04 00:17:57 - let exact = atan (1. / 2.) / 2.
2018-12-04 00:18:01 - let exact = atan (1. / 2.) / 2.
2018-12-04 00:18:01 - exact
2018-12-04 00:18:40 - let N = 100. //параметр
2018-12-04 00:18:41 - let h = (b - a) / N
2018-12-04 00:18:41 - let quadrature delta = h * ([1. .. N] |> List.fold (fun acc k -> acc + f (delta + (k - 1.) * h)) 0.)
2018-12-04 00:18:42 - let left_quadrature = quadrature a
2018-12-04 00:18:42 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-04 00:18:42 - let right_quadrature = quadrature (a + h)
2018-12-04 00:18:42 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 00:18:46 - let xk k = a + k * h
2018-12-04 00:18:46 - let trapezium = h / 2. * (f (xk 0.) + f (xk N) 
2018-12-04 00:18:46 -                     + 2. * ([1. .. N - 1.] |> List.fold (fun acc i -> acc + f (xk i)) 0.))
2018-12-04 00:18:47 - trapezium
2018-12-04 00:18:49 - let h = (b - a) / N / 2.
2018-12-04 00:18:49 - let xk k = a + k * h
2018-12-04 00:18:49 - let simpson = 
2018-12-04 00:18:49 -     let term n =
2018-12-04 00:18:49 -         match n % 2 = 1 with
2018-12-04 00:18:49 -         | true  -> 2. * f (xk (float n))
2018-12-04 00:18:49 -         | false -> 4. * f (xk (float n))
2018-12-04 00:18:49 -     h / 3. * (f (xk 0.) + f (xk (2. * N)) + ([1 .. 2 * int(N) - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-04 00:18:50 - simpson
2018-12-04 00:18:57 - let exact = atan (1. / 2.) / 2.
2018-12-04 00:18:57 - exact
2018-12-04 00:20:56 - abs (exact left_quadrature)
2018-12-04 00:20:56 - This value is not a function and cannot be applied.
2018-12-04 00:21:00 - abs (exact - left_quadrature)
2018-12-04 00:21:14 - abs (exact - midle_quadrature)
2018-12-04 00:21:27 - abs (exact - right_quadrature)
2018-12-04 00:21:38 - abs (exact - trapezium)
2018-12-04 00:21:54 - abs (exact - simpson)
2018-12-04 00:22:52 - let a = 0m
2018-12-04 00:22:52 - let b = 1m
2018-12-04 00:22:52 - let f x = 1m / (x ** 2m + 4m)
2018-12-04 00:22:52 - The type 'decimal' does not support the operator 'Pow'
2018-12-04 00:23:15 - let a = 0m
2018-12-04 00:23:15 - let b = 1m
2018-12-04 00:23:15 - let f x = 1m / (decimal (x ** 2.) + 4m)
2018-12-04 00:23:21 - let N = 100 //параметр
2018-12-04 00:24:03 - let h = (b - a) / (decimal N)
2018-12-04 00:24:03 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (decimal k - 1m) * h)) 0m)
2018-12-04 00:24:03 - This expression was expected to have type
2018-12-04 00:24:03 -     'float'    
2018-12-04 00:24:03 - but here has type
2018-12-04 00:24:03 -     'decimal'    
2018-12-04 00:24:57 - let a = 0m
2018-12-04 00:24:57 - let b = 1m
2018-12-04 00:24:57 - let f (x : decimal) = 1m / (x ** 2.) + 4m)
2018-12-04 00:24:57 - Unexpected symbol ')' in binding. Expected incomplete structured construct at or before this point or other token.
2018-12-04 00:25:03 - let a = 0m
2018-12-04 00:25:03 - let b = 1m
2018-12-04 00:25:03 - let f (x : decimal) = 1m / ((x ** 2.) + 4m)
2018-12-04 00:25:03 - The type 'decimal' does not support the operator 'Pow'
2018-12-04 00:25:26 - let a = 0m
2018-12-04 00:25:26 - let b = 1m
2018-12-04 00:25:26 - let f (x : decimal) = 1m / (x * x + 4m)
2018-12-04 00:25:26 - let N = 100 //параметр
2018-12-04 00:25:29 - let h = (b - a) / (decimal N)
2018-12-04 00:25:29 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (decimal k - 1m) * h)) 0m)
2018-12-04 00:25:39 - let left_quadrature = quadrature a
2018-12-04 00:25:39 - let midle_quadrature = quadrature (a + h / 2m)
2018-12-04 00:25:39 - let right_quadrature = quadrature (a + h)
2018-12-04 00:25:40 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 00:25:46 - let xk k = a + k * h
2018-12-04 00:26:34 - let trapezium = h / 2m * (f (xk 0m) + f (xk (decimal N)) 
2018-12-04 00:26:34 -                     + 2m * ([1 .. N - 1] |> List.fold (fun acc k -> acc + f (xk (decimal k))) 0m))
2018-12-04 00:26:35 - trapezium
2018-12-04 00:26:43 - let h = (b - a) / N / 2m
2018-12-04 00:26:43 - let xk k = a + k * h
2018-12-04 00:26:43 - Type constraint mismatch. The type 
2018-12-04 00:26:43 -     'int'    
2018-12-04 00:26:43 - is not compatible with type
2018-12-04 00:26:43 -     'decimal'    
2018-12-04 00:26:43 - Type constraint mismatch. The type 
2018-12-04 00:26:43 -     'int'    
2018-12-04 00:26:43 - is not compatible with type
2018-12-04 00:26:43 -     'decimal'    
2018-12-04 00:26:53 - let h = (b - a) / (decimal N) / 2m
2018-12-04 00:26:53 - let xk k = a + k * h
2018-12-04 00:27:49 - let simpson = 
2018-12-04 00:27:49 -     let term n =
2018-12-04 00:27:49 -         match n % 2 = 1 with
2018-12-04 00:27:49 -         | true  -> 2m * f (xk (decimal n))
2018-12-04 00:27:49 -         | false -> 4m * f (xk (decimal n))
2018-12-04 00:27:49 -     h / 3m * (f (xk 0m) + f (xk (2m * (decimal N))) 
2018-12-04 00:27:49 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0m))
2018-12-04 00:27:50 - simpson
2018-12-04 00:29:13 - let exact = atan (1. / 2.) / 2.
2018-12-04 00:29:13 - exact
2018-12-04 00:29:28 - abs (exact - (decimal left_quadrature))
2018-12-04 00:29:28 - Type constraint mismatch. The type 
2018-12-04 00:29:28 -     'float'    
2018-12-04 00:29:28 - is not compatible with type
2018-12-04 00:29:28 -     'decimal'    
2018-12-04 00:29:28 - Type constraint mismatch. The type 
2018-12-04 00:29:28 -     'float'    
2018-12-04 00:29:28 - is not compatible with type
2018-12-04 00:29:28 -     'decimal'    
2018-12-04 00:29:44 - abs (decimal exact - left_quadrature)
2018-12-04 00:29:52 - abs (decimal exact - midle_quadrature)
2018-12-04 00:29:58 - abs (decimal exact - right_quadrature)
2018-12-04 00:30:02 - abs (decimal exact - trapezium)
2018-12-04 00:30:12 - abs (decimal exact - simpson)
2018-12-04 00:31:25 - simpson, h
2018-12-04 00:31:43 - simpson
2018-12-04 00:36:24 - let simpson = 
2018-12-04 00:36:24 -     let term n =
2018-12-04 00:36:24 -         match n % 2 = 0 with
2018-12-04 00:36:24 -         | true  -> 2m * f (xk (decimal n))
2018-12-04 00:36:24 -         | false -> 4m * f (xk (decimal n))
2018-12-04 00:36:24 -     h / 3m * (f (xk 0m) + f (xk (2m * (decimal N))) 
2018-12-04 00:36:24 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0m))
2018-12-04 00:36:24 - simpson
2018-12-04 00:36:31 - let h = (b - a) / (decimal N)
2018-12-04 00:36:31 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (decimal k - 1m) * h)) 0m)
2018-12-04 00:36:31 - let left_quadrature = quadrature a
2018-12-04 00:36:31 - let midle_quadrature = quadrature (a + h / 2m)
2018-12-04 00:36:31 - let right_quadrature = quadrature (a + h)
2018-12-04 00:36:34 - let a = 0m
2018-12-04 00:36:34 - let b = 1m
2018-12-04 00:36:34 - let f (x : decimal) = 1m / (x * x + 4m)
2018-12-04 00:36:34 - let N = 100 //параметр
2018-12-04 00:36:35 - let h = (b - a) / (decimal N)
2018-12-04 00:36:35 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (decimal k - 1m) * h)) 0m)
2018-12-04 00:36:35 - let left_quadrature = quadrature a
2018-12-04 00:36:35 - let midle_quadrature = quadrature (a + h / 2m)
2018-12-04 00:36:35 - let right_quadrature = quadrature (a + h)
2018-12-04 00:36:35 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 00:36:36 - let xk k = a + k * h
2018-12-04 00:36:36 - let trapezium = h / 2m * (f (xk 0m) + f (xk (decimal N)) 
2018-12-04 00:36:36 -                     + 2m * ([1 .. N - 1] |> List.fold (fun acc k -> acc + f (xk (decimal k))) 0m))
2018-12-04 00:36:36 - trapezium
2018-12-04 00:36:37 - let h = (b - a) / (decimal N) / 2m
2018-12-04 00:36:37 - let xk k = a + k * h
2018-12-04 00:36:38 - let simpson = 
2018-12-04 00:36:38 -     let term n =
2018-12-04 00:36:38 -         match n % 2 = 0 with
2018-12-04 00:36:38 -         | true  -> 2m * f (xk (decimal n))
2018-12-04 00:36:38 -         | false -> 4m * f (xk (decimal n))
2018-12-04 00:36:38 -     h / 3m * (f (xk 0m) + f (xk (2m * (decimal N))) 
2018-12-04 00:36:38 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0m))
2018-12-04 00:36:38 - simpson
2018-12-04 00:36:39 - let exact = atan (1. / 2.) / 2.
2018-12-04 00:36:39 - exact
2018-12-04 00:36:40 - abs (decimal exact - left_quadrature)
2018-12-04 00:36:40 - abs (decimal exact - midle_quadrature)
2018-12-04 00:36:40 - abs (decimal exact - right_quadrature)
2018-12-04 00:36:41 - abs (decimal exact - trapezium)
2018-12-04 00:36:41 - abs (decimal exact - simpson)
2018-12-04 00:38:07 - nameof(exact)
2018-12-04 00:38:07 - The value or constructor 'nameof' is not defined.
2018-12-04 00:47:35 - let exact = decimal (atan (1. / 2.) / 2.)
2018-12-04 00:47:35 - exact
2018-12-04 00:48:01 - let factError func = abs (exact - func)
2018-12-04 00:53:00 - let a = 0.
2018-12-04 00:53:00 - let b = 1.
2018-12-04 00:53:00 - let f x = 1. / (x * x + 4.)
2018-12-04 00:53:01 - let N = 100 //параметр
2018-12-04 00:53:27 - let h = (b - a) / float N
2018-12-04 00:53:27 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (float k - 1.) * h)) 0.)
2018-12-04 00:53:32 - let left_quadrature = quadrature a
2018-12-04 00:53:32 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-04 00:53:32 - let right_quadrature = quadrature (a + h)
2018-12-04 00:53:32 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 00:53:58 - let trapezium = h / 2. * (f (xk 0.) + f (xk (float N)) 
2018-12-04 00:53:58 -                     + 2. * ([1 .. N - 1] |> List.fold (fun acc k -> acc + f (xk (float k))) 0.))
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - This expression was expected to have type
2018-12-04 00:53:58 -     'float'    
2018-12-04 00:53:58 - but here has type
2018-12-04 00:53:58 -     'decimal'    
2018-12-04 00:54:14 - trapezium
2018-12-04 00:54:47 - trapezium
2018-12-04 00:55:03 - let h = (b - a) / (float N) / 2.
2018-12-04 00:55:03 - let xk k = a + k * h
2018-12-04 00:55:28 - let simpson = 
2018-12-04 00:55:28 -     let term n =
2018-12-04 00:55:28 -         match n % 2 = 0 with
2018-12-04 00:55:28 -         | true  -> 2. * f (xk (float n))
2018-12-04 00:55:28 -         | false -> 4. * f (xk (float n))
2018-12-04 00:55:28 -     h / 3. * (f (xk 0.) + f (xk (2. * (float N))) 
2018-12-04 00:55:28 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-04 00:55:29 - simpson
2018-12-04 00:55:31 - let exact = decimal (atan (1. / 2.) / 2.)
2018-12-04 00:55:31 - exact
2018-12-04 00:55:35 - let factError func = abs (exact - func)
2018-12-04 00:55:41 - let exact = atan (1. / 2.) / 2.
2018-12-04 00:55:41 - exact
2018-12-04 00:55:42 - let factError func = abs (exact - func)
2018-12-04 01:00:35 - let f' x = -2. * x / ((x ** 2. + 4.) ** 2.)
2018-12-04 01:00:35 - let f'' x = (8. * x ** 2.) / ((x ** 2. + 4.) ** 3.) - 2. / ((x ** 2. + 4.) ** 2.)
2018-12-04 01:00:35 - let f'''' x = -(228. * x ** 2.) / ((x ** 2. + 4.) ** 4.) 
2018-12-04 01:00:35 -                 + 24. / ((x ** 2. + 4.) ** 3.) 
2018-12-04 01:00:35 -                 + 384. * x ** 4. / ((x ** 2. + 4.) ** 5.) 
2018-12-04 01:07:37 - let theoryError c d =
2018-12-04 01:07:37 -     let m = 
2018-12-04 01:07:37 -         let func =
2018-12-04 01:07:37 -             match d with
2018-12-04 01:07:37 -             | 0 -> f'
2018-12-04 01:07:37 -             | 1 -> f''
2018-12-04 01:07:37 -             | 3 -> f''''
2018-12-04 01:07:37 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:07:37 -         [a .. 0.000001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:07:37 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:16:17 - let a = 0.
2018-12-04 01:16:17 - let b = 1.
2018-12-04 01:16:17 - let f x = 1. / (x * x + 4.)
2018-12-04 01:16:17 - let N = 100 //параметр
2018-12-04 01:16:18 - let h = (b - a) / float N
2018-12-04 01:16:18 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (float k - 1.) * h)) 0.)
2018-12-04 01:16:18 - let left_quadrature = quadrature a
2018-12-04 01:16:18 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-04 01:16:18 - let right_quadrature = quadrature (a + h)
2018-12-04 01:16:19 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 01:16:20 - let xk k = a + k * h
2018-12-04 01:16:20 - let trapezium = h / 2. * (f (xk 0.) + f (xk (float N)) 
2018-12-04 01:16:20 -                     + 2. * ([1 .. N - 1] |> List.fold (fun acc k -> acc + f (xk (float k))) 0.))
2018-12-04 01:16:21 - trapezium
2018-12-04 01:16:22 - let h = (b - a) / (float N) / 2.
2018-12-04 01:16:22 - let xk k = a + k * h
2018-12-04 01:16:23 - let simpson = 
2018-12-04 01:16:23 -     let term n =
2018-12-04 01:16:23 -         match n % 2 = 0 with
2018-12-04 01:16:23 -         | true  -> 2. * f (xk (float n))
2018-12-04 01:16:23 -         | false -> 4. * f (xk (float n))
2018-12-04 01:16:23 -     h / 3. * (f (xk 0.) + f (xk (2. * (float N))) 
2018-12-04 01:16:23 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-04 01:16:23 - simpson
2018-12-04 01:16:24 - let exact = atan (1. / 2.) / 2.
2018-12-04 01:16:24 - exact
2018-12-04 01:16:24 - let factError func = abs (exact - func)
2018-12-04 01:16:25 - let f' x = -2. * x / ((x ** 2. + 4.) ** 2.)
2018-12-04 01:16:25 - let f'' x = (8. * x ** 2.) / ((x ** 2. + 4.) ** 3.) - 2. / ((x ** 2. + 4.) ** 2.)
2018-12-04 01:16:25 - let f'''' x = -(228. * x ** 2.) / ((x ** 2. + 4.) ** 4.) 
2018-12-04 01:16:25 -                 + 24. / ((x ** 2. + 4.) ** 3.) 
2018-12-04 01:16:25 -                 + 384. * x ** 4. / ((x ** 2. + 4.) ** 5.) 
2018-12-04 01:16:27 - let theoryError c d =
2018-12-04 01:16:27 -     let m = 
2018-12-04 01:16:27 -         let func =
2018-12-04 01:16:27 -             match d with
2018-12-04 01:16:27 -             | 0 -> f'
2018-12-04 01:16:27 -             | 1 -> f''
2018-12-04 01:16:27 -             | 3 -> f''''
2018-12-04 01:16:27 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:16:27 -         [a .. 0.000001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:16:27 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:16:29 - let info =
2018-12-04 01:16:29 -     (sprintf "left quadrature --- fact error: %f theory error: %f" 
2018-12-04 01:16:29 -     <| factError left_quadrature 
2018-12-04 01:16:29 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:16:29 -     +
2018-12-04 01:16:29 -     (sprintf "midle quadrature --- fact error: %f theory error: %f" 
2018-12-04 01:16:29 -     <| factError midle_quadrature 
2018-12-04 01:16:29 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:16:29 -     +
2018-12-04 01:16:29 -     (sprintf "right quadrature --- fact error: %f theory error: %f" 
2018-12-04 01:16:29 -     <| factError right_quadrature 
2018-12-04 01:16:29 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:16:29 -     +
2018-12-04 01:16:29 -     (sprintf "trapezium --- fact error: %f theory error: %f" 
2018-12-04 01:16:29 -     <| factError trapezium 
2018-12-04 01:16:29 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:16:29 -     +
2018-12-04 01:16:29 -     (sprintf "simpson --- fact error: %f theory error: %f" 
2018-12-04 01:16:29 -     <| factError simpson 
2018-12-04 01:16:29 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:16:34 - info
2018-12-04 01:16:56 - let info =
2018-12-04 01:16:56 -     (sprintf "left quadrature --- fact error: %f theory error: %f" 
2018-12-04 01:16:56 -     <| factError left_quadrature 
2018-12-04 01:16:56 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:16:56 -     +
2018-12-04 01:16:56 -     (sprintf "\nmidle quadrature --- fact error: %f theory error: %f" 
2018-12-04 01:16:56 -     <| factError midle_quadrature 
2018-12-04 01:16:56 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:16:56 -     +
2018-12-04 01:16:56 -     (sprintf "\nright quadrature --- fact error: %f theory error: %f" 
2018-12-04 01:16:56 -     <| factError right_quadrature 
2018-12-04 01:16:56 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:16:56 -     +
2018-12-04 01:16:56 -     (sprintf "\ntrapezium --- fact error: %f theory error: %f" 
2018-12-04 01:16:56 -     <| factError trapezium 
2018-12-04 01:16:56 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:16:56 -     +
2018-12-04 01:16:56 -     (sprintf "\nsimpson --- fact error: %f theory error: %f" 
2018-12-04 01:16:56 -     <| factError simpson 
2018-12-04 01:16:56 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:16:57 - info
2018-12-04 01:19:32 - let info =
2018-12-04 01:19:32 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:19:32 -     <| factError left_quadrature 
2018-12-04 01:19:32 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:19:32 -     +
2018-12-04 01:19:32 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:19:32 -     <| factError midle_quadrature 
2018-12-04 01:19:32 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:19:32 -     +
2018-12-04 01:19:32 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:19:32 -     <| factError right_quadrature 
2018-12-04 01:19:32 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:19:32 -     +
2018-12-04 01:19:32 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:19:32 -     <| factError trapezium 
2018-12-04 01:19:32 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:19:32 -     +
2018-12-04 01:19:32 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:19:32 -     <| factError simpson 
2018-12-04 01:19:32 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:19:34 - info
2018-12-04 01:22:09 - let theoryError c d =
2018-12-04 01:22:09 -     let m = 
2018-12-04 01:22:09 -         let func =
2018-12-04 01:22:09 -             match d with
2018-12-04 01:22:09 -             | 0 -> f'
2018-12-04 01:22:09 -             | 1 -> f''
2018-12-04 01:22:09 -             | 3 -> f''''
2018-12-04 01:22:09 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:22:09 -         [a .. 0.000001 .. b] |> List.maxBy (abs >> func)
2018-12-04 01:22:09 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:22:09 - let info =
2018-12-04 01:22:09 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:22:09 -     <| factError left_quadrature 
2018-12-04 01:22:09 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:22:09 -     +
2018-12-04 01:22:09 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:22:09 -     <| factError midle_quadrature 
2018-12-04 01:22:09 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:22:09 -     +
2018-12-04 01:22:09 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:22:09 -     <| factError right_quadrature 
2018-12-04 01:22:09 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:22:09 -     +
2018-12-04 01:22:09 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:22:09 -     <| factError trapezium 
2018-12-04 01:22:09 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:22:09 -     +
2018-12-04 01:22:09 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:22:09 -     <| factError simpson 
2018-12-04 01:22:09 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:22:11 - info
2018-12-04 01:22:57 - let theoryError c d =
2018-12-04 01:22:57 -     let m = 
2018-12-04 01:22:57 -         let func =
2018-12-04 01:22:57 -             match d with
2018-12-04 01:22:57 -             | 0 -> f'
2018-12-04 01:22:57 -             | 1 -> f''
2018-12-04 01:22:57 -             | 3 -> f''''
2018-12-04 01:22:57 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:22:57 -         [a .. 0.000001 .. b] |> List.maxBy (fun i -> abs (func i))
2018-12-04 01:22:57 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:22:58 - let info =
2018-12-04 01:22:58 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:22:58 -     <| factError left_quadrature 
2018-12-04 01:22:58 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:22:58 -     +
2018-12-04 01:22:58 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:22:58 -     <| factError midle_quadrature 
2018-12-04 01:22:58 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:22:58 -     +
2018-12-04 01:22:58 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:22:58 -     <| factError right_quadrature 
2018-12-04 01:22:58 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:22:58 -     +
2018-12-04 01:22:58 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:22:58 -     <| factError trapezium 
2018-12-04 01:22:58 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:22:58 -     +
2018-12-04 01:22:58 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:22:58 -     <| factError simpson 
2018-12-04 01:22:58 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:23:00 - info
2018-12-04 01:23:20 - let theoryError c d =
2018-12-04 01:23:20 -     let m = 
2018-12-04 01:23:20 -         let func =
2018-12-04 01:23:20 -             match d with
2018-12-04 01:23:20 -             | 0 -> f'
2018-12-04 01:23:20 -             | 1 -> f''
2018-12-04 01:23:20 -             | 3 -> f''''
2018-12-04 01:23:20 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:23:20 -         [a .. 0.000001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:23:20 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:23:20 - let info =
2018-12-04 01:23:20 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:23:20 -     <| factError left_quadrature 
2018-12-04 01:23:20 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:23:20 -     +
2018-12-04 01:23:20 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:23:20 -     <| factError midle_quadrature 
2018-12-04 01:23:20 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:23:20 -     +
2018-12-04 01:23:20 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:23:20 -     <| factError right_quadrature 
2018-12-04 01:23:20 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:23:20 -     +
2018-12-04 01:23:20 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:23:20 -     <| factError trapezium 
2018-12-04 01:23:20 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:23:20 -     +
2018-12-04 01:23:20 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:23:20 -     <| factError simpson 
2018-12-04 01:23:20 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:23:21 - info
2018-12-04 01:24:08 - let theoryError c d =
2018-12-04 01:24:08 -     let m = 
2018-12-04 01:24:08 -         let func =
2018-12-04 01:24:08 -             match d with
2018-12-04 01:24:08 -             | 0 -> f'
2018-12-04 01:24:08 -             | 1 -> f''
2018-12-04 01:24:08 -             | 3 -> f''''
2018-12-04 01:24:08 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:24:08 -         [a .. 0.00000001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:24:08 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:24:09 - let info =
2018-12-04 01:24:09 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:24:09 -     <| factError left_quadrature 
2018-12-04 01:24:09 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:24:09 -     +
2018-12-04 01:24:09 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:24:09 -     <| factError midle_quadrature 
2018-12-04 01:24:09 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:24:09 -     +
2018-12-04 01:24:09 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:24:09 -     <| factError right_quadrature 
2018-12-04 01:24:09 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:24:09 -     +
2018-12-04 01:24:09 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:24:09 -     <| factError trapezium 
2018-12-04 01:24:09 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:24:09 -     +
2018-12-04 01:24:09 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:24:09 -     <| factError simpson 
2018-12-04 01:24:09 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:27:44 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-04 01:27:44 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-04 01:27:44 - For help type #help;;
2018-12-04 01:27:44 - > val it :
2018-12-04 01:27:44 -   ResizeArray<System.Type *
2018-12-04 01:27:44 -               (obj ->
2018-12-04 01:27:44 -                  seq<string *
2018-12-04 01:27:44 -                      string> *
2018-12-04 01:27:44 -                  string)>
2018-12-04 01:27:44 - = seq []
2018-12-04 01:27:44 - --> Added '/home/max/IfSharp.v3.0.1' to library include path
2018-12-04 01:27:44 - --> Referenced '/home/max/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-04 01:27:44 - --> Referenced '/home/max/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-04 01:28:24 - let theoryError c d =
2018-12-04 01:28:24 -     let m = 
2018-12-04 01:28:24 -         let func =
2018-12-04 01:28:24 -             match d with
2018-12-04 01:28:24 -             | 0 -> f'
2018-12-04 01:28:24 -             | 1 -> f''
2018-12-04 01:28:24 -             | 3 -> f''''
2018-12-04 01:28:24 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:28:24 -         [a .. 0.000001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:28:24 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:28:24 - The value or constructor 'f'' is not defined.
2018-12-04 01:28:24 - The value or constructor 'f''' is not defined.
2018-12-04 01:28:24 - The value or constructor 'f''''' is not defined.
2018-12-04 01:28:24 - The value or constructor 'a' is not defined. Maybe you want one of the following:
2018-12-04 01:28:24 -    c
2018-12-04 01:28:24 -    d
2018-12-04 01:28:24 - The value or constructor 'b' is not defined. Maybe you want one of the following:
2018-12-04 01:28:24 -    c
2018-12-04 01:28:24 -    d
2018-12-04 01:28:24 - The value or constructor 'b' is not defined. Maybe you want one of the following:
2018-12-04 01:28:24 -    c
2018-12-04 01:28:24 -    d
2018-12-04 01:28:24 -    m
2018-12-04 01:28:24 - The value or constructor 'a' is not defined. Maybe you want one of the following:
2018-12-04 01:28:24 -    c
2018-12-04 01:28:24 -    d
2018-12-04 01:28:24 -    m
2018-12-04 01:28:24 - The value or constructor 'b' is not defined. Maybe you want one of the following:
2018-12-04 01:28:24 -    c
2018-12-04 01:28:24 -    d
2018-12-04 01:28:24 -    m
2018-12-04 01:28:24 - The value or constructor 'a' is not defined. Maybe you want one of the following:
2018-12-04 01:28:24 -    c
2018-12-04 01:28:24 -    d
2018-12-04 01:28:24 -    m
2018-12-04 01:28:24 - The value or constructor 'N' is not defined. Maybe you want one of the following:
2018-12-04 01:28:24 -    c
2018-12-04 01:28:24 -    d
2018-12-04 01:28:24 -    m
2018-12-04 01:28:36 - #load "XPlot.Plotly.Paket.fsx"
2018-12-04 01:28:36 - #load "XPlot.Plotly.fsx"
2018-12-04 01:28:36 - open XPlot.Plotly
2018-12-04 01:28:36 - open System
2018-12-04 01:28:40 - let f x = sin x / (1. + x ** 2.)
2018-12-04 01:28:40 - let df_1 h x = (f (x + h) - f x) / h
2018-12-04 01:28:40 - let df_2 h x = (f x - f (x - h)) / h
2018-12-04 01:28:40 - let df_3 h x = (f (x + h) - f (x - h)) / (2. * h)
2018-12-04 01:28:40 - let df_4 h x = (-3. * f x + 4. * f (x + h) - f (x + 2. * h)) / (2. * h)
2018-12-04 01:28:40 - let df_5 h x = (-3. * f x - 4. * f (x - h) + f (x - 2. * h)) / (2. * h)
2018-12-04 01:28:40 - let df_6 h x = (f (x + h) - 2. * f x + f (x - h)) / (h ** 2.)
2018-12-04 01:28:40 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-12-04 01:28:40 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-12-04 01:28:40 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-12-04 01:28:40 - let x = [-5. .. 0.01 .. 5.]
2018-12-04 01:28:40 - let trace1 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map f),
2018-12-04 01:28:40 -         name = "f"
2018-12-04 01:28:40 -     )   
2018-12-04 01:28:40 - let trace2 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map f'),
2018-12-04 01:28:40 -         name = "f'"
2018-12-04 01:28:40 -     )
2018-12-04 01:28:40 - let trace3 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map f''),
2018-12-04 01:28:40 -         name = "f''"
2018-12-04 01:28:40 -     )
2018-12-04 01:28:40 - [trace1; trace2; trace3]
2018-12-04 01:28:40 - |> Chart.Plot
2018-12-04 01:28:40 - |> Chart.WithWidth 900
2018-12-04 01:28:40 - |> Chart.WithHeight 700
2018-12-04 01:28:40 - let x = [-5. .. 0.01 .. 5.]
2018-12-04 01:28:40 - let trace1 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map (fun i -> abs (f' i - df_1 1. i))),
2018-12-04 01:28:40 -         name = "Погрешность 1)"
2018-12-04 01:28:40 -     )   
2018-12-04 01:28:40 - let trace2 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map (fun i -> abs (f' i - df_2 1. i))),
2018-12-04 01:28:40 -         name = "Погрешность 2)"
2018-12-04 01:28:40 -     )
2018-12-04 01:28:40 - let trace3 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map (fun i -> abs (f' i - df_3 1. i))),
2018-12-04 01:28:40 -         name = "Погрешность 3)"
2018-12-04 01:28:40 -     )
2018-12-04 01:28:40 - let trace4 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map (fun i -> abs (f' i - df_4 1. i))),
2018-12-04 01:28:40 -         name = "Погрешность 4)"
2018-12-04 01:28:40 -     )
2018-12-04 01:28:40 - let trace5 =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map (fun i -> abs (f' i - df_5 1. i))),
2018-12-04 01:28:40 -         name = "Погрешность 5)"
2018-12-04 01:28:40 -     )
2018-12-04 01:28:40 - [trace1; trace2; trace3; trace4; trace5]
2018-12-04 01:28:40 - |> Chart.Plot
2018-12-04 01:28:40 - |> Chart.WithWidth 1000
2018-12-04 01:28:40 - |> Chart.WithHeight 700
2018-12-04 01:28:40 - let trace =
2018-12-04 01:28:40 -     Scatter(
2018-12-04 01:28:40 -         x = x,
2018-12-04 01:28:40 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 1. i))),
2018-12-04 01:28:40 -         name = "Погрешность 6)"
2018-12-04 01:28:40 -     )
2018-12-04 01:28:40 - [trace]
2018-12-04 01:28:40 - |> Chart.Plot
2018-12-04 01:28:40 - |> Chart.WithWidth 1000
2018-12-04 01:28:40 - |> Chart.WithHeight 700
2018-12-04 01:28:41 - let r = new Random()
2018-12-04 01:28:41 - let x = r.NextDouble() * 10. - 5.
2018-12-04 01:28:41 - let trace =
2018-12-04 01:28:41 -     let delta h x = abs (f' x - df_3 h x)
2018-12-04 01:28:41 -     let hs = [0.00001 .. 0.00001 .. 5.]
2018-12-04 01:28:41 -     Scatter(
2018-12-04 01:28:41 -         x = hs,
2018-12-04 01:28:41 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-04 01:28:41 -         name = "Погрешность 6)"
2018-12-04 01:28:41 -     )
2018-12-04 01:28:41 - [trace]
2018-12-04 01:28:41 - |> Chart.Plot
2018-12-04 01:28:41 - |> Chart.WithWidth 1000
2018-12-04 01:28:41 - |> Chart.WithHeight 700
2018-12-04 01:28:43 - let optimalStep start_h = 
2018-12-04 01:28:43 -     let rec optimalStepInternal h acc = 
2018-12-04 01:28:43 -         match h with
2018-12-04 01:28:43 -         | _ when h > 0. -> optimalStepInternal (h / 2.) ((abs (f' x - df_3 h x), h) :: acc)
2018-12-04 01:28:43 -         | _ -> acc
2018-12-04 01:28:43 -     optimalStepInternal start_h [] 
2018-12-04 01:28:43 -     |> List.minBy fst
2018-12-04 01:28:43 -     |> snd
2018-12-04 01:28:43 - x, optimalStep 5.
2018-12-04 01:28:43 - let a = 0.
2018-12-04 01:28:43 - let b = 1.
2018-12-04 01:28:43 - let f x = 1. / (x * x + 4.)
2018-12-04 01:28:43 - let N = 100 //параметр
2018-12-04 01:28:43 - let h = (b - a) / float N
2018-12-04 01:28:43 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (float k - 1.) * h)) 0.)
2018-12-04 01:28:43 - let left_quadrature = quadrature a
2018-12-04 01:28:43 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-04 01:28:43 - let right_quadrature = quadrature (a + h)
2018-12-04 01:28:43 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 01:28:43 - let xk k = a + k * h
2018-12-04 01:28:43 - let trapezium = h / 2. * (f (xk 0.) + f (xk (float N)) 
2018-12-04 01:28:43 -                     + 2. * ([1 .. N - 1] |> List.fold (fun acc k -> acc + f (xk (float k))) 0.))
2018-12-04 01:28:43 - trapezium
2018-12-04 01:28:43 - let h = (b - a) / (float N) / 2.
2018-12-04 01:28:43 - let xk k = a + k * h
2018-12-04 01:28:43 - let simpson = 
2018-12-04 01:28:43 -     let term n =
2018-12-04 01:28:43 -         match n % 2 = 0 with
2018-12-04 01:28:43 -         | true  -> 2. * f (xk (float n))
2018-12-04 01:28:43 -         | false -> 4. * f (xk (float n))
2018-12-04 01:28:43 -     h / 3. * (f (xk 0.) + f (xk (2. * (float N))) 
2018-12-04 01:28:43 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-04 01:28:43 - simpson
2018-12-04 01:28:43 - let exact = atan (1. / 2.) / 2.
2018-12-04 01:28:43 - exact
2018-12-04 01:28:43 - let factError func = abs (exact - func)
2018-12-04 01:28:43 - let f' x = -2. * x / ((x ** 2. + 4.) ** 2.)
2018-12-04 01:28:43 - let f'' x = (8. * x ** 2.) / ((x ** 2. + 4.) ** 3.) - 2. / ((x ** 2. + 4.) ** 2.)
2018-12-04 01:28:43 - let f'''' x = -(228. * x ** 2.) / ((x ** 2. + 4.) ** 4.) 
2018-12-04 01:28:43 -                 + 24. / ((x ** 2. + 4.) ** 3.) 
2018-12-04 01:28:43 -                 + 384. * x ** 4. / ((x ** 2. + 4.) ** 5.) 
2018-12-04 01:28:43 - let theoryError c d =
2018-12-04 01:28:43 -     let m = 
2018-12-04 01:28:43 -         let func =
2018-12-04 01:28:43 -             match d with
2018-12-04 01:28:43 -             | 0 -> f'
2018-12-04 01:28:43 -             | 1 -> f''
2018-12-04 01:28:43 -             | 3 -> f''''
2018-12-04 01:28:43 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:28:43 -         [a .. 0.000001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:28:43 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:28:43 - let info =
2018-12-04 01:28:43 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:28:43 -     <| factError left_quadrature 
2018-12-04 01:28:43 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:28:43 -     +
2018-12-04 01:28:43 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:28:43 -     <| factError midle_quadrature 
2018-12-04 01:28:43 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:28:43 -     +
2018-12-04 01:28:43 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:28:43 -     <| factError right_quadrature 
2018-12-04 01:28:43 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:28:43 -     +
2018-12-04 01:28:43 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:28:43 -     <| factError trapezium 
2018-12-04 01:28:43 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:28:43 -     +
2018-12-04 01:28:43 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:28:43 -     <| factError simpson 
2018-12-04 01:28:43 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:28:44 - info
2018-12-04 01:31:45 - let info =
2018-12-04 01:31:45 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:31:45 -     <| factError left_quadrature 
2018-12-04 01:31:45 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:31:45 -     +
2018-12-04 01:31:45 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:31:45 -     <| factError midle_quadrature 
2018-12-04 01:31:45 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:31:45 -     +
2018-12-04 01:31:45 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:31:45 -     <| factError right_quadrature 
2018-12-04 01:31:45 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:31:45 -     +
2018-12-04 01:31:45 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:31:45 -     <| factError trapezium 
2018-12-04 01:31:45 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:31:45 -     +
2018-12-04 01:31:45 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:31:45 -     <| factError simpson 
2018-12-04 01:31:45 -     <| theoryError (1. / 2280.) 3)
2018-12-04 01:31:46 - info
2018-12-04 01:32:10 - let theoryError c d =
2018-12-04 01:32:10 -     let m = 
2018-12-04 01:32:10 -         let func =
2018-12-04 01:32:10 -             match d with
2018-12-04 01:32:10 -             | 0 -> f'
2018-12-04 01:32:10 -             | 1 -> f''
2018-12-04 01:32:10 -             | 3 -> f''''
2018-12-04 01:32:10 -             | _ -> failwith "invalid d parameter"
2018-12-04 01:32:10 -         [a .. 0.00001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:32:10 -     c * (b - a) * (((b - a) / float N) ** (float d + 1.)) * m
2018-12-04 01:32:10 - let info =
2018-12-04 01:32:10 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:32:10 -     <| factError left_quadrature 
2018-12-04 01:32:10 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:32:10 -     +
2018-12-04 01:32:10 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:32:10 -     <| factError midle_quadrature 
2018-12-04 01:32:10 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:32:10 -     +
2018-12-04 01:32:10 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:32:10 -     <| factError right_quadrature 
2018-12-04 01:32:10 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:32:10 -     +
2018-12-04 01:32:10 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:32:10 -     <| factError trapezium 
2018-12-04 01:32:10 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:32:10 -     +
2018-12-04 01:32:10 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:32:10 -     <| factError simpson 
2018-12-04 01:32:10 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:32:11 - info
2018-12-04 01:36:24 - f'''' 2
2018-12-04 01:36:24 - This expression was expected to have type
2018-12-04 01:36:24 -     'float'    
2018-12-04 01:36:24 - but here has type
2018-12-04 01:36:24 -     'int'    
2018-12-04 01:36:26 - f'''' 2.
2018-12-04 01:36:43 - f'' 2.
2018-12-04 01:37:51 - 1./24. / ((float N) ** 2.) * (f'' 2.)
2018-12-04 01:38:08 - 1./24. / ((float N) ** 2.) * (f'' 1.)
2018-12-04 01:38:13 - 1./24. / ((float N) ** 2.) * (f'' 0.)
2018-12-04 01:38:34 - abs(1./24. / ((float N) ** 2.) * (f'' 0.))
2018-12-04 01:38:48 - 1./24. / ((float N) ** 2.) * (abs << f'' 0.)
2018-12-04 01:38:48 - The type ''a -> 'b' does not match the type 'float'
2018-12-04 01:38:48 - This expression was expected to have type
2018-12-04 01:38:48 -     ''a -> 'b'    
2018-12-04 01:38:48 - but here has type
2018-12-04 01:38:48 -     'float'    
2018-12-04 01:38:48 - This expression was expected to have type
2018-12-04 01:38:48 -     ''a -> 'b'    
2018-12-04 01:38:48 - but here has type
2018-12-04 01:38:48 -     'float'    
2018-12-04 01:38:48 - The type ''a -> 'b' does not match the type 'float'
2018-12-04 01:39:13 - 1./24. / ((float N) ** 2.) * <| 0. >> abs << f''
2018-12-04 01:39:13 - Unexpected infix operator in expression
2018-12-04 01:39:13 - parse error
2018-12-04 01:39:22 - 1./24. / ((float N) ** 2.) * <| 0. >> abs << f''
2018-12-04 01:39:22 - Unexpected infix operator in expression
2018-12-04 01:39:22 - parse error
2018-12-04 01:39:41 - 1. / 24. / ((float N) ** 2.) * <| abs << f'' << 0.
2018-12-04 01:39:41 - Unexpected infix operator in expression
2018-12-04 01:39:41 - parse error
2018-12-04 01:39:54 - 1. / 24. / ((float N) ** 2.) * (abs << f'' << 0.)
2018-12-04 01:39:54 - The type ''a -> float' does not match the type 'float'
2018-12-04 01:39:54 - This expression was expected to have type
2018-12-04 01:39:54 -     ''a -> float'    
2018-12-04 01:39:54 - but here has type
2018-12-04 01:39:54 -     'float'    
2018-12-04 01:39:54 - The type ''a -> float' does not match the type 'float'
2018-12-04 01:40:05 - 1. / 24. / ((float N) ** 2.) * (abs (f'' 0.))
2018-12-04 01:40:17 - 1. / 24. / ((float N) ** 2.) * (abs (f'' 0.5))
2018-12-04 01:41:05 - b
2018-12-04 01:41:56 - let theoryError c d =
2018-12-04 01:41:56 -     let m = 
2018-12-04 01:41:56 -         let func =
2018-12-04 01:41:56 -             match d with
2018-12-04 01:41:56 -             | 0 -> f'
2018-12-04 01:41:56 -             | 1 -> f''
2018-12-04 01:41:56 -             | 3 -> f''''
2018-12-04 01:41:56 -             | _ -> failwith "invalid parameter d"
2018-12-04 01:41:56 -         [a .. 0.00001 .. b] |> List.maxBy (abs << func)
2018-12-04 01:41:56 -     c * (b - a) * (((b - a) / (float N)) ** (float d + 1.)) * m
2018-12-04 01:41:58 - let info =
2018-12-04 01:41:58 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:41:58 -     <| factError left_quadrature 
2018-12-04 01:41:58 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:41:58 -     +
2018-12-04 01:41:58 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:41:58 -     <| factError midle_quadrature 
2018-12-04 01:41:58 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:41:58 -     +
2018-12-04 01:41:58 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:41:58 -     <| factError right_quadrature 
2018-12-04 01:41:58 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:41:58 -     +
2018-12-04 01:41:58 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:41:58 -     <| factError trapezium 
2018-12-04 01:41:58 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:41:58 -     +
2018-12-04 01:41:58 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:41:58 -     <| factError simpson 
2018-12-04 01:41:58 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:41:58 - info
2018-12-04 01:42:57 - [a .. 0.00001 .. b] |> List.maxBy (abs << f')
2018-12-04 01:43:43 - let theoryError c d =
2018-12-04 01:43:43 -     let m = 
2018-12-04 01:43:43 -         let func =
2018-12-04 01:43:43 -             match d with
2018-12-04 01:43:43 -             | 0 -> f'
2018-12-04 01:43:43 -             | 1 -> f''
2018-12-04 01:43:43 -             | 3 -> f''''
2018-12-04 01:43:43 -             | _ -> failwith "invalid parameter d"
2018-12-04 01:43:43 -         [a .. 0.00001 .. b] |> List.map (abs << func) |> List.max
2018-12-04 01:43:43 -     c * (b - a) * (((b - a) / (float N)) ** (float d + 1.)) * m
2018-12-04 01:43:44 - let info =
2018-12-04 01:43:44 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:43:44 -     <| factError left_quadrature 
2018-12-04 01:43:44 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:43:44 -     +
2018-12-04 01:43:44 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:43:44 -     <| factError midle_quadrature 
2018-12-04 01:43:44 -     <| theoryError (1. / 24.) 1)
2018-12-04 01:43:44 -     +
2018-12-04 01:43:44 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 01:43:44 -     <| factError right_quadrature 
2018-12-04 01:43:44 -     <| theoryError (1. / 2.) 0)
2018-12-04 01:43:44 -     +
2018-12-04 01:43:44 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 01:43:44 -     <| factError trapezium 
2018-12-04 01:43:44 -     <| theoryError (1. / 12.) 1)
2018-12-04 01:43:44 -     +
2018-12-04 01:43:44 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 01:43:44 -     <| factError simpson 
2018-12-04 01:43:44 -     <| theoryError (1. / 2880.) 3)
2018-12-04 01:43:45 - info
2018-12-04 15:24:20 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-04 15:24:20 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-04 15:24:20 - For help type #help;;
2018-12-04 15:24:20 - > val it :
2018-12-04 15:24:20 -   ResizeArray<System.Type *
2018-12-04 15:24:20 -               (obj ->
2018-12-04 15:24:20 -                  seq<string *
2018-12-04 15:24:20 -                      string> *
2018-12-04 15:24:20 -                  string)>
2018-12-04 15:24:20 - = seq []
2018-12-04 15:24:20 - --> Added '/home/max/IfSharp.v3.0.1' to library include path
2018-12-04 15:24:20 - --> Referenced '/home/max/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-04 15:24:20 - --> Referenced '/home/max/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-04 15:24:21 - Reporting 0 opened comms
2018-12-04 15:24:44 - #load "XPlot.Plotly.Paket.fsx"
2018-12-04 15:24:44 - #load "XPlot.Plotly.fsx"
2018-12-04 15:24:44 - open XPlot.Plotly
2018-12-04 15:24:44 - open System
2018-12-04 15:24:47 - let f x = sin x / (1. + x ** 2.)
2018-12-04 15:24:47 - let df_1 h x = (f (x + h) - f x) / h
2018-12-04 15:24:47 - let df_2 h x = (f x - f (x - h)) / h
2018-12-04 15:24:47 - let df_3 h x = (f (x + h) - f (x - h)) / (2. * h)
2018-12-04 15:24:47 - let df_4 h x = (-3. * f x + 4. * f (x + h) - f (x + 2. * h)) / (2. * h)
2018-12-04 15:24:47 - let df_5 h x = (-3. * f x - 4. * f (x - h) + f (x - 2. * h)) / (2. * h)
2018-12-04 15:24:47 - let df_6 h x = (f (x + h) - 2. * f x + f (x - h)) / (h ** 2.)
2018-12-04 15:24:47 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-12-04 15:24:47 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-12-04 15:24:47 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-12-04 15:24:47 - let x = [-5. .. 0.01 .. 5.]
2018-12-04 15:24:47 - let trace1 =
2018-12-04 15:24:47 -     Scatter(
2018-12-04 15:24:47 -         x = x,
2018-12-04 15:24:47 -         y = (x |> List.map f),
2018-12-04 15:24:47 -         name = "f"
2018-12-04 15:24:47 -     )   
2018-12-04 15:24:47 - let trace2 =
2018-12-04 15:24:47 -     Scatter(
2018-12-04 15:24:47 -         x = x,
2018-12-04 15:24:47 -         y = (x |> List.map f'),
2018-12-04 15:24:47 -         name = "f'"
2018-12-04 15:24:47 -     )
2018-12-04 15:24:47 - let trace3 =
2018-12-04 15:24:47 -     Scatter(
2018-12-04 15:24:47 -         x = x,
2018-12-04 15:24:47 -         y = (x |> List.map f''),
2018-12-04 15:24:47 -         name = "f''"
2018-12-04 15:24:47 -     )
2018-12-04 15:24:47 - [trace1; trace2; trace3]
2018-12-04 15:24:47 - |> Chart.Plot
2018-12-04 15:24:47 - |> Chart.WithWidth 900
2018-12-04 15:24:47 - |> Chart.WithHeight 700
2018-12-04 15:24:48 - let x = [-5. .. 0.01 .. 5.]
2018-12-04 15:24:48 - let trace1 =
2018-12-04 15:24:48 -     Scatter(
2018-12-04 15:24:48 -         x = x,
2018-12-04 15:24:48 -         y = (x |> List.map (fun i -> abs (f' i - df_1 1. i))),
2018-12-04 15:24:48 -         name = "Погрешность 1)"
2018-12-04 15:24:48 -     )   
2018-12-04 15:24:48 - let trace2 =
2018-12-04 15:24:48 -     Scatter(
2018-12-04 15:24:48 -         x = x,
2018-12-04 15:24:48 -         y = (x |> List.map (fun i -> abs (f' i - df_2 1. i))),
2018-12-04 15:24:48 -         name = "Погрешность 2)"
2018-12-04 15:24:48 -     )
2018-12-04 15:24:48 - let trace3 =
2018-12-04 15:24:48 -     Scatter(
2018-12-04 15:24:48 -         x = x,
2018-12-04 15:24:48 -         y = (x |> List.map (fun i -> abs (f' i - df_3 1. i))),
2018-12-04 15:24:48 -         name = "Погрешность 3)"
2018-12-04 15:24:48 -     )
2018-12-04 15:24:48 - let trace4 =
2018-12-04 15:24:48 -     Scatter(
2018-12-04 15:24:48 -         x = x,
2018-12-04 15:24:48 -         y = (x |> List.map (fun i -> abs (f' i - df_4 1. i))),
2018-12-04 15:24:48 -         name = "Погрешность 4)"
2018-12-04 15:24:48 -     )
2018-12-04 15:24:48 - let trace5 =
2018-12-04 15:24:48 -     Scatter(
2018-12-04 15:24:48 -         x = x,
2018-12-04 15:24:48 -         y = (x |> List.map (fun i -> abs (f' i - df_5 1. i))),
2018-12-04 15:24:48 -         name = "Погрешность 5)"
2018-12-04 15:24:48 -     )
2018-12-04 15:24:48 - [trace1; trace2; trace3; trace4; trace5]
2018-12-04 15:24:48 - |> Chart.Plot
2018-12-04 15:24:48 - |> Chart.WithWidth 1000
2018-12-04 15:24:48 - |> Chart.WithHeight 700
2018-12-04 15:24:48 - let trace =
2018-12-04 15:24:48 -     Scatter(
2018-12-04 15:24:48 -         x = x,
2018-12-04 15:24:48 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 1. i))),
2018-12-04 15:24:48 -         name = "Погрешность 6)"
2018-12-04 15:24:48 -     )
2018-12-04 15:24:48 - [trace]
2018-12-04 15:24:48 - |> Chart.Plot
2018-12-04 15:24:48 - |> Chart.WithWidth 1000
2018-12-04 15:24:48 - |> Chart.WithHeight 700
2018-12-04 15:24:48 - let r = new Random()
2018-12-04 15:24:48 - let x = r.NextDouble() * 10. - 5.
2018-12-04 15:24:48 - let trace =
2018-12-04 15:24:48 -     let delta h x = abs (f' x - df_3 h x)
2018-12-04 15:24:48 -     let hs = [0.00001 .. 0.00001 .. 5.]
2018-12-04 15:24:48 -     Scatter(
2018-12-04 15:24:48 -         x = hs,
2018-12-04 15:24:48 -         y = (hs |> List.map (fun i -> delta i x)),
2018-12-04 15:24:48 -         name = "Погрешность 6)"
2018-12-04 15:24:48 -     )
2018-12-04 15:24:48 - [trace]
2018-12-04 15:24:48 - |> Chart.Plot
2018-12-04 15:24:48 - |> Chart.WithWidth 1000
2018-12-04 15:24:48 - |> Chart.WithHeight 700
2018-12-04 15:24:50 - let optimalStep start_h = 
2018-12-04 15:24:50 -     let rec optimalStepInternal h acc = 
2018-12-04 15:24:50 -         match h with
2018-12-04 15:24:50 -         | _ when h > 0. -> optimalStepInternal (h / 2.) ((abs (f' x - df_3 h x), h) :: acc)
2018-12-04 15:24:50 -         | _ -> acc
2018-12-04 15:24:50 -     optimalStepInternal start_h [] 
2018-12-04 15:24:50 -     |> List.minBy fst
2018-12-04 15:24:50 -     |> snd
2018-12-04 15:24:50 - x, optimalStep 5.
2018-12-04 15:24:50 - let a = 0.
2018-12-04 15:24:50 - let b = 1.
2018-12-04 15:24:50 - let f x = 1. / (x * x + 4.)
2018-12-04 15:24:50 - let N = 100 //параметр
2018-12-04 15:24:50 - let h = (b - a) / float N
2018-12-04 15:24:50 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (float k - 1.) * h)) 0.)
2018-12-04 15:24:50 - let left_quadrature = quadrature a
2018-12-04 15:24:50 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-04 15:24:50 - let right_quadrature = quadrature (a + h)
2018-12-04 15:24:50 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 15:24:50 - let xk k = a + k * h
2018-12-04 15:24:50 - let trapezium = h / 2. * (f (xk 0.) + f (xk (float N)) 
2018-12-04 15:24:50 -                     + 2. * ([1 .. N - 1] |> List.fold (fun acc k -> acc + f (xk (float k))) 0.))
2018-12-04 15:24:50 - trapezium
2018-12-04 15:24:50 - let h = (b - a) / (float N) / 2.
2018-12-04 15:24:50 - let xk k = a + k * h
2018-12-04 15:24:50 - let simpson = 
2018-12-04 15:24:50 -     let term n =
2018-12-04 15:24:50 -         match n % 2 = 0 with
2018-12-04 15:24:50 -         | true  -> 2. * f (xk (float n))
2018-12-04 15:24:50 -         | false -> 4. * f (xk (float n))
2018-12-04 15:24:50 -     h / 3. * (f (xk 0.) + f (xk (2. * (float N))) 
2018-12-04 15:24:50 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-04 15:24:50 - simpson
2018-12-04 15:24:50 - let exact = atan (1. / 2.) / 2.
2018-12-04 15:24:50 - exact
2018-12-04 15:24:50 - let factError func = abs (exact - func)
2018-12-04 15:24:50 - let f' x = -2. * x / ((x ** 2. + 4.) ** 2.)
2018-12-04 15:24:50 - let f'' x = (8. * x ** 2.) / ((x ** 2. + 4.) ** 3.) - 2. / ((x ** 2. + 4.) ** 2.)
2018-12-04 15:24:50 - let f'''' x = -(228. * x ** 2.) / ((x ** 2. + 4.) ** 4.) 
2018-12-04 15:24:50 -                 + 24. / ((x ** 2. + 4.) ** 3.) 
2018-12-04 15:24:50 -                 + 384. * x ** 4. / ((x ** 2. + 4.) ** 5.) 
2018-12-04 15:24:50 - let theoryError c d =
2018-12-04 15:24:50 -     let m = 
2018-12-04 15:24:50 -         let func =
2018-12-04 15:24:50 -             match d with
2018-12-04 15:24:50 -             | 0 -> f'
2018-12-04 15:24:50 -             | 1 -> f''
2018-12-04 15:24:50 -             | 3 -> f''''
2018-12-04 15:24:50 -             | _ -> failwith "invalid parameter d"
2018-12-04 15:24:50 -         [a .. 0.00001 .. b] |> List.map (abs << func) |> List.max
2018-12-04 15:24:50 -     c * (b - a) * (((b - a) / (float N)) ** (float d + 1.)) * m
2018-12-04 15:24:50 - let info =
2018-12-04 15:24:50 -     (sprintf "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 15:24:50 -     <| factError left_quadrature 
2018-12-04 15:24:50 -     <| theoryError (1. / 2.) 0)
2018-12-04 15:24:50 -     +
2018-12-04 15:24:50 -     (sprintf "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 15:24:50 -     <| factError midle_quadrature 
2018-12-04 15:24:50 -     <| theoryError (1. / 24.) 1)
2018-12-04 15:24:50 -     +
2018-12-04 15:24:50 -     (sprintf "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 15:24:50 -     <| factError right_quadrature 
2018-12-04 15:24:50 -     <| theoryError (1. / 2.) 0)
2018-12-04 15:24:50 -     +
2018-12-04 15:24:50 -     (sprintf "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 15:24:50 -     <| factError trapezium 
2018-12-04 15:24:50 -     <| theoryError (1. / 12.) 1)
2018-12-04 15:24:50 -     +
2018-12-04 15:24:50 -     (sprintf "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 15:24:50 -     <| factError simpson 
2018-12-04 15:24:50 -     <| theoryError (1. / 2880.) 3)
2018-12-04 15:24:50 - info
2018-12-04 15:26:30 - let info =
2018-12-04 15:26:30 -     printfn "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 15:26:30 -     <| factError left_quadrature 
2018-12-04 15:26:30 -     <| theoryError (1. / 2.) 0
2018-12-04 15:26:30 -     printfn "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 15:26:30 -     <| factError midle_quadrature 
2018-12-04 15:26:30 -     <| theoryError (1. / 24.) 1
2018-12-04 15:26:30 -     printfn "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 15:26:30 -     <| factError right_quadrature 
2018-12-04 15:26:30 -     <| theoryError (1. / 2.) 0
2018-12-04 15:26:30 -     printfn "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 15:26:30 -     <| factError trapezium 
2018-12-04 15:26:30 -     <| theoryError (1. / 12.) 1
2018-12-04 15:26:30 -     printfn "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 15:26:30 -     <| factError simpson 
2018-12-04 15:26:30 -     <| theoryError (1. / 2880.) 3
2018-12-04 15:28:06 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-04 15:28:06 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-04 15:28:06 - For help type #help;;
2018-12-04 15:28:06 - > val it :
2018-12-04 15:28:06 -   ResizeArray<System.Type *
2018-12-04 15:28:06 -               (obj ->
2018-12-04 15:28:06 -                  seq<string *
2018-12-04 15:28:06 -                      string> *
2018-12-04 15:28:06 -                  string)>
2018-12-04 15:28:06 - = seq []
2018-12-04 15:28:06 - --> Added '/home/max/IfSharp.v3.0.1' to library include path
2018-12-04 15:28:06 - --> Referenced '/home/max/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-04 15:28:06 - --> Referenced '/home/max/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-04 15:28:07 - Reporting 0 opened comms
2018-12-04 16:39:40 - let f x = sin x / (1. + x ** 2.)
2018-12-04 16:39:44 - let df_1 h x = (f (x + h) - f x) / h
2018-12-04 16:39:44 - let df_2 h x = (f x - f (x - h)) / h
2018-12-04 16:39:44 - let df_3 h x = (f (x + h) - f (x - h)) / (2. * h)
2018-12-04 16:39:44 - let df_4 h x = (-3. * f x + 4. * f (x + h) - f (x + 2. * h)) / (2. * h)
2018-12-04 16:39:44 - let df_5 h x = (-3. * f x - 4. * f (x - h) + f (x - 2. * h)) / (2. * h)
2018-12-04 16:39:44 - let df_6 h x = (f (x + h) - 2. * f x + f (x - h)) / (h ** 2.)
2018-12-04 16:39:44 - let f' x = (cos x + x ** 2. * cos x - 2. * x * sin x) / ((1. + x ** 2.) ** 2.)
2018-12-04 16:39:44 - let f'' x = - (4. * x * cos x) / ((1. + x ** 2.) ** 2.) + 
2018-12-04 16:39:44 -             ((-3. + 4. * x ** 2. - x ** 4.) * sin x) / ((1. + x ** 2.) ** 3.)
2018-12-04 16:39:47 - let x = [-5. .. 0.01 .. 5.]
2018-12-04 16:39:47 - let trace1 =
2018-12-04 16:39:47 -     Scatter(
2018-12-04 16:39:47 -         x = x,
2018-12-04 16:39:47 -         y = (x |> List.map f),
2018-12-04 16:39:47 -         name = "f"
2018-12-04 16:39:47 -     )   
2018-12-04 16:39:47 - let trace2 =
2018-12-04 16:39:47 -     Scatter(
2018-12-04 16:39:47 -         x = x,
2018-12-04 16:39:47 -         y = (x |> List.map f'),
2018-12-04 16:39:47 -         name = "f'"
2018-12-04 16:39:47 -     )
2018-12-04 16:39:47 - let trace3 =
2018-12-04 16:39:47 -     Scatter(
2018-12-04 16:39:47 -         x = x,
2018-12-04 16:39:47 -         y = (x |> List.map f''),
2018-12-04 16:39:47 -         name = "f''"
2018-12-04 16:39:47 -     )
2018-12-04 16:39:47 - [trace1; trace2; trace3]
2018-12-04 16:39:47 - |> Chart.Plot
2018-12-04 16:39:47 - |> Chart.WithWidth 900
2018-12-04 16:39:47 - |> Chart.WithHeight 700
2018-12-04 16:39:54 - let x = [-5. .. 0.01 .. 5.]
2018-12-04 16:39:54 - let trace1 =
2018-12-04 16:39:54 -     Scatter(
2018-12-04 16:39:54 -         x = x,
2018-12-04 16:39:54 -         y = (x |> List.map (fun i -> abs (f' i - df_1 1. i))),
2018-12-04 16:39:54 -         name = "Погрешность 1)"
2018-12-04 16:39:54 -     )   
2018-12-04 16:39:54 - let trace2 =
2018-12-04 16:39:54 -     Scatter(
2018-12-04 16:39:54 -         x = x,
2018-12-04 16:39:54 -         y = (x |> List.map (fun i -> abs (f' i - df_2 1. i))),
2018-12-04 16:39:54 -         name = "Погрешность 2)"
2018-12-04 16:39:54 -     )
2018-12-04 16:39:54 - let trace3 =
2018-12-04 16:39:54 -     Scatter(
2018-12-04 16:39:54 -         x = x,
2018-12-04 16:39:54 -         y = (x |> List.map (fun i -> abs (f' i - df_3 1. i))),
2018-12-04 16:39:54 -         name = "Погрешность 3)"
2018-12-04 16:39:54 -     )
2018-12-04 16:39:54 - let trace4 =
2018-12-04 16:39:54 -     Scatter(
2018-12-04 16:39:54 -         x = x,
2018-12-04 16:39:54 -         y = (x |> List.map (fun i -> abs (f' i - df_4 1. i))),
2018-12-04 16:39:54 -         name = "Погрешность 4)"
2018-12-04 16:39:54 -     )
2018-12-04 16:39:54 - let trace5 =
2018-12-04 16:39:54 -     Scatter(
2018-12-04 16:39:54 -         x = x,
2018-12-04 16:39:54 -         y = (x |> List.map (fun i -> abs (f' i - df_5 1. i))),
2018-12-04 16:39:54 -         name = "Погрешность 5)"
2018-12-04 16:39:54 -     )
2018-12-04 16:39:54 - [trace1; trace2; trace3; trace4; trace5]
2018-12-04 16:39:54 - |> Chart.Plot
2018-12-04 16:39:54 - |> Chart.WithWidth 1000
2018-12-04 16:39:54 - |> Chart.WithHeight 700
2018-12-04 16:40:01 - let trace =
2018-12-04 16:40:01 -     Scatter(
2018-12-04 16:40:01 -         x = x,
2018-12-04 16:40:01 -         y = (x |> List.map (fun i -> abs (f'' i - df_6 1. i))),
2018-12-04 16:40:01 -         name = "Погрешность 6)"
2018-12-04 16:40:01 -     )
2018-12-04 16:40:01 - [trace]
2018-12-04 16:40:01 - |> Chart.Plot
2018-12-04 16:40:01 - |> Chart.WithWidth 1000
2018-12-04 16:40:01 - |> Chart.WithHeight 700
2018-12-04 16:41:08 - let x = 2.1
2018-12-04 16:41:08 - abs (f' x - df_1 1. x)
2018-12-04 16:41:19 - abs (f' x - df_2 1. x)
2018-12-04 16:41:38 - abs (f' x - df_3 1. x)
2018-12-04 16:42:05 - let x = 2.1
2018-12-04 16:42:05 - abs (f' x - df_1 1. x)
2018-12-04 16:42:05 - abs (f' x - df_2 1. x)
2018-12-04 16:42:05 - abs (f' x - df_3 1. x)
2018-12-04 16:42:05 - abs (f' x - df_4 1. x)
2018-12-04 16:42:06 - abs (f' x - df_5 1. x)
2018-12-04 16:42:06 - abs (f'' x - df_6 1. x)
2018-12-04 16:44:50 - let optimalStep start_h = 
2018-12-04 16:44:50 -     let rec optimalStepInternal h acc = 
2018-12-04 16:44:50 -         match h with
2018-12-04 16:44:50 -         | _ when h > 0. -> optimalStepInternal (h / 2.) ((abs (f' x - df_3 h x), h) :: acc)
2018-12-04 16:44:50 -         | _ -> acc
2018-12-04 16:44:50 -     optimalStepInternal start_h [] 
2018-12-04 16:44:50 -     |> List.minBy fst
2018-12-04 16:44:50 -     |> snd
2018-12-04 16:44:50 - x, optimalStep 5.
2018-12-04 16:47:45 - let a = 0.
2018-12-04 16:47:45 - let b = 1.
2018-12-04 16:47:45 - let f x = 1. / (x * x + 4.)
2018-12-04 16:47:45 - let N = 100 //параметр
2018-12-04 16:47:46 - let h = (b - a) / float N
2018-12-04 16:47:46 - let quadrature delta = h * ([1 .. N] |> List.fold (fun acc k -> acc + f (delta + (float k - 1.) * h)) 0.)
2018-12-04 16:47:46 - let left_quadrature = quadrature a
2018-12-04 16:47:46 - let midle_quadrature = quadrature (a + h / 2.)
2018-12-04 16:47:46 - let right_quadrature = quadrature (a + h)
2018-12-04 16:47:46 - left_quadrature, midle_quadrature, right_quadrature
2018-12-04 16:47:46 - let xk k = a + k * h
2018-12-04 16:47:46 - let trapezium = h / 2. * (f (xk 0.) + f (xk (float N)) 
2018-12-04 16:47:46 -                     + 2. * ([1 .. N - 1] |> List.fold (fun acc k -> acc + f (xk (float k))) 0.))
2018-12-04 16:47:46 - trapezium
2018-12-04 16:47:47 - let h = (b - a) / (float N) / 2.
2018-12-04 16:47:47 - let xk k = a + k * h
2018-12-04 16:47:47 - let simpson = 
2018-12-04 16:47:47 -     let term n =
2018-12-04 16:47:47 -         match n % 2 = 0 with
2018-12-04 16:47:47 -         | true  -> 2. * f (xk (float n))
2018-12-04 16:47:47 -         | false -> 4. * f (xk (float n))
2018-12-04 16:47:47 -     h / 3. * (f (xk 0.) + f (xk (2. * (float N))) 
2018-12-04 16:47:47 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-04 16:47:47 - simpson
2018-12-04 16:47:48 - let exact = atan (1. / 2.) / 2.
2018-12-04 16:47:48 - exact
2018-12-04 16:47:48 - let factError func = abs (exact - func)
2018-12-04 16:47:49 - let f' x = -2. * x / ((x ** 2. + 4.) ** 2.)
2018-12-04 16:47:49 - let f'' x = (8. * x ** 2.) / ((x ** 2. + 4.) ** 3.) - 2. / ((x ** 2. + 4.) ** 2.)
2018-12-04 16:47:49 - let f'''' x = -(228. * x ** 2.) / ((x ** 2. + 4.) ** 4.) 
2018-12-04 16:47:49 -                 + 24. / ((x ** 2. + 4.) ** 3.) 
2018-12-04 16:47:49 -                 + 384. * x ** 4. / ((x ** 2. + 4.) ** 5.) 
2018-12-04 16:47:49 - let theoryError c d =
2018-12-04 16:47:49 -     let m = 
2018-12-04 16:47:49 -         let func =
2018-12-04 16:47:49 -             match d with
2018-12-04 16:47:49 -             | 0 -> f'
2018-12-04 16:47:49 -             | 1 -> f''
2018-12-04 16:47:49 -             | 3 -> f''''
2018-12-04 16:47:49 -             | _ -> failwith "invalid parameter d"
2018-12-04 16:47:49 -         [a .. 0.00001 .. b] |> List.map (abs << func) |> List.max
2018-12-04 16:47:49 -     c * (b - a) * (((b - a) / (float N)) ** (float d + 1.)) * m
2018-12-04 16:47:50 - let info =
2018-12-04 16:47:50 -     printfn "left quadrature --- fact error: %e theory error: %e" 
2018-12-04 16:47:50 -     <| factError left_quadrature 
2018-12-04 16:47:50 -     <| theoryError (1. / 2.) 0
2018-12-04 16:47:50 -     printfn "\nmidle quadrature --- fact error: %e theory error: %e" 
2018-12-04 16:47:50 -     <| factError midle_quadrature 
2018-12-04 16:47:50 -     <| theoryError (1. / 24.) 1
2018-12-04 16:47:50 -     printfn "\nright quadrature --- fact error: %e theory error: %e" 
2018-12-04 16:47:50 -     <| factError right_quadrature 
2018-12-04 16:47:50 -     <| theoryError (1. / 2.) 0
2018-12-04 16:47:50 -     printfn "\ntrapezium --- fact error: %e theory error: %e" 
2018-12-04 16:47:50 -     <| factError trapezium 
2018-12-04 16:47:50 -     <| theoryError (1. / 12.) 1
2018-12-04 16:47:50 -     printfn "\nsimpson --- fact error: %e theory error: %e" 
2018-12-04 16:47:50 -     <| factError simpson 
2018-12-04 16:47:50 -     <| theoryError (1. / 2880.) 3
2018-12-10 20:31:42 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-10 20:31:42 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-10 20:31:42 - For help type #help;;
2018-12-10 20:31:42 - > val it :
2018-12-10 20:31:42 -   ResizeArray<System.Type *
2018-12-10 20:31:42 -               (obj ->
2018-12-10 20:31:42 -                  seq<string *
2018-12-10 20:31:42 -                      string> *
2018-12-10 20:31:42 -                  string)>
2018-12-10 20:31:42 - = seq []
2018-12-10 20:31:42 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-10 20:31:42 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-10 20:31:42 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-10 20:31:43 - Reporting 0 opened comms
2018-12-10 20:51:57 - let xs = [|-0.906179845938664, -0.538469310105683, 0, 0.538469310105683, 0.906179845938664|]
2018-12-10 20:51:57 - let As = [|0.236926885056189, 0.478628670499366, 0.568888888888889, 0.478628670499366, 0.236926885056189|]
2018-12-10 20:53:42 - let a = 0.
2018-12-10 20:53:42 - let b = 1.
2018-12-10 20:53:42 - let N = 2
2018-12-10 20:53:42 - let h = (b - a) / 2. / float N
2018-12-10 20:53:42 - let n = 5
2018-12-10 20:55:09 - let ts = [|-0.906179845938664, -0.538469310105683, 0, 0.538469310105683, 0.906179845938664|]
2018-12-10 20:55:09 - let As = [|0.236926885056189, 0.478628670499366, 0.568888888888889, 0.478628670499366, 0.236926885056189|]
2018-12-10 20:55:09 - let a = 0.
2018-12-10 20:55:09 - let b = 1.
2018-12-10 20:55:09 - let N = 2
2018-12-10 20:55:09 - let h = (b - a) / 2. / float N
2018-12-10 20:55:09 - let n = 5
2018-12-10 20:57:04 - let f x = 1 / (x ** 2 + 4)
2018-12-10 20:57:04 - The type 'int' does not support the operator 'Pow'
2018-12-10 20:57:10 - let f x = 1. / (x ** 2. + 4.)
2018-12-10 20:58:27 - let gauss = (b - a) / 2. * (List.fold2 (fun acc t A -> acc + A * f ((b - a) / 2. * t + (b + a) / 2.)) 0. ts As)
2018-12-10 20:58:28 - This expression was expected to have type
2018-12-10 20:58:28 -     'float list'    
2018-12-10 20:58:28 - but here has type
2018-12-10 20:58:28 -     '(float * float * int * float * float) []'    
2018-12-10 20:58:28 - This expression was expected to have type
2018-12-10 20:58:28 -     'float list'    
2018-12-10 20:58:28 - but here has type
2018-12-10 20:58:28 -     '(float * float * float * float * float) []'    
2018-12-10 20:59:23 - let ts = [|-0.906179845938664; -0.538469310105683; 0.; 0.538469310105683; 0.906179845938664|]
2018-12-10 20:59:23 - let As = [|0.236926885056189; 0.478628670499366; 0.568888888888889; 0.478628670499366; 0.236926885056189|]
2018-12-10 20:59:24 - let a = 0.
2018-12-10 20:59:24 - let b = 1.
2018-12-10 20:59:24 - let N = 2
2018-12-10 20:59:24 - let h = (b - a) / 2. / float N
2018-12-10 20:59:24 - let n = 5
2018-12-10 20:59:24 - let f x = 1. / (x ** 2. + 4.)
2018-12-10 20:59:25 - let gauss = (b - a) / 2. * (List.fold2 (fun acc t A -> acc + A * f ((b - a) / 2. * t + (b + a) / 2.)) 0. ts As)
2018-12-10 20:59:25 - This expression was expected to have type
2018-12-10 20:59:25 -     'float list'    
2018-12-10 20:59:25 - but here has type
2018-12-10 20:59:25 -     'float []'    
2018-12-10 20:59:25 - This expression was expected to have type
2018-12-10 20:59:25 -     'float list'    
2018-12-10 20:59:25 - but here has type
2018-12-10 20:59:25 -     'float []'    
2018-12-10 20:59:40 - let ts = [-0.906179845938664; -0.538469310105683; 0.; 0.538469310105683; 0.906179845938664]
2018-12-10 20:59:40 - let As = [0.236926885056189; 0.478628670499366; 0.568888888888889; 0.478628670499366; 0.236926885056189]
2018-12-10 20:59:40 - let a = 0.
2018-12-10 20:59:40 - let b = 1.
2018-12-10 20:59:40 - let N = 2
2018-12-10 20:59:40 - let h = (b - a) / 2. / float N
2018-12-10 20:59:40 - let n = 5
2018-12-10 20:59:41 - let f x = 1. / (x ** 2. + 4.)
2018-12-10 20:59:41 - let gauss = (b - a) / 2. * (List.fold2 (fun acc t A -> acc + A * f ((b - a) / 2. * t + (b + a) / 2.)) 0. ts As)
2018-12-10 21:00:25 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-10 21:00:25 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-10 21:00:25 - For help type #help;;
2018-12-10 21:00:25 - > val it :
2018-12-10 21:00:25 -   ResizeArray<System.Type *
2018-12-10 21:00:25 -               (obj ->
2018-12-10 21:00:25 -                  seq<string *
2018-12-10 21:00:25 -                      string> *
2018-12-10 21:00:25 -                  string)>
2018-12-10 21:00:25 - = seq []
2018-12-10 21:00:25 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-10 21:00:25 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-10 21:00:25 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-10 21:00:26 - Reporting 0 opened comms
2018-12-10 21:01:43 - let exact = atan (1. / 2.) / 2.
2018-12-10 21:02:00 - abs (exact - gauss)
2018-12-10 21:03:05 - let xk k = a + k * h
2018-12-10 21:03:20 - let simpson = 
2018-12-10 21:03:20 -     let term n =
2018-12-10 21:03:20 -         match n % 2 = 0 with
2018-12-10 21:03:20 -         | true  -> 2. * f (xk (float n))
2018-12-10 21:03:20 -         | false -> 4. * f (xk (float n))
2018-12-10 21:03:20 -     h / 3. * (f (xk 0.) + f (xk (2. * (float N))) 
2018-12-10 21:03:20 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-10 21:03:46 - abs (exact - simpson)
2018-12-10 21:16:13 - let f(x) = exp(x)*sqrt(1. - x)
2018-12-10 21:16:13 - let p(x) = sqrt(1. - x)
2018-12-10 21:16:13 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-10 21:17:22 - let f(x) = exp(x)*sqrt(1. - x)
2018-12-10 21:17:22 - let p(x) = sqrt(1. - x)
2018-12-10 21:17:22 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-10 21:17:22 - let x = [|0.; 0.5; 1.|]
2018-12-10 21:17:27 - let f(x) = exp(x)*sqrt(1. - x)
2018-12-10 21:17:27 - let p(x) = sqrt(1. - x)
2018-12-10 21:17:27 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-10 21:17:27 - let x = [|0.; 0.5; 1.|]
2018-12-10 21:33:52 - let f(x) = exp(x)*sqrt(1. - x)
2018-12-10 21:33:52 - let p(x) = sqrt(1. - x)
2018-12-10 21:33:52 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-10 21:33:52 - let xs = [|0.; 0.5; 1.|]
2018-12-10 21:34:05 - let f x = exp(x)*sqrt(1. - x)
2018-12-10 21:34:05 - let p x = sqrt(1. - x)
2018-12-10 21:34:05 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-10 21:34:05 - let xs = [|0.; 0.5; 1.|]
2018-12-10 21:34:21 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-10 21:34:21 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-10 21:34:21 - For help type #help;;
2018-12-10 21:34:21 - > val it :
2018-12-10 21:34:21 -   ResizeArray<System.Type *
2018-12-10 21:34:21 -               (obj ->
2018-12-10 21:34:21 -                  seq<string *
2018-12-10 21:34:21 -                      string> *
2018-12-10 21:34:21 -                  string)>
2018-12-10 21:34:21 - = seq []
2018-12-10 21:34:21 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-10 21:34:21 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-10 21:34:21 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-10 21:34:23 - Reporting 0 opened comms
2018-12-10 21:35:54 - let l k x = 
2018-12-10 21:35:54 -     points |> List.where (fun i -> i <> k) |> List.fold (fun acc i -> (x - i) / (k - i) * acc) 1.
2018-12-10 21:35:54 - The value or constructor 'points' is not defined. Maybe you want one of the following:
2018-12-10 21:35:54 -    printf
2018-12-10 21:35:54 -    Printf
2018-12-10 21:36:00 - let l k x = 
2018-12-10 21:36:00 -     xs |> List.where (fun i -> i <> k) |> List.fold (fun acc i -> (x - i) / (k - i) * acc) 1.
2018-12-10 21:36:00 - Type mismatch. Expecting a
2018-12-10 21:36:00 -     'float [] -> float list'    
2018-12-10 21:36:00 - but given a
2018-12-10 21:36:00 -     'float list -> float list'    
2018-12-10 21:36:00 - The type 'float []' does not match the type 'float list'
2018-12-10 21:36:00 - Type mismatch. Expecting a
2018-12-10 21:36:00 -     'float [] -> float list'    
2018-12-10 21:36:00 - but given a
2018-12-10 21:36:00 -     'float list -> float list'    
2018-12-10 21:36:00 - The type 'float []' does not match the type 'float list'
2018-12-10 21:36:20 - let f x = exp(x)*sqrt(1. - x)
2018-12-10 21:36:20 - let p x = sqrt(1. - x)
2018-12-10 21:36:20 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-10 21:36:20 - let xs = [0.; 0.5; 1.]
2018-12-10 21:36:21 - let l k x = 
2018-12-10 21:36:21 -     xs |> List.where (fun i -> i <> k) |> List.fold (fun acc i -> (x - i) / (k - i) * acc) 1.
2018-12-10 21:53:38 - let As = [0.171429; 4. / 3.; 0.0380952]
2018-12-10 21:55:02 - let f x = exp(x)*sqrt(1. - x)
2018-12-10 21:55:02 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-10 21:55:02 - let xs = [0.; 0.5; 1.]
2018-12-10 21:55:03 - let As = [0.171429; 4. / 3.; 0.0380952]
2018-12-10 21:55:54 - let interpol = List.fold2 (fun acc A x -> acc + A * f x) 0. As xs
2018-12-10 21:56:15 - abs (realAnswer - interpol)
2018-12-10 22:22:00 - let xs = [0.30152; 1.1694; 5.9444]
2018-12-10 22:35:05 - let xs = [0.099194; 0.45013; 0.83529]
2018-12-10 22:42:58 - let As = [0.233281; 0.307603; 0.125783]
2018-12-10 22:43:34 - let As = [0.233281; 0.307603; 0.125783]
2018-12-10 22:43:53 - let greatAST = List.fold2 (fun acc A x -> acc + A * f x) 0. As xs
2018-12-10 22:44:14 - abs (realAnswer - greatAST)
2018-12-11 06:03:56 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 06:03:56 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 06:03:56 - For help type #help;;
2018-12-11 06:03:56 - > val it :
2018-12-11 06:03:56 -   ResizeArray<System.Type *
2018-12-11 06:03:56 -               (obj ->
2018-12-11 06:03:56 -                  seq<string *
2018-12-11 06:03:56 -                      string> *
2018-12-11 06:03:56 -                  string)>
2018-12-11 06:03:56 - = seq []
2018-12-11 06:03:56 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 06:03:56 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 06:03:56 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 06:03:58 - Reporting 0 opened comms
2018-12-11 06:11:37 - let f(x)   = exp(x) - 6.*x - 3.
2018-12-11 06:11:37 - let f'(x)  = exp(x) - 6.
2018-12-11 06:11:37 - let f''(x) = exp(x)
2018-12-11 06:12:37 - Reporting 0 opened comms
2018-12-11 06:12:46 - shutdown request
2018-12-11 06:12:46 - shutdown request
2018-12-11 06:12:57 - #load "XPlot.Plotly.Paket.fsx"
2018-12-11 06:12:57 - #load "XPlot.Plotly.fsx"
2018-12-11 06:12:57 - open XPlot.Plotly
2018-12-11 06:12:57 - open System
2018-12-11 06:14:39 - let x = [-10. .. 0.01 .. 10.]
2018-12-11 06:14:39 - let trace1 =
2018-12-11 06:14:39 -     let y = x |> List.map f
2018-12-11 06:14:39 -     Scatter(
2018-12-11 06:14:39 -         x = x,
2018-12-11 06:14:39 -         y = y,
2018-12-11 06:14:39 -         name = "Исходная функция"
2018-12-11 06:14:39 -     )        
2018-12-11 06:14:39 - [trace1]
2018-12-11 06:14:39 - |> Chart.Plot
2018-12-11 06:14:39 - |> Chart.WithWidth 1000
2018-12-11 06:14:39 - |> Chart.WithHeight 700
2018-12-11 06:15:04 - let x = [-10. .. 0.01 .. 5.]
2018-12-11 06:15:04 - let trace1 =
2018-12-11 06:15:04 -     let y = x |> List.map f
2018-12-11 06:15:04 -     Scatter(
2018-12-11 06:15:04 -         x = x,
2018-12-11 06:15:04 -         y = y,
2018-12-11 06:15:04 -         name = "Исходная функция"
2018-12-11 06:15:04 -     )        
2018-12-11 06:15:04 - [trace1]
2018-12-11 06:15:04 - |> Chart.Plot
2018-12-11 06:15:04 - |> Chart.WithWidth 1000
2018-12-11 06:15:04 - |> Chart.WithHeight 700
2018-12-11 06:15:14 - let x = [-4. .. 0.01 .. 5.]
2018-12-11 06:15:14 - let trace1 =
2018-12-11 06:15:14 -     let y = x |> List.map f
2018-12-11 06:15:14 -     Scatter(
2018-12-11 06:15:14 -         x = x,
2018-12-11 06:15:14 -         y = y,
2018-12-11 06:15:14 -         name = "Исходная функция"
2018-12-11 06:15:14 -     )        
2018-12-11 06:15:14 - [trace1]
2018-12-11 06:15:14 - |> Chart.Plot
2018-12-11 06:15:14 - |> Chart.WithWidth 1000
2018-12-11 06:15:14 - |> Chart.WithHeight 700
2018-12-11 06:15:26 - let x = [-2. .. 0.01 .. 4.]
2018-12-11 06:15:26 - let trace1 =
2018-12-11 06:15:26 -     let y = x |> List.map f
2018-12-11 06:15:26 -     Scatter(
2018-12-11 06:15:26 -         x = x,
2018-12-11 06:15:26 -         y = y,
2018-12-11 06:15:26 -         name = "Исходная функция"
2018-12-11 06:15:26 -     )        
2018-12-11 06:15:26 - [trace1]
2018-12-11 06:15:26 - |> Chart.Plot
2018-12-11 06:15:26 - |> Chart.WithWidth 1000
2018-12-11 06:15:26 - |> Chart.WithHeight 700
2018-12-11 06:15:59 - let x = [-1. .. 0.01 .. 4.]
2018-12-11 06:15:59 - let trace1 =
2018-12-11 06:15:59 -     let y = x |> List.map f
2018-12-11 06:15:59 -     Scatter(
2018-12-11 06:15:59 -         x = x,
2018-12-11 06:15:59 -         y = y,
2018-12-11 06:15:59 -         name = "Исходная функция"
2018-12-11 06:15:59 -     )        
2018-12-11 06:15:59 - [trace1]
2018-12-11 06:15:59 - |> Chart.Plot
2018-12-11 06:15:59 - |> Chart.WithWidth 1000
2018-12-11 06:15:59 - |> Chart.WithHeight 700
2018-12-11 06:16:06 - let x = [-1. .. 0.01 .. 3.5]
2018-12-11 06:16:06 - let trace1 =
2018-12-11 06:16:06 -     let y = x |> List.map f
2018-12-11 06:16:06 -     Scatter(
2018-12-11 06:16:06 -         x = x,
2018-12-11 06:16:06 -         y = y,
2018-12-11 06:16:06 -         name = "Исходная функция"
2018-12-11 06:16:06 -     )        
2018-12-11 06:16:06 - [trace1]
2018-12-11 06:16:06 - |> Chart.Plot
2018-12-11 06:16:06 - |> Chart.WithWidth 1000
2018-12-11 06:16:06 - |> Chart.WithHeight 700
2018-12-11 06:39:20 - let newton1 a b e =
2018-12-11 06:39:20 -     let x0 = 
2018-12-11 06:39:20 -         match f(a) * f''(a) > 0. with
2018-12-11 06:39:20 -         |true -> a
2018-12-11 06:39:20 -         |false -> b
2018-12-11 06:39:20 -     let rec newton1Internal pred cur =
2018-12-11 06:39:20 -         match abs (cur - pred) < e with
2018-12-11 06:39:20 -         |true -> cur
2018-12-11 06:39:20 -         |false -> newton1Internal cur (cur - f cur / f' cur)
2018-12-11 06:39:20 -     newton1Internal 0. x0
2018-12-11 06:39:41 - newton1 -0.5 0. 0.0001
2018-12-11 06:40:06 - newton1 -0.5 0. 0.00001
2018-12-11 06:41:25 - let newton1 a b e =
2018-12-11 06:41:25 -     let x0 = 
2018-12-11 06:41:25 -         match f(a) * f''(a) > 0. with
2018-12-11 06:41:25 -         |true -> a
2018-12-11 06:41:25 -         |false -> b
2018-12-11 06:41:25 -     let rec newton1Internal pred cur i =
2018-12-11 06:41:25 -         match abs (cur - pred) < e with
2018-12-11 06:41:25 -         |true -> (cur, i)
2018-12-11 06:41:25 -         |false -> newton1Internal cur (cur - f cur / f' cur) i++
2018-12-11 06:41:25 -     newton1Internal 0. x0 0
2018-12-11 06:41:25 - Possible incorrect indentation: this token is offside of context started at position (9:19). Try indenting this token further or using standard formatting conventions.
2018-12-11 06:41:25 - Possible incorrect indentation: this token is offside of context started at position (9:19). Try indenting this token further or using standard formatting conventions.
2018-12-11 06:41:25 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-12-11 06:41:39 - let newton1 a b e =
2018-12-11 06:41:39 -     let x0 = 
2018-12-11 06:41:39 -         match f(a) * f''(a) > 0. with
2018-12-11 06:41:39 -         |true -> a
2018-12-11 06:41:39 -         |false -> b
2018-12-11 06:41:39 -     let rec newton1Internal pred cur i =
2018-12-11 06:41:39 -         match abs (cur - pred) < e with
2018-12-11 06:41:39 -         |true -> (cur, i)
2018-12-11 06:41:39 -         |false -> newton1Internal cur (cur - f cur / f' cur) (i++)
2018-12-11 06:41:39 -     newton1Internal 0. x0 0
2018-12-11 06:41:39 - Unexpected symbol ')' in expression
2018-12-11 06:41:55 - let newton1 a b e =
2018-12-11 06:41:55 -     let x0 = 
2018-12-11 06:41:55 -         match f(a) * f''(a) > 0. with
2018-12-11 06:41:55 -         |true -> a
2018-12-11 06:41:55 -         |false -> b
2018-12-11 06:41:55 -     let rec newton1Internal pred cur i =
2018-12-11 06:41:55 -         match abs (cur - pred) < e with
2018-12-11 06:41:55 -         |true -> (cur, i)
2018-12-11 06:41:55 -         |false -> newton1Internal cur (cur - f cur / f' cur) ++i
2018-12-11 06:41:55 -     newton1Internal 0. x0 0
2018-12-11 06:41:55 - Expecting a type supporting the operator '++' but given a function type. You may be missing an argument to a function.
2018-12-11 06:42:12 - let newton1 a b e =
2018-12-11 06:42:12 -     let x0 = 
2018-12-11 06:42:12 -         match f(a) * f''(a) > 0. with
2018-12-11 06:42:12 -         |true -> a
2018-12-11 06:42:12 -         |false -> b
2018-12-11 06:42:12 -     let rec newton1Internal pred cur i =
2018-12-11 06:42:12 -         match abs (cur - pred) < e with
2018-12-11 06:42:12 -         |true -> (cur, i)
2018-12-11 06:42:12 -         |false -> newton1Internal cur (cur - f cur / f' cur) (i + 1)
2018-12-11 06:42:12 -     newton1Internal 0. x0 0
2018-12-11 06:42:13 - newton1 -0.5 0. 0.00001
2018-12-11 06:42:18 - newton1 -0.5 0. 0.00000001
2018-12-11 06:42:23 - newton1 -0.5 0. 0.00000000001
2018-12-11 06:47:57 - let newton a b e meth =
2018-12-11 06:47:57 -     let x0 = 
2018-12-11 06:47:57 -         match f(a) * f''(a) > 0. with
2018-12-11 06:47:57 -         |true -> a
2018-12-11 06:47:57 -         |false -> b
2018-12-11 06:47:57 -     let rec newtonInternal pred cur i =
2018-12-11 06:47:57 -         match abs (cur - pred) < e with
2018-12-11 06:47:57 -         |true -> (cur, i)
2018-12-11 06:47:57 -         |false -> newtonInternal cur meth (i + 1)
2018-12-11 06:47:57 -     newtonInternal 0. x0 0
2018-12-11 06:50:21 - let newton1 a b e = (fun pred cur -> cur - f cur / f' cur) |> newton a b e 
2018-12-11 06:50:21 - Type mismatch. Expecting a
2018-12-11 06:50:21 -     '(obj -> float -> float) -> 'a'    
2018-12-11 06:50:21 - but given a
2018-12-11 06:50:21 -     'float -> float * int'    
2018-12-11 06:50:21 - The type 'obj -> float -> float' does not match the type 'float'
2018-12-11 06:50:21 - Type mismatch. Expecting a
2018-12-11 06:50:21 -     '(obj -> float -> float) -> 'a'    
2018-12-11 06:50:21 - but given a
2018-12-11 06:50:21 -     'float -> float * int'    
2018-12-11 06:50:21 - The type 'obj -> float -> float' does not match the type 'float'
2018-12-11 06:50:32 - let newton1 a b e = (fun _ cur -> cur - f cur / f' cur) |> newton a b e 
2018-12-11 06:50:32 - Type mismatch. Expecting a
2018-12-11 06:50:32 -     '(obj -> float -> float) -> 'a'    
2018-12-11 06:50:32 - but given a
2018-12-11 06:50:32 -     'float -> float * int'    
2018-12-11 06:50:32 - The type 'obj -> float -> float' does not match the type 'float'
2018-12-11 06:50:32 - Type mismatch. Expecting a
2018-12-11 06:50:32 -     '(obj -> float -> float) -> 'a'    
2018-12-11 06:50:32 - but given a
2018-12-11 06:50:32 -     'float -> float * int'    
2018-12-11 06:50:32 - The type 'obj -> float -> float' does not match the type 'float'
2018-12-11 06:51:16 - let newton a b e meth =
2018-12-11 06:51:16 -     let x0 = 
2018-12-11 06:51:16 -         match f(a) * f''(a) > 0. with
2018-12-11 06:51:16 -         |true -> a
2018-12-11 06:51:16 -         |false -> b
2018-12-11 06:51:16 -     let rec newtonInternal pred cur i =
2018-12-11 06:51:16 -         match abs (cur - pred) < e with
2018-12-11 06:51:16 -         |true -> (cur, i)
2018-12-11 06:51:16 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-11 06:51:16 -     newtonInternal 0. x0 0
2018-12-11 06:51:16 - let newton1 a b e = (fun _ cur -> cur - f cur / f' cur) |> newton a b e 
2018-12-11 06:51:18 - newton1 -0.5 0. 0.00000000001
2018-12-11 06:54:26 - let newton1 a b e = (fun pred _ -> pred - f pred / f' pred) |> newton a b e 
2018-12-11 06:54:27 - newton1 -0.5 0. 0.00000000001
2018-12-11 06:57:46 - let newton2 a b e = (fun pred cur -> cur - f cur * (cur - pred) / (f cur - f pred)) |> newton a b e 
2018-12-11 06:58:01 - newton2 -0.5 0. 0.00000000001
2018-12-11 07:11:09 - let newton meth a b e =
2018-12-11 07:11:09 -     let x0 = 
2018-12-11 07:11:09 -         match f(a) * f''(a) > 0. with
2018-12-11 07:11:09 -         |true -> a
2018-12-11 07:11:09 -         |false -> b
2018-12-11 07:11:09 -     let rec newtonInternal pred cur i =
2018-12-11 07:11:09 -         match abs (cur - pred) < e with
2018-12-11 07:11:09 -         |true -> (cur, i)
2018-12-11 07:11:09 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-11 07:11:09 -     newtonInternal 0. x0 0
2018-12-11 07:11:09 - let newton1 = (fun pred _ -> pred - f pred / f' pred) |> newton
2018-12-11 07:11:09 - newton1 -0.5 0. 0.00000000001
2018-12-11 07:11:20 - let newton2 = (fun pred cur -> cur - f cur * (cur - pred) / (f cur - f pred)) |> newton
2018-12-11 07:11:20 - newton2 -0.5 0. 0.00000000001
2018-12-11 07:11:48 - let newton3 a b e =
2018-12-11 07:11:48 -     let func = 
2018-12-11 07:11:48 -         match f b > 0. with 
2018-12-11 07:11:48 -         | true -> (fun _ cur -> cur - f cur * (b - cur) / (f b - f cur))
2018-12-11 07:11:48 -         | false -> (fun _ cur -> cur - f cur * (cur - a) / (f cur - f a))
2018-12-11 07:11:48 -     newton func a b e
2018-12-11 07:11:56 - newton3 -0.5 0. 0.00000000001
2018-12-11 07:12:29 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 07:12:29 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 07:12:29 - For help type #help;;
2018-12-11 07:12:29 - > val it :
2018-12-11 07:12:29 -   ResizeArray<System.Type *
2018-12-11 07:12:29 -               (obj ->
2018-12-11 07:12:29 -                  seq<string *
2018-12-11 07:12:29 -                      string> *
2018-12-11 07:12:29 -                  string)>
2018-12-11 07:12:29 - = seq []
2018-12-11 07:12:29 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 07:12:29 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 07:12:29 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 07:13:16 - let f(x)   = exp(x) - 6.*x - 3.
2018-12-11 07:13:16 - let f'(x)  = exp(x) - 6.
2018-12-11 07:13:16 - let f''(x) = exp(x)
2018-12-11 07:13:17 - #load "XPlot.Plotly.Paket.fsx"
2018-12-11 07:13:17 - #load "XPlot.Plotly.fsx"
2018-12-11 07:13:17 - open XPlot.Plotly
2018-12-11 07:13:17 - open System
2018-12-11 07:13:20 - let x = [-1. .. 0.01 .. 3.5]
2018-12-11 07:13:20 - let trace1 =
2018-12-11 07:13:20 -     let y = x |> List.map f
2018-12-11 07:13:20 -     Scatter(
2018-12-11 07:13:20 -         x = x,
2018-12-11 07:13:20 -         y = y,
2018-12-11 07:13:20 -         name = "Исходная функция"
2018-12-11 07:13:20 -     )        
2018-12-11 07:13:20 - [trace1]
2018-12-11 07:13:20 - |> Chart.Plot
2018-12-11 07:13:20 - |> Chart.WithWidth 1000
2018-12-11 07:13:20 - |> Chart.WithHeight 700
2018-12-11 07:13:21 - let newton meth a b e =
2018-12-11 07:13:21 -     let x0 = 
2018-12-11 07:13:21 -         match f(a) * f''(a) > 0. with
2018-12-11 07:13:21 -         |true -> a
2018-12-11 07:13:21 -         |false -> b
2018-12-11 07:13:21 -     let rec newtonInternal pred cur i =
2018-12-11 07:13:21 -         match abs (cur - pred) < e with
2018-12-11 07:13:21 -         |true -> (cur, i)
2018-12-11 07:13:21 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-11 07:13:21 -     newtonInternal 0. x0 0
2018-12-11 07:13:22 - let newton1 = (fun pred _ -> pred - f pred / f' pred) |> newton
2018-12-11 07:13:23 - newton1 -0.5 0. 0.00000000001
2018-12-11 07:13:24 - let newton2 = (fun pred cur -> cur - f cur * (cur - pred) / (f cur - f pred)) |> newton
2018-12-11 07:13:25 - newton2 -0.5 0. 0.00000000001
2018-12-11 07:16:53 - let newton3 a b e =
2018-12-11 07:16:53 -     let func = 
2018-12-11 07:16:53 -         match f b > 0. with 
2018-12-11 07:16:53 -         | true -> (fun _ cur -> cur - f cur * (b - cur) / (f b - f cur))
2018-12-11 07:16:53 -         | false -> (fun _ cur -> cur - f cur * (cur - a) / (f cur - f a))
2018-12-11 07:16:53 -     newton func a b e
2018-12-11 07:16:57 - newton3 -0.5 0. 0.001
2018-12-11 07:18:08 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 07:18:08 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 07:18:08 - For help type #help;;
2018-12-11 07:18:08 - > val it :
2018-12-11 07:18:08 -   ResizeArray<System.Type *
2018-12-11 07:18:08 -               (obj ->
2018-12-11 07:18:08 -                  seq<string *
2018-12-11 07:18:08 -                      string> *
2018-12-11 07:18:08 -                  string)>
2018-12-11 07:18:08 - = seq []
2018-12-11 07:18:08 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 07:18:08 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 07:18:08 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 07:30:58 - let newton3 a b e =
2018-12-11 07:30:58 -     let func = 
2018-12-11 07:30:58 -         match f b > 0. with 
2018-12-11 07:30:58 -         | true -> (fun _ cur -> cur - f cur * (b + 2. * e - cur) / (f (b + 2. * e) - f cur))
2018-12-11 07:30:58 -         | false -> (fun _ cur -> cur - f cur * (cur - (a - 2. * e)) / (f cur - f (a - 2. * e)))
2018-12-11 07:30:58 -     newton func a b e
2018-12-11 07:30:58 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-12-11 07:30:58 -    a
2018-12-11 07:30:58 -    b
2018-12-11 07:30:58 -    e
2018-12-11 07:30:58 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-12-11 07:30:58 -    a
2018-12-11 07:30:58 -    b
2018-12-11 07:30:58 -    e
2018-12-11 07:30:58 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-12-11 07:30:58 -    a
2018-12-11 07:30:58 -    b
2018-12-11 07:30:58 -    e
2018-12-11 07:30:58 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-12-11 07:30:58 -    a
2018-12-11 07:30:58 -    b
2018-12-11 07:30:58 -    e
2018-12-11 07:30:58 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-12-11 07:30:58 -    a
2018-12-11 07:30:58 -    b
2018-12-11 07:30:58 -    e
2018-12-11 07:30:58 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-12-11 07:30:58 -    a
2018-12-11 07:30:58 -    b
2018-12-11 07:30:58 -    e
2018-12-11 07:30:58 - The value or constructor 'f' is not defined. Maybe you want one of the following:
2018-12-11 07:30:58 -    a
2018-12-11 07:30:58 -    b
2018-12-11 07:30:58 -    e
2018-12-11 07:30:58 - The value or constructor 'newton' is not defined.
2018-12-11 07:31:03 - let f(x)   = exp(x) - 6.*x - 3.
2018-12-11 07:31:03 - let f'(x)  = exp(x) - 6.
2018-12-11 07:31:03 - let f''(x) = exp(x)
2018-12-11 07:31:04 - #load "XPlot.Plotly.Paket.fsx"
2018-12-11 07:31:04 - #load "XPlot.Plotly.fsx"
2018-12-11 07:31:04 - open XPlot.Plotly
2018-12-11 07:31:04 - open System
2018-12-11 07:31:07 - let x = [-1. .. 0.01 .. 3.5]
2018-12-11 07:31:07 - let trace1 =
2018-12-11 07:31:07 -     let y = x |> List.map f
2018-12-11 07:31:07 -     Scatter(
2018-12-11 07:31:07 -         x = x,
2018-12-11 07:31:07 -         y = y,
2018-12-11 07:31:07 -         name = "Исходная функция"
2018-12-11 07:31:07 -     )        
2018-12-11 07:31:07 - [trace1]
2018-12-11 07:31:07 - |> Chart.Plot
2018-12-11 07:31:07 - |> Chart.WithWidth 1000
2018-12-11 07:31:07 - |> Chart.WithHeight 700
2018-12-11 07:31:07 - let newton meth a b e =
2018-12-11 07:31:07 -     let x0 = 
2018-12-11 07:31:07 -         match f(a) * f''(a) > 0. with
2018-12-11 07:31:07 -         |true -> a
2018-12-11 07:31:07 -         |false -> b
2018-12-11 07:31:07 -     let rec newtonInternal pred cur i =
2018-12-11 07:31:07 -         match abs (cur - pred) < e with
2018-12-11 07:31:07 -         |true -> (cur, i)
2018-12-11 07:31:07 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-11 07:31:07 -     newtonInternal 0. x0 0
2018-12-11 07:31:07 - let newton1 = (fun pred _ -> pred - f pred / f' pred) |> newton
2018-12-11 07:31:07 - newton1 -0.5 0. 0.00000000001
2018-12-11 07:31:09 - let newton2 = (fun pred cur -> cur - f cur * (cur - pred) / (f cur - f pred)) |> newton
2018-12-11 07:31:10 - newton2 -0.5 0. 0.00000000001
2018-12-11 07:31:11 - let newton3 a b e =
2018-12-11 07:31:11 -     let func = 
2018-12-11 07:31:11 -         match f b > 0. with 
2018-12-11 07:31:11 -         | true -> (fun _ cur -> cur - f cur * (b + 2. * e - cur) / (f (b + 2. * e) - f cur))
2018-12-11 07:31:11 -         | false -> (fun _ cur -> cur - f cur * (cur - (a - 2. * e)) / (f cur - f (a - 2. * e)))
2018-12-11 07:31:11 -     newton func a b e
2018-12-11 07:31:12 - newton3 -0.5 0. 0.001
2018-12-11 07:31:22 - newton3 -0.5 0. 0.00000000001
2018-12-11 07:51:09 - let newton3 a b e =
2018-12-11 07:51:09 -     let func = 
2018-12-11 07:51:09 -         match f b > 0. with 
2018-12-11 07:51:09 -         |true -> (fun _ cur -> cur - f cur * (b + 2. * e - cur) / (f (b + 2. * e) - f cur))
2018-12-11 07:51:09 -         |false -> (fun _ cur -> cur - f cur * (cur - (a - 2. * e)) / (f cur - f (a - 2. * e)))
2018-12-11 07:51:09 -     newton func a b e
2018-12-11 07:51:10 - newton3 -0.5 0. 0.00000000001
2018-12-11 07:53:50 - let iter a b e =
2018-12-11 07:53:50 -     let list_f' = [a .. 0.01 .. b] |> List.map f'
2018-12-11 07:53:50 -     let m1 = list_f' |> List.min
2018-12-11 07:53:50 -     let M1 = list_f' |> List.max
2018-12-11 07:53:50 -     let q = 1. - m1 / M1
2018-12-11 07:53:50 -     let fi x = x - f x / M1
2018-12-11 07:53:50 -     let rec iterInternal pred cur i =
2018-12-11 07:53:50 -         match q * abs (cur - pred) / (1. - q) < e with
2018-12-11 07:53:50 -         |true -> (cur, i)
2018-12-11 07:53:50 -         |false -> iterInternal cur (fi cur) (i + 1)
2018-12-11 07:53:50 -     iterInternal 0. a 0
2018-12-11 07:54:03 - iter -0.5 0. 0.00000000001
2018-12-11 07:54:08 - let iter a b e =
2018-12-11 07:54:08 -     let list_f' = [a .. 0.01 .. b] |> List.map f'
2018-12-11 07:54:08 -     let m1 = list_f' |> List.min
2018-12-11 07:54:08 -     let M1 = list_f' |> List.max
2018-12-11 07:54:08 -     let q = 1. - m1 / M1
2018-12-11 07:54:08 -     let fi x = x - f x / M1
2018-12-11 07:54:08 -     let rec iterInternal pred cur i =
2018-12-11 07:54:08 -         match q * abs (cur - pred) / (1. - q) < e with
2018-12-11 07:54:08 -         |true -> (cur, i)
2018-12-11 07:54:08 -         |false -> iterInternal cur (fi cur) (i + 1)
2018-12-11 07:54:08 -     iterInternal 0. b 0
2018-12-11 07:54:09 - iter -0.5 0. 0.00000000001
2018-12-11 08:14:58 - let iter a b e =
2018-12-11 08:14:58 -     let list_f' = [a .. 0.01 .. b] |> List.map f'
2018-12-11 08:14:58 -     let m1 = list_f' |> List.minBy (abs)
2018-12-11 08:14:58 -     let M1 = list_f' |> List.maxBy (abs)
2018-12-11 08:14:58 -     let q = 1. - m1 / M1
2018-12-11 08:14:58 -     let fi x = x - f x / M1
2018-12-11 08:14:58 -     let rec iterInternal pred cur i =
2018-12-11 08:14:58 -         match q * abs (cur - pred) / (1. - q) < e with
2018-12-11 08:14:58 -         |true -> (cur, i)
2018-12-11 08:14:58 -         |false -> iterInternal cur (fi cur) (i + 1)
2018-12-11 08:14:58 -     iterInternal b (fi b) 1
2018-12-11 08:14:59 - iter -0.5 0. 0.00000000001
2018-12-11 08:15:46 - shutdown request
2018-12-11 08:15:46 - shutdown request
2018-12-11 08:15:56 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 08:15:56 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 08:15:56 - For help type #help;;
2018-12-11 08:15:56 - > val it :
2018-12-11 08:15:56 -   ResizeArray<System.Type *
2018-12-11 08:15:56 -               (obj ->
2018-12-11 08:15:56 -                  seq<string *
2018-12-11 08:15:56 -                      string> *
2018-12-11 08:15:56 -                  string)>
2018-12-11 08:15:56 - = seq []
2018-12-11 08:15:56 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 08:15:56 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 08:15:56 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 08:15:57 - Reporting 0 opened comms
2018-12-11 08:16:38 - shutdown request
2018-12-11 08:16:45 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 08:16:45 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 08:16:45 - For help type #help;;
2018-12-11 08:16:45 - > val it :
2018-12-11 08:16:45 -   ResizeArray<System.Type *
2018-12-11 08:16:45 -               (obj ->
2018-12-11 08:16:45 -                  seq<string *
2018-12-11 08:16:45 -                      string> *
2018-12-11 08:16:45 -                  string)>
2018-12-11 08:16:45 - = seq []
2018-12-11 08:16:45 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 08:16:45 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 08:16:45 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 08:16:46 - Reporting 0 opened comms
2018-12-11 09:18:41 - let f x y = (x + y) / (y - x)
2018-12-11 09:19:58 - let f x y = (x + y) / (y - x)
2018-12-11 09:19:58 - let x0 = 0
2018-12-11 09:19:58 - let y0 = 1
2018-12-11 09:20:09 - let f x y = (x + y) / (y - x)
2018-12-11 09:20:09 - let x0 = 0.
2018-12-11 09:20:09 - let y0 = 1.
2018-12-11 09:20:35 - let f x y = (x + y) / (y - x)
2018-12-11 09:20:35 - let x0 = 0.
2018-12-11 09:20:35 - let y0 = 1.
2018-12-11 09:20:35 - let a = x0
2018-12-11 09:20:35 - let b = x0 + 1.
2018-12-11 09:21:10 - let N = 10
2018-12-11 09:21:10 - let h = (b - a) / float N
2018-12-11 09:21:10 - let points = [a .. h .. b]
2018-12-11 09:25:02 - type point = {Точка: float; Значение: float}
2018-12-11 09:36:35 - let euler1 = 
2018-12-11 09:36:35 -     points 
2018-12-11 09:36:35 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:36:35 -                         let res = acc + h * f x acc
2018-12-11 09:36:35 -                         (res, res)) y0
2018-12-11 09:36:35 -     |> fst
2018-12-11 09:36:35 -     |> List.map2 (fun x y -> {x; y}) points
2018-12-11 09:36:35 - The type 'int' does not match the type 'float'
2018-12-11 09:36:35 - This expression was expected to have type
2018-12-11 09:36:35 -     'int'    
2018-12-11 09:36:35 - but here has type
2018-12-11 09:36:35 -     'float'    
2018-12-11 09:36:35 - The type 'int' does not match the type 'float'
2018-12-11 09:36:35 - This expression was expected to have type
2018-12-11 09:36:35 -     'int'    
2018-12-11 09:36:35 - but here has type
2018-12-11 09:36:35 -     'float'    
2018-12-11 09:36:35 - Invalid object, sequence or record expression
2018-12-11 09:36:35 - Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'
2018-12-11 09:36:58 - let euler1 = 
2018-12-11 09:36:58 -     points 
2018-12-11 09:36:58 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:36:58 -                         let res = acc + h * f x acc
2018-12-11 09:36:58 -                         (res, res)) y0
2018-12-11 09:36:58 -     |> fst
2018-12-11 09:36:58 -     |> List.map2 (fun x y -> {x; y}) points
2018-12-11 09:36:58 - The type 'int' does not match the type 'float'
2018-12-11 09:36:58 - This expression was expected to have type
2018-12-11 09:36:58 -     'int'    
2018-12-11 09:36:58 - but here has type
2018-12-11 09:36:58 -     'float'    
2018-12-11 09:36:58 - The type 'int' does not match the type 'float'
2018-12-11 09:36:58 - This expression was expected to have type
2018-12-11 09:36:58 -     'int'    
2018-12-11 09:36:58 - but here has type
2018-12-11 09:36:58 -     'float'    
2018-12-11 09:36:58 - Invalid object, sequence or record expression
2018-12-11 09:36:58 - Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'
2018-12-11 09:39:45 - let euler1 = 
2018-12-11 09:39:45 -     points 
2018-12-11 09:39:45 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:39:45 -                         let res = acc + h * f x acc
2018-12-11 09:39:45 -                         (res, res)) y0
2018-12-11 09:39:45 -     |> fst
2018-12-11 09:39:45 -     |> List.map2 (fun x y -> {Точка = x; Значение = y}) points
2018-12-11 09:39:45 - The type 'int' does not match the type 'float'
2018-12-11 09:39:45 - This expression was expected to have type
2018-12-11 09:39:45 -     'int'    
2018-12-11 09:39:45 - but here has type
2018-12-11 09:39:45 -     'float'    
2018-12-11 09:39:45 - The type 'int' does not match the type 'float'
2018-12-11 09:39:45 - This expression was expected to have type
2018-12-11 09:39:45 -     'int'    
2018-12-11 09:39:45 - but here has type
2018-12-11 09:39:45 -     'float'    
2018-12-11 09:40:09 - let f x y = (x + y) / (y - x)
2018-12-11 09:40:09 - let x0 = 0.
2018-12-11 09:40:09 - let y0 = 1.
2018-12-11 09:40:09 - let a = x0
2018-12-11 09:40:09 - let b = x0 + 1.
2018-12-11 09:40:09 - let N = 10
2018-12-11 09:40:09 - let h = (b - a) / float N
2018-12-11 09:40:09 - let points = [a .. h .. b]
2018-12-11 09:40:10 - type point = {Точка: float; Значение: float}
2018-12-11 09:40:11 - let euler1 = 
2018-12-11 09:40:11 -     points 
2018-12-11 09:40:11 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:40:11 -                         let res = acc + h * f x acc
2018-12-11 09:40:11 -                         (res, res)) y0
2018-12-11 09:40:11 -     |> fst
2018-12-11 09:40:11 -     |> List.map2 (fun x y -> {Точка = x; Значение = y}) points
2018-12-11 09:40:11 - The type 'int' does not match the type 'float'
2018-12-11 09:40:11 - This expression was expected to have type
2018-12-11 09:40:11 -     'int'    
2018-12-11 09:40:11 - but here has type
2018-12-11 09:40:11 -     'float'    
2018-12-11 09:40:11 - The type 'int' does not match the type 'float'
2018-12-11 09:40:11 - This expression was expected to have type
2018-12-11 09:40:11 -     'int'    
2018-12-11 09:40:11 - but here has type
2018-12-11 09:40:11 -     'float'    
2018-12-11 09:40:29 - let euler1 = 
2018-12-11 09:40:29 -     points 
2018-12-11 09:40:29 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:40:29 -                         let res = acc + h * f x acc
2018-12-11 09:40:29 -                         (res, res)) y0
2018-12-11 09:40:29 -     |> snd
2018-12-11 09:40:29 -     |> List.map2 (fun x y -> {Точка = x; Значение = y}) points
2018-12-11 09:40:29 - The type 'int' does not match the type 'float'
2018-12-11 09:40:29 - This expression was expected to have type
2018-12-11 09:40:29 -     'int'    
2018-12-11 09:40:29 - but here has type
2018-12-11 09:40:29 -     'float'    
2018-12-11 09:40:29 - The type 'int' does not match the type 'float'
2018-12-11 09:40:29 - This expression was expected to have type
2018-12-11 09:40:29 -     'int'    
2018-12-11 09:40:29 - but here has type
2018-12-11 09:40:29 -     'float'    
2018-12-11 09:40:29 - Type mismatch. Expecting a
2018-12-11 09:40:29 -     'int -> obj'    
2018-12-11 09:40:29 - but given a
2018-12-11 09:40:29 -     'float list -> point list'    
2018-12-11 09:40:29 - The type 'int' does not match the type 'float list'
2018-12-11 09:40:29 - Type mismatch. Expecting a
2018-12-11 09:40:29 -     'int -> obj'    
2018-12-11 09:40:29 - but given a
2018-12-11 09:40:29 -     'float list -> point list'    
2018-12-11 09:40:29 - The type 'int' does not match the type 'float list'
2018-12-11 09:40:57 - let euler1 = 
2018-12-11 09:40:57 -     points 
2018-12-11 09:40:57 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:40:57 -                         let res = acc + h * f x acc
2018-12-11 09:40:57 -                         (res, res)) y0
2018-12-11 09:40:57 -     |> fst
2018-12-11 09:40:57 -     |> List.map2 (fun x y -> {Точка = x; Значение = y}) points
2018-12-11 09:40:57 - The type 'int' does not match the type 'float'
2018-12-11 09:40:57 - This expression was expected to have type
2018-12-11 09:40:57 -     'int'    
2018-12-11 09:40:57 - but here has type
2018-12-11 09:40:57 -     'float'    
2018-12-11 09:40:57 - The type 'int' does not match the type 'float'
2018-12-11 09:40:57 - This expression was expected to have type
2018-12-11 09:40:57 -     'int'    
2018-12-11 09:40:57 - but here has type
2018-12-11 09:40:57 -     'float'    
2018-12-11 09:41:52 - let f (x : float) (y : float) = (x + y) / (y - x)
2018-12-11 09:41:52 - let x0 = 0.
2018-12-11 09:41:52 - let y0 = 1.
2018-12-11 09:41:52 - let a = x0
2018-12-11 09:41:52 - let b = x0 + 1.
2018-12-11 09:41:52 - let N = 10
2018-12-11 09:41:52 - let h = (b - a) / float N
2018-12-11 09:41:52 - let points = [a .. h .. b]
2018-12-11 09:41:53 - type point = {Точка: float; Значение: float}
2018-12-11 09:41:53 - let euler1 = 
2018-12-11 09:41:53 -     points 
2018-12-11 09:41:53 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:41:53 -                         let res = acc + h * f x acc
2018-12-11 09:41:53 -                         (res, res)) y0
2018-12-11 09:41:53 -     |> fst
2018-12-11 09:41:53 -     |> List.map2 (fun x y -> {Точка = x; Значение = y}) points
2018-12-11 09:42:14 - euler1
2018-12-11 09:42:58 - euler1 |> Util.Table
2018-12-11 09:55:12 - let exact x = sqrt(1. + 2. * x ** 2.) + x
2018-12-11 09:56:00 - type tableRow = {Точка: float; Значение: float; Погрешность: float}
2018-12-11 09:56:31 - let euler1 = 
2018-12-11 09:56:31 -     points 
2018-12-11 09:56:31 -     |> List.mapFold (fun acc x -> 
2018-12-11 09:56:31 -                         let res = acc + h * f x acc
2018-12-11 09:56:31 -                         (res, res)) y0
2018-12-11 09:56:31 -     |> fst
2018-12-11 09:56:31 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) points
2018-12-11 09:56:32 - euler1 |> Util.Table
2018-12-11 10:03:33 - let euler1 = 
2018-12-11 10:03:33 -     points 
2018-12-11 10:03:33 -     |> List.take (points.Length - 1)
2018-12-11 10:03:33 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:03:33 -                         let res = acc + h * f x acc
2018-12-11 10:03:33 -                         (res, res)) y0
2018-12-11 10:03:33 -     |> fst
2018-12-11 10:03:33 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:03:33 -         (points |> List.take (points.Length - 1))
2018-12-11 10:03:33 - euler1 |> Util.Table
2018-12-11 10:05:36 - let euler1 = 
2018-12-11 10:05:36 -     points 
2018-12-11 10:05:36 -     |> List.take (points.Length - 1)
2018-12-11 10:05:36 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:05:36 -                         let res = acc + h * f x acc
2018-12-11 10:05:36 -                         (res, res)) y0
2018-12-11 10:05:36 -     |> fst
2018-12-11 10:05:36 -     |> (::) y0
2018-12-11 10:05:36 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:05:36 -         (points |> List.take (points.Length - 1))
2018-12-11 10:05:36 - Unexpected symbol '::' in expression
2018-12-11 10:05:36 - Unmatched '('
2018-12-11 10:05:45 - let euler1 = 
2018-12-11 10:05:45 -     points 
2018-12-11 10:05:45 -     |> List.take (points.Length - 1)
2018-12-11 10:05:45 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:05:45 -                         let res = acc + h * f x acc
2018-12-11 10:05:45 -                         (res, res)) y0
2018-12-11 10:05:45 -     |> fst
2018-12-11 10:05:45 -     |> ((::) y0)
2018-12-11 10:05:45 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:05:45 -         (points |> List.take (points.Length - 1))
2018-12-11 10:05:45 - Unexpected symbol '::' in expression
2018-12-11 10:05:45 - Unmatched '('
2018-12-11 10:05:51 - let euler1 = 
2018-12-11 10:05:51 -     points 
2018-12-11 10:05:51 -     |> List.take (points.Length - 1)
2018-12-11 10:05:51 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:05:51 -                         let res = acc + h * f x acc
2018-12-11 10:05:51 -                         (res, res)) y0
2018-12-11 10:05:51 -     |> fst
2018-12-11 10:05:51 -     |> ((::) << y0)
2018-12-11 10:05:51 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:05:51 -         (points |> List.take (points.Length - 1))
2018-12-11 10:05:51 - Unexpected symbol '::' in expression
2018-12-11 10:05:51 - Unmatched '('
2018-12-11 10:05:55 - let euler1 = 
2018-12-11 10:05:55 -     points 
2018-12-11 10:05:55 -     |> List.take (points.Length - 1)
2018-12-11 10:05:55 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:05:55 -                         let res = acc + h * f x acc
2018-12-11 10:05:55 -                         (res, res)) y0
2018-12-11 10:05:55 -     |> fst
2018-12-11 10:05:55 -     |> ((::) >> y0)
2018-12-11 10:05:55 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:05:55 -         (points |> List.take (points.Length - 1))
2018-12-11 10:05:55 - Unexpected symbol '::' in expression
2018-12-11 10:05:55 - Unmatched '('
2018-12-11 10:06:11 - let euler1 = 
2018-12-11 10:06:11 -     points 
2018-12-11 10:06:11 -     |> List.take (points.Length - 1)
2018-12-11 10:06:11 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:06:11 -                         let res = acc + h * f x acc
2018-12-11 10:06:11 -                         (res, res)) y0
2018-12-11 10:06:11 -     |> fst
2018-12-11 10:06:11 -     |> ((:) y0)
2018-12-11 10:06:11 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:06:11 -         (points |> List.take (points.Length - 1))
2018-12-11 10:06:11 - Unexpected symbol ':' in expression
2018-12-11 10:06:11 - Unmatched '('
2018-12-11 10:06:29 - let euler1 = 
2018-12-11 10:06:29 -     points 
2018-12-11 10:06:29 -     |> List.take (points.Length - 1)
2018-12-11 10:06:29 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:06:29 -                         let res = acc + h * f x acc
2018-12-11 10:06:29 -                         (res, res)) y0
2018-12-11 10:06:29 -     |> fst
2018-12-11 10:06:29 -     (::) y0
2018-12-11 10:06:29 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:06:29 -         (points |> List.take (points.Length - 1))
2018-12-11 10:06:29 - Unexpected symbol '::' in binding
2018-12-11 10:06:29 - Unmatched '('
2018-12-11 10:06:40 - let euler1 = 
2018-12-11 10:06:40 -     points 
2018-12-11 10:06:40 -     |> List.take (points.Length - 1)
2018-12-11 10:06:40 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:06:40 -                         let res = acc + h * f x acc
2018-12-11 10:06:40 -                         (res, res)) y0
2018-12-11 10:06:40 -     |> fst
2018-12-11 10:06:40 -     |> :: y0
2018-12-11 10:06:40 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:06:40 -         (points |> List.take (points.Length - 1))
2018-12-11 10:06:40 - Unexpected symbol '::' in expression
2018-12-11 10:07:13 - let euler1 = 
2018-12-11 10:07:13 -     points 
2018-12-11 10:07:13 -     |> List.take (points.Length - 1)
2018-12-11 10:07:13 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:07:13 -                         let res = acc + h * f x acc
2018-12-11 10:07:13 -                         (res, res)) y0
2018-12-11 10:07:13 -     |> fst
2018-12-11 10:07:13 -     |> y0 ::
2018-12-11 10:07:13 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:07:13 -         (points |> List.take (points.Length - 1))
2018-12-11 10:07:13 - Unexpected infix operator in expression
2018-12-11 10:07:20 - let euler1 = 
2018-12-11 10:07:20 -     points 
2018-12-11 10:07:20 -     |> List.take (points.Length - 1)
2018-12-11 10:07:20 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:07:20 -                         let res = acc + h * f x acc
2018-12-11 10:07:20 -                         (res, res)) y0
2018-12-11 10:07:20 -     |> fst
2018-12-11 10:07:20 -     |> (y0 ::)
2018-12-11 10:07:20 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:07:20 -         (points |> List.take (points.Length - 1))
2018-12-11 10:07:20 - Unexpected symbol ')' in expression
2018-12-11 10:07:29 - let euler1 = 
2018-12-11 10:07:29 -     points 
2018-12-11 10:07:29 -     |> List.take (points.Length - 1)
2018-12-11 10:07:29 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:07:29 -                         let res = acc + h * f x acc
2018-12-11 10:07:29 -                         (res, res)) y0
2018-12-11 10:07:29 -     |> fst
2018-12-11 10:07:29 -     |> (y0 (::))
2018-12-11 10:07:29 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:07:29 -         (points |> List.take (points.Length - 1))
2018-12-11 10:07:29 - Unexpected symbol '::' in expression
2018-12-11 10:07:29 - Unmatched '('
2018-12-11 10:07:29 - Unmatched '('
2018-12-11 10:07:37 - let euler1 = 
2018-12-11 10:07:37 -     points 
2018-12-11 10:07:37 -     |> List.take (points.Length - 1)
2018-12-11 10:07:37 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:07:37 -                         let res = acc + h * f x acc
2018-12-11 10:07:37 -                         (res, res)) y0
2018-12-11 10:07:37 -     |> fst
2018-12-11 10:07:37 -     |> (::)
2018-12-11 10:07:37 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:07:37 -         (points |> List.take (points.Length - 1))
2018-12-11 10:07:37 - Unexpected symbol '::' in expression
2018-12-11 10:07:37 - Unmatched '('
2018-12-11 10:08:37 - let euler1 = 
2018-12-11 10:08:37 -     points 
2018-12-11 10:08:37 -     |> List.take (points.Length - 1)
2018-12-11 10:08:37 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:08:37 -                         let res = acc + h * f x acc
2018-12-11 10:08:37 -                         (res, res)) y0
2018-12-11 10:08:37 -     |> fst >> (::) y0 
2018-12-11 10:08:37 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:08:37 -         (points |> List.take (points.Length - 1))
2018-12-11 10:08:37 - Unexpected symbol '::' in expression
2018-12-11 10:08:37 - Unmatched '('
2018-12-11 10:08:43 - let euler1 = 
2018-12-11 10:08:43 -     points 
2018-12-11 10:08:43 -     |> List.take (points.Length - 1)
2018-12-11 10:08:43 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:08:43 -                         let res = acc + h * f x acc
2018-12-11 10:08:43 -                         (res, res)) y0
2018-12-11 10:08:43 -     |> fst >> ((::) y0) 
2018-12-11 10:08:43 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:08:43 -         (points |> List.take (points.Length - 1))
2018-12-11 10:08:43 - Unexpected symbol '::' in expression
2018-12-11 10:08:43 - Unmatched '('
2018-12-11 10:08:47 - let euler1 = 
2018-12-11 10:08:47 -     points 
2018-12-11 10:08:47 -     |> List.take (points.Length - 1)
2018-12-11 10:08:47 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:08:47 -                         let res = acc + h * f x acc
2018-12-11 10:08:47 -                         (res, res)) y0
2018-12-11 10:08:47 -     |> fst << ((::) y0) 
2018-12-11 10:08:47 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:08:47 -         (points |> List.take (points.Length - 1))
2018-12-11 10:08:47 - Unexpected symbol '::' in expression
2018-12-11 10:08:47 - Unmatched '('
2018-12-11 10:09:28 - let euler1 = 
2018-12-11 10:09:28 -     y0 :: (points 
2018-12-11 10:09:28 -     |> List.take (points.Length - 1)
2018-12-11 10:09:28 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:09:28 -                         let res = acc + h * f x acc
2018-12-11 10:09:28 -                         (res, res)) y0
2018-12-11 10:09:28 -     |> fst) 
2018-12-11 10:09:28 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:09:28 -         (points |> List.take (points.Length - 1))
2018-12-11 10:09:28 - Expression evaluation failed: The lists had different lengths.
2018-12-11 10:09:28 - list1 is 1 element shorter than list2
2018-12-11 10:09:28 - Parameter name: list1
2018-12-11 10:09:28 - ArgumentExceptionThe lists had different lengths.
2018-12-11 10:09:28 - list1 is 1 element shorter than list2
2018-12-11 10:09:28 - Parameter name: list1
2018-12-11 10:09:28 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:09:28 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:09:28 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:09:28 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:09:28 -   at <StartupCode$FSI_0049>.$FSI_0049.main@ () [0x00069] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:09:28 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 10:09:28 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 10:09:49 - let euler1 = 
2018-12-11 10:09:49 -     y0 :: (points 
2018-12-11 10:09:49 -     |> List.take (points.Length - 1)
2018-12-11 10:09:49 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:09:49 -                         let res = acc + h * f x acc
2018-12-11 10:09:49 -                         (res, res)) y0
2018-12-11 10:09:49 -     |> fst)
2018-12-11 10:09:49 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) points
2018-12-11 10:09:50 - euler1 |> Util.Table
2018-12-11 10:13:43 - let euler2 = 
2018-12-11 10:13:43 -     y0 :: (points 
2018-12-11 10:13:43 -     |> List.take (points.Length - 1)
2018-12-11 10:13:43 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:13:43 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-11 10:13:43 -                         (res, res)) y0
2018-12-11 10:13:43 -     |> fst)
2018-12-11 10:13:43 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) points
2018-12-11 10:13:57 - euler2 |> Util.Table
2018-12-11 10:24:31 - let euler3 = 
2018-12-11 10:24:31 -     let overY x y = y + h * f x y
2018-12-11 10:24:31 -     let rec euler3Internal acc pred cur l = 
2018-12-11 10:24:31 -         match l with
2018-12-11 10:24:31 -         | h :: t -> 
2018-12-11 10:24:31 -             let y = List.last acc
2018-12-11 10:24:31 -             let newAcc = (y + h / 2. * (f pred y + f cur (overY pred y))) :: acc
2018-12-11 10:24:31 -             euler3Internal newAcc cur h t
2018-12-11 10:24:31 -         | [] -> List.rev acc
2018-12-11 10:24:31 -     euler3Internal [] a (a + h) (points |> List.skip 2)
2018-12-11 10:24:31 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) points
2018-12-11 10:24:31 - Expression evaluation failed: The input list was empty.
2018-12-11 10:24:31 - Parameter name: list
2018-12-11 10:24:31 - ArgumentExceptionThe input list was empty.
2018-12-11 10:24:31 - Parameter name: list
2018-12-11 10:24:31 -   at Microsoft.FSharp.Collections.ListModule.Last[T] (Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x0001d] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:24:31 -   at FSI_0056.euler3Internal@3 (Microsoft.FSharp.Collections.FSharpList`1[T] acc, System.Double pred, System.Double cur, Microsoft.FSharp.Collections.FSharpList`1[T] l) [0x0003d] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:24:31 -   at <StartupCode$FSI_0056>.$FSI_0056.main@ () [0x00036] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:24:31 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 10:24:31 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 10:25:26 - let euler2 = 
2018-12-11 10:25:26 -     points 
2018-12-11 10:25:26 -     |> List.take (points.Length - 1)
2018-12-11 10:25:26 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:25:26 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-11 10:25:26 -                         (res, res)) y0
2018-12-11 10:25:26 -     |> fst
2018-12-11 10:25:26 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:25:26 -         (points List.skip 1)
2018-12-11 10:25:26 - This value is not a function and cannot be applied.
2018-12-11 10:25:33 - let euler2 = 
2018-12-11 10:25:33 -     points 
2018-12-11 10:25:33 -     |> List.take (points.Length - 1)
2018-12-11 10:25:33 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:25:33 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-11 10:25:33 -                         (res, res)) y0
2018-12-11 10:25:33 -     |> fst
2018-12-11 10:25:33 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:25:33 -         (points |> List.skip 1)
2018-12-11 10:25:34 - euler2 |> Util.Table
2018-12-11 10:26:40 - let euler1 = 
2018-12-11 10:26:40 -     y0 :: (points 
2018-12-11 10:26:40 -     |> List.take (points.Length - 1)
2018-12-11 10:26:40 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:26:40 -                         let res = acc + h * f x acc
2018-12-11 10:26:40 -                         (res, res)) y0
2018-12-11 10:26:40 -     |> fst)
2018-12-11 10:26:40 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-11 10:26:40 -         (points |> List.skip 1)
2018-12-11 10:26:40 - Expression evaluation failed: The lists had different lengths.
2018-12-11 10:26:40 - list1 is 1 element shorter than list2
2018-12-11 10:26:40 - Parameter name: list1
2018-12-11 10:26:40 - ArgumentExceptionThe lists had different lengths.
2018-12-11 10:26:40 - list1 is 1 element shorter than list2
2018-12-11 10:26:40 - Parameter name: list1
2018-12-11 10:26:40 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:26:40 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:26:40 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:26:40 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:26:40 -   at <StartupCode$FSI_0061>.$FSI_0061.main@ () [0x0005e] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:26:40 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 10:26:40 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 10:26:48 - let euler1 = 
2018-12-11 10:26:48 -     points 
2018-12-11 10:26:48 -     |> List.take (points.Length - 1)
2018-12-11 10:26:48 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:26:48 -                         let res = acc + h * f x acc
2018-12-11 10:26:48 -                         (res, res)) y0
2018-12-11 10:26:48 -     |> fst
2018-12-11 10:26:48 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-11 10:26:48 -         (points |> List.skip 1)
2018-12-11 10:26:49 - euler1 |> Util.Table
2018-12-11 10:26:53 - let euler2 = 
2018-12-11 10:26:53 -     points 
2018-12-11 10:26:53 -     |> List.take (points.Length - 1)
2018-12-11 10:26:53 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:26:53 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-11 10:26:53 -                         (res, res)) y0
2018-12-11 10:26:53 -     |> fst
2018-12-11 10:26:53 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:26:53 -         (points |> List.skip 1)
2018-12-11 10:26:53 - euler2 |> Util.Table
2018-12-11 10:28:03 - let euler3 = 
2018-12-11 10:28:03 -     let overY x y = y + h * f x y
2018-12-11 10:28:03 -     let rec euler3Internal acc pred cur l = 
2018-12-11 10:28:03 -         match l with
2018-12-11 10:28:03 -         | h :: t -> 
2018-12-11 10:28:03 -             let y = List.last acc
2018-12-11 10:28:03 -             let newAcc = (y + h / 2. * (f pred y + f cur (overY pred y))) :: acc
2018-12-11 10:28:03 -             euler3Internal newAcc cur h t
2018-12-11 10:28:03 -         | [] -> List.rev acc
2018-12-11 10:28:03 -     euler3Internal [] a (a + h) (points |> List.skip 2)
2018-12-11 10:28:03 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:28:03 -         (points |> List.skip 1)
2018-12-11 10:28:03 - Expression evaluation failed: The input list was empty.
2018-12-11 10:28:03 - Parameter name: list
2018-12-11 10:28:03 - ArgumentExceptionThe input list was empty.
2018-12-11 10:28:03 - Parameter name: list
2018-12-11 10:28:03 -   at Microsoft.FSharp.Collections.ListModule.Last[T] (Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x0001d] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:28:03 -   at FSI_0068.euler3Internal@3-1 (Microsoft.FSharp.Collections.FSharpList`1[T] acc, System.Double pred, System.Double cur, Microsoft.FSharp.Collections.FSharpList`1[T] l) [0x0003d] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:28:03 -   at <StartupCode$FSI_0068>.$FSI_0068.main@ () [0x0002c] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:28:03 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 10:28:03 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 10:30:43 - let euler3 = 
2018-12-11 10:30:43 -     let overY x y = y + h * f x y
2018-12-11 10:30:43 -     let rec euler3Internal acc pred l = 
2018-12-11 10:30:43 -         match l with
2018-12-11 10:30:43 -         | head :: t -> 
2018-12-11 10:30:43 -             let y = List.last acc
2018-12-11 10:30:43 -             let newAcc = (y + h / 2. * (f pred y + f h (overY pred y))) :: acc
2018-12-11 10:30:43 -             euler3Internal newAcc h t
2018-12-11 10:30:43 -         | [] -> List.rev acc
2018-12-11 10:30:43 -     euler3Internal [] a (points |> List.skip 1)
2018-12-11 10:30:43 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:30:43 -         (points |> List.skip 1)
2018-12-11 10:30:43 - Expression evaluation failed: The input list was empty.
2018-12-11 10:30:43 - Parameter name: list
2018-12-11 10:30:43 - ArgumentExceptionThe input list was empty.
2018-12-11 10:30:43 - Parameter name: list
2018-12-11 10:30:43 -   at Microsoft.FSharp.Collections.ListModule.Last[T] (Microsoft.FSharp.Collections.FSharpList`1[T] list) [0x0001d] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:30:43 -   at FSI_0069.euler3Internal@3-2[0] (Microsoft.FSharp.Collections.FSharpList`1[T] acc, System.Double pred, Microsoft.FSharp.Collections.FSharpList`1[T] l) [0x00030] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:30:43 -   at <StartupCode$FSI_0069>.$FSI_0069.main@ () [0x0001d] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:30:43 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 10:30:43 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 10:31:35 - let euler3 = 
2018-12-11 10:31:35 -     let overY x y = y + h * f x y
2018-12-11 10:31:35 -     let rec euler3Internal acc pred l = 
2018-12-11 10:31:35 -         match l with
2018-12-11 10:31:35 -         | head :: t -> 
2018-12-11 10:31:35 -             let y = List.last acc
2018-12-11 10:31:35 -             let newAcc = (y + h / 2. * (f pred y + f h (overY pred y))) :: acc
2018-12-11 10:31:35 -             euler3Internal newAcc h t
2018-12-11 10:31:35 -         | [] -> List.rev acc
2018-12-11 10:31:35 -     euler3Internal [y0] a (points |> List.skip 1)
2018-12-11 10:31:35 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:31:35 -         (points |> List.skip 1)
2018-12-11 10:31:35 - Expression evaluation failed: The lists had different lengths.
2018-12-11 10:31:35 - list1 is 1 element shorter than list2
2018-12-11 10:31:35 - Parameter name: list1
2018-12-11 10:31:35 - ArgumentExceptionThe lists had different lengths.
2018-12-11 10:31:35 - list1 is 1 element shorter than list2
2018-12-11 10:31:35 - Parameter name: list1
2018-12-11 10:31:35 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:31:35 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:31:35 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:31:35 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 10:31:35 -   at <StartupCode$FSI_0070>.$FSI_0070.main@ () [0x0004e] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:31:35 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 10:31:35 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 10:32:53 - let euler3 = 
2018-12-11 10:32:53 -     let overY x y = y + h * f x y
2018-12-11 10:32:53 -     let rec euler3Internal acc pred l = 
2018-12-11 10:32:53 -         match l with
2018-12-11 10:32:53 -         | head :: t -> 
2018-12-11 10:32:53 -             let y = List.last acc
2018-12-11 10:32:53 -             let newAcc = (y + h / 2. * (f pred y + f h (overY pred y))) :: acc
2018-12-11 10:32:53 -             euler3Internal newAcc h t
2018-12-11 10:32:53 -         | [] -> acc |> List.rev |> List.skip 1
2018-12-11 10:32:53 -     euler3Internal [y0] a (points |> List.skip 1)
2018-12-11 10:32:53 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:32:53 -         (points |> List.skip 1)
2018-12-11 10:33:09 - euler3 |> Util.Table
2018-12-11 10:34:41 - let euler3 = 
2018-12-11 10:34:41 -     let overY x y = y + h * f x y
2018-12-11 10:34:41 -     let rec euler3Internal acc pred l = 
2018-12-11 10:34:41 -         match l with
2018-12-11 10:34:41 -         | head :: t -> 
2018-12-11 10:34:41 -             let y = List.head acc
2018-12-11 10:34:41 -             let newAcc = (y + h / 2. * (f pred y + f h (overY pred y))) :: acc
2018-12-11 10:34:41 -             euler3Internal newAcc h t
2018-12-11 10:34:41 -         | [] -> acc |> List.rev |> List.skip 1
2018-12-11 10:34:41 -     euler3Internal [y0] a (points |> List.skip 1)
2018-12-11 10:34:41 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:34:41 -         (points |> List.skip 1)
2018-12-11 10:34:42 - euler3 |> Util.Table
2018-12-11 10:34:58 - let euler3 = 
2018-12-11 10:34:58 -     let overY x y = y + h * f x y
2018-12-11 10:34:58 -     let rec euler3Internal acc pred l = 
2018-12-11 10:34:58 -         match l with
2018-12-11 10:34:58 -         | head :: t -> 
2018-12-11 10:34:58 -             let y = List.last acc
2018-12-11 10:34:58 -             let newAcc = (y + h / 2. * (f pred y + f h (overY pred y))) :: acc
2018-12-11 10:34:58 -             euler3Internal newAcc h t
2018-12-11 10:34:58 -         | [] -> acc |> List.rev |> List.skip 1
2018-12-11 10:34:58 -     euler3Internal [y0] a (points |> List.skip 1)
2018-12-11 10:34:58 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:34:58 -         (points |> List.skip 1)
2018-12-11 10:34:58 - euler3 |> Util.Table
2018-12-11 10:35:06 - let euler3 = 
2018-12-11 10:35:06 -     let overY x y = y + h * f x y
2018-12-11 10:35:06 -     let rec euler3Internal acc pred l = 
2018-12-11 10:35:06 -         match l with
2018-12-11 10:35:06 -         | head :: t -> 
2018-12-11 10:35:06 -             let y = List.head acc
2018-12-11 10:35:06 -             let newAcc = (y + h / 2. * (f pred y + f h (overY pred y))) :: acc
2018-12-11 10:35:06 -             euler3Internal newAcc h t
2018-12-11 10:35:06 -         | [] -> acc |> List.rev |> List.skip 1
2018-12-11 10:35:06 -     euler3Internal [y0] a (points |> List.skip 1)
2018-12-11 10:35:06 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:35:06 -         (points |> List.skip 1)
2018-12-11 10:35:07 - euler3 |> Util.Table
2018-12-11 10:38:16 - let euler3 = 
2018-12-11 10:38:16 -     let overY x y = y + h * f x y
2018-12-11 10:38:16 -     let rec euler3Internal acc l = 
2018-12-11 10:38:16 -         match l with
2018-12-11 10:38:16 -         | first :: second :: t -> 
2018-12-11 10:38:16 -             let y = List.head acc
2018-12-11 10:38:16 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-11 10:38:16 -             euler3Internal newAcc (second :: t)
2018-12-11 10:38:16 -         | [] -> acc |> List.rev |> List.skip 1
2018-12-11 10:38:16 -     euler3Internal [y0] points
2018-12-11 10:38:16 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:38:16 -         (points |> List.skip 1)
2018-12-11 10:38:16 - Incomplete pattern matches on this expression. For example, the value '[_]' may indicate a case not covered by the pattern(s).
2018-12-11 10:39:22 - let euler3 = 
2018-12-11 10:39:22 -     let overY x y = y + h * f x y
2018-12-11 10:39:22 -     let rec euler3Internal acc l = 
2018-12-11 10:39:22 -         match l with
2018-12-11 10:39:22 -         | first :: second :: t -> 
2018-12-11 10:39:22 -             let y = List.head acc
2018-12-11 10:39:22 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-11 10:39:22 -             euler3Internal newAcc (second :: t)
2018-12-11 10:39:22 -         | [_] -> failwith "bla"
2018-12-11 10:39:22 -         | [] -> acc |> List.rev |> List.skip 1
2018-12-11 10:39:22 -     euler3Internal [y0] points
2018-12-11 10:39:22 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:39:22 -         (points |> List.skip 1)
2018-12-11 10:39:22 - Expression evaluation failed: bla
2018-12-11 10:39:22 - Exceptionbla
2018-12-11 10:39:22 -   at FSI_0084.euler3Internal@3-9 (Microsoft.FSharp.Collections.FSharpList`1[T] acc, Microsoft.FSharp.Collections.FSharpList`1[T] l) [0x00040] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:39:22 -   at <StartupCode$FSI_0084>.$FSI_0084.main@ () [0x00018] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 10:39:22 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 10:39:22 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 10:40:47 - let euler3 = 
2018-12-11 10:40:47 -     let overY x y = y + h * f x y
2018-12-11 10:40:47 -     let rec euler3Internal acc l = 
2018-12-11 10:40:47 -         match l with
2018-12-11 10:40:47 -         | first :: second :: t -> 
2018-12-11 10:40:47 -             let y = List.head acc
2018-12-11 10:40:47 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-11 10:40:47 -             euler3Internal newAcc (second :: t)
2018-12-11 10:40:47 -         |[] |[_] -> acc |> List.rev |> List.skip 1
2018-12-11 10:40:47 -     euler3Internal [y0] points
2018-12-11 10:40:47 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:40:47 -         (points |> List.skip 1)
2018-12-11 10:40:47 - euler3 |> Util.Table
2018-12-11 10:46:47 - let rungekut = 
2018-12-11 10:46:47 -     points 
2018-12-11 10:46:47 -     |> List.take (points.Length - 1)
2018-12-11 10:46:47 -     |> List.mapFold (fun acc x -> 
2018-12-11 10:46:47 -                         let k1 = h * f x acc
2018-12-11 10:46:47 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-11 10:46:47 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-11 10:46:47 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-11 10:46:47 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-11 10:46:47 -                         (res, res)) y0
2018-12-11 10:46:47 -     |> fst
2018-12-11 10:46:47 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 10:46:47 -         (points |> List.skip 1)
2018-12-11 10:47:03 - rungekut |> Util.Table
2018-12-11 10:54:04 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 10:54:04 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 10:54:04 - For help type #help;;
2018-12-11 10:54:04 - > val it :
2018-12-11 10:54:04 -   ResizeArray<System.Type *
2018-12-11 10:54:04 -               (obj ->
2018-12-11 10:54:04 -                  seq<string *
2018-12-11 10:54:04 -                      string> *
2018-12-11 10:54:04 -                  string)>
2018-12-11 10:54:04 - = seq []
2018-12-11 10:54:04 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 10:54:04 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 10:54:04 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 10:54:05 - Reporting 0 opened comms
2018-12-11 12:14:04 - let q x y = h * f x y
2018-12-11 12:17:14 - let firstKPoints k =
2018-12-11 12:17:14 -     points 
2018-12-11 12:17:14 -     |> List.take k
2018-12-11 12:17:14 -     |> List.mapFold (fun acc x -> 
2018-12-11 12:17:14 -                         let k1 = h * f x acc
2018-12-11 12:17:14 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-11 12:17:14 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-11 12:17:14 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-11 12:17:14 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-11 12:17:14 -                         (res, res)) y0
2018-12-11 12:17:14 -     |> fst
2018-12-11 12:17:35 - let fourPoints = firstKPoints 4
2018-12-11 12:26:15 - let firstKPoints k =
2018-12-11 12:26:15 -     y0 :: (points 
2018-12-11 12:26:15 -     |> List.take (k - 1)
2018-12-11 12:26:15 -     |> List.mapFold (fun acc x -> 
2018-12-11 12:26:15 -                         let k1 = h * f x acc
2018-12-11 12:26:15 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-11 12:26:15 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-11 12:26:15 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-11 12:26:15 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-11 12:26:15 -                         (res, res)) y0
2018-12-11 12:26:15 -     |> fst)
2018-12-11 12:27:15 - let finiteDifferencesTable = 
2018-12-11 12:27:15 -     let rec computeCells y acc = 
2018-12-11 12:27:15 -         let computeCol (prevCol : float list) =
2018-12-11 12:27:15 -             let rec computeColInternal x acc =
2018-12-11 12:27:15 -                 match x with
2018-12-11 12:27:15 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 12:27:15 -                 | _ -> acc
2018-12-11 12:27:15 -             computeColInternal y [] 
2018-12-11 12:27:15 -         match y with
2018-12-11 12:27:15 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 12:27:15 -         |_ -> List.rev acc
2018-12-11 12:27:15 -     computeCells (points.Length - 1) [(firstKPoints 4)]
2018-12-11 12:27:15 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 12:27:15 - Parameter name: n
2018-12-11 12:27:15 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 12:27:15 - Parameter name: n
2018-12-11 12:27:15 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 12:27:15 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 12:27:15 -   at FSI_0095.computeColInternal@4 (Microsoft.FSharp.Collections.FSharpList`1[T] prevCol, System.Int32 x, Microsoft.FSharp.Collections.FSharpList`1[T] acc) [0x0000e] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:15 -   at FSI_0095.computeCol@3 (System.Int32 y, Microsoft.FSharp.Collections.FSharpList`1[T] prevCol) [0x00015] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:15 -   at FSI_0095.computeCells@2 (System.Int32 y, Microsoft.FSharp.Collections.FSharpList`1[T] acc) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:15 -   at <StartupCode$FSI_0095>.$FSI_0095.main@ () [0x00024] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:15 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 12:27:15 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 12:27:31 - let finiteDifferencesTable = 
2018-12-11 12:27:31 -     let rec computeCells y acc = 
2018-12-11 12:27:31 -         let computeCol (prevCol : float list) =
2018-12-11 12:27:31 -             let rec computeColInternal x acc =
2018-12-11 12:27:31 -                 match x with
2018-12-11 12:27:31 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 12:27:31 -                 | _ -> acc
2018-12-11 12:27:31 -             computeColInternal y [] 
2018-12-11 12:27:31 -         match y with
2018-12-11 12:27:31 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 12:27:31 -         |_ -> List.rev acc
2018-12-11 12:27:31 -     computeCells 3 [(firstKPoints 4)]
2018-12-11 12:27:43 - let finiteDifferencesTable = 
2018-12-11 12:27:43 -     let rec computeCells y acc = 
2018-12-11 12:27:43 -         let computeCol (prevCol : float list) =
2018-12-11 12:27:43 -             let rec computeColInternal x acc =
2018-12-11 12:27:43 -                 match x with
2018-12-11 12:27:43 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 12:27:43 -                 | _ -> acc
2018-12-11 12:27:43 -             computeColInternal y [] 
2018-12-11 12:27:43 -         match y with
2018-12-11 12:27:43 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 12:27:43 -         |_ -> List.rev acc
2018-12-11 12:27:43 -     computeCells 4 [(firstKPoints 4)]
2018-12-11 12:27:43 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 12:27:43 - Parameter name: n
2018-12-11 12:27:43 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 12:27:43 - Parameter name: n
2018-12-11 12:27:43 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 12:27:43 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 12:27:43 -   at FSI_0097.computeColInternal@4-2 (Microsoft.FSharp.Collections.FSharpList`1[T] prevCol, System.Int32 x, Microsoft.FSharp.Collections.FSharpList`1[T] acc) [0x0000e] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:43 -   at FSI_0097.computeCol@3-2 (System.Int32 y, Microsoft.FSharp.Collections.FSharpList`1[T] prevCol) [0x00015] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:43 -   at FSI_0097.computeCells@2-2 (System.Int32 y, Microsoft.FSharp.Collections.FSharpList`1[T] acc) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:43 -   at <StartupCode$FSI_0097>.$FSI_0097.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 12:27:43 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 12:27:43 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 12:27:46 - let finiteDifferencesTable = 
2018-12-11 12:27:46 -     let rec computeCells y acc = 
2018-12-11 12:27:46 -         let computeCol (prevCol : float list) =
2018-12-11 12:27:46 -             let rec computeColInternal x acc =
2018-12-11 12:27:46 -                 match x with
2018-12-11 12:27:46 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 12:27:46 -                 | _ -> acc
2018-12-11 12:27:46 -             computeColInternal y [] 
2018-12-11 12:27:46 -         match y with
2018-12-11 12:27:46 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 12:27:46 -         |_ -> List.rev acc
2018-12-11 12:27:46 -     computeCells 3 [(firstKPoints 4)]
2018-12-11 12:27:48 - finiteDifferencesTable
2018-12-11 12:31:51 - let fourQ = points |> List.take 4 |> List.map2 (q) (firstKPoints 4)
2018-12-11 12:32:06 - let finiteDifferencesTable = 
2018-12-11 12:32:06 -     let rec computeCells y acc = 
2018-12-11 12:32:06 -         let computeCol (prevCol : float list) =
2018-12-11 12:32:06 -             let rec computeColInternal x acc =
2018-12-11 12:32:06 -                 match x with
2018-12-11 12:32:06 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 12:32:06 -                 | _ -> acc
2018-12-11 12:32:06 -             computeColInternal y [] 
2018-12-11 12:32:06 -         match y with
2018-12-11 12:32:06 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 12:32:06 -         |_ -> List.rev acc
2018-12-11 12:32:06 -     computeCells 3 [fourQ]
2018-12-11 12:32:07 - finiteDifferencesTable
2018-12-11 13:35:28 - let ys = firstKPoints 4
2018-12-11 13:35:28 - let fourQ = points |> List.take 4 |> List.map2 (q) (ys)
2018-12-11 13:35:30 - let finiteDifferencesTable = 
2018-12-11 13:35:30 -     let rec computeCells y acc = 
2018-12-11 13:35:30 -         let computeCol (prevCol : float list) =
2018-12-11 13:35:30 -             let rec computeColInternal x acc =
2018-12-11 13:35:30 -                 match x with
2018-12-11 13:35:30 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 13:35:30 -                 | _ -> acc
2018-12-11 13:35:30 -             computeColInternal y [] 
2018-12-11 13:35:30 -         match y with
2018-12-11 13:35:30 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 13:35:30 -         |_ -> List.rev acc
2018-12-11 13:35:30 -     computeCells 3 [fourQ]
2018-12-11 16:00:27 - let first4Table = finiteDifferencesTable 4 fourQ
2018-12-11 16:00:27 - This value is not a function and cannot be applied.
2018-12-11 16:00:29 - let finiteDifferencesTable k Qs = 
2018-12-11 16:00:29 -     let rec computeCells y acc = 
2018-12-11 16:00:29 -         let computeCol (prevCol : float list) =
2018-12-11 16:00:29 -             let rec computeColInternal x acc =
2018-12-11 16:00:29 -                 match x with
2018-12-11 16:00:29 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:00:29 -                 | _ -> acc
2018-12-11 16:00:29 -             computeColInternal y [] 
2018-12-11 16:00:29 -         match y with
2018-12-11 16:00:29 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:00:29 -         |_ -> List.rev acc
2018-12-11 16:00:29 -     computeCells (k - 1) [Qs]
2018-12-11 16:00:29 - let first4Table = finiteDifferencesTable 4 fourQ
2018-12-11 16:11:44 - open System.Collections.Generic
2018-12-11 16:11:44 - let adams =
2018-12-11 16:11:44 -     let new_y y q (table : float list list) i = 
2018-12-11 16:11:44 -                     y + 
2018-12-11 16:11:44 -                     q + 
2018-12-11 16:11:44 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:11:44 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:11:44 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:11:44 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:11:44 -     let mutable lastY = ys |> List.last
2018-12-11 16:11:44 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:11:44 -     let mutable Qs = fourQ
2018-12-11 16:11:44 -     for i in 5 .. (N - 1) do
2018-12-11 16:11:44 -         lastY <- Ys |> List.last
2018-12-11 16:11:44 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:11:44 -         let table = finiteDifferencesTable i Qs
2018-12-11 16:11:44 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:11:44 -     Ys
2018-12-11 16:11:44 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:11:44 - Parameter name: n
2018-12-11 16:11:44 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:11:44 - Parameter name: n
2018-12-11 16:11:44 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:11:44 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:11:44 -   at FSI_0110.new_y@4 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:11:44 -   at <StartupCode$FSI_0110>.$FSI_0110.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:11:44 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:11:44 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:11:48 - let adams =
2018-12-11 16:11:48 -     let new_y y q (table : float list list) i = 
2018-12-11 16:11:48 -                     y + 
2018-12-11 16:11:48 -                     q + 
2018-12-11 16:11:48 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:11:48 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:11:48 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:11:48 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:11:48 -     let mutable lastY = ys |> List.last
2018-12-11 16:11:48 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:11:48 -     let mutable Qs = fourQ
2018-12-11 16:11:48 -     for i in 5 .. (N - 1) do
2018-12-11 16:11:48 -         lastY <- Ys |> List.last
2018-12-11 16:11:48 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:11:48 -         let table = finiteDifferencesTable i Qs
2018-12-11 16:11:48 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:11:48 -     Ys
2018-12-11 16:11:49 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:11:49 - Parameter name: n
2018-12-11 16:11:49 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:11:49 - Parameter name: n
2018-12-11 16:11:49 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:11:49 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:11:49 -   at FSI_0111.new_y@2-1 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:11:49 -   at <StartupCode$FSI_0111>.$FSI_0111.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:11:49 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:11:49 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:12:22 - let finiteDifferencesTable k Qs = 
2018-12-11 16:12:22 -     let rec computeCells y acc = 
2018-12-11 16:12:22 -         let computeCol (prevCol : float list) =
2018-12-11 16:12:22 -             let rec computeColInternal x acc =
2018-12-11 16:12:22 -                 match x with
2018-12-11 16:12:22 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:12:22 -                 | _ -> acc
2018-12-11 16:12:22 -             computeColInternal y [] 
2018-12-11 16:12:22 -         match y with
2018-12-11 16:12:22 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:12:22 -         |_ -> List.rev acc
2018-12-11 16:12:22 -     computeCells (k - 1) [Qs]
2018-12-11 16:12:22 - let first4Table = finiteDifferencesTable 4 fourQ
2018-12-11 16:12:22 - let adams =
2018-12-11 16:12:22 -     let new_y y q (table : float list list) i = 
2018-12-11 16:12:22 -                     y + 
2018-12-11 16:12:22 -                     q + 
2018-12-11 16:12:22 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:12:22 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:12:22 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:12:22 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:12:22 -     let mutable lastY = ys |> List.last
2018-12-11 16:12:22 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:12:22 -     let mutable Qs = fourQ
2018-12-11 16:12:22 -     for i in 5 .. (N - 1) do
2018-12-11 16:12:22 -         lastY <- Ys |> List.last
2018-12-11 16:12:22 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:12:22 -         let table = finiteDifferencesTable i Qs
2018-12-11 16:12:22 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:12:22 -     Ys
2018-12-11 16:12:22 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:12:22 - Parameter name: n
2018-12-11 16:12:22 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:12:22 - Parameter name: n
2018-12-11 16:12:22 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:12:22 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:12:22 -   at FSI_0114.new_y@2-2 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:12:22 -   at <StartupCode$FSI_0114>.$FSI_0114.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:12:22 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:12:22 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:17:23 - let finiteDifferencesTable (Qs : float list) = 
2018-12-11 16:17:23 -     let rec computeCells y acc = 
2018-12-11 16:17:23 -         let computeCol (prevCol : float list) =
2018-12-11 16:17:23 -             let rec computeColInternal x acc =
2018-12-11 16:17:23 -                 match x with
2018-12-11 16:17:23 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:17:23 -                 | _ -> acc
2018-12-11 16:17:23 -             computeColInternal y [] 
2018-12-11 16:17:23 -         match y with
2018-12-11 16:17:23 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:17:23 -         |_ -> List.rev acc
2018-12-11 16:17:23 -     computeCells (Qs.Length - 1) [Qs]
2018-12-11 16:17:23 - let first4Table = finiteDifferencesTable fourQ
2018-12-11 16:17:24 - let adams =
2018-12-11 16:17:24 -     let new_y y q (table : float list list) i = 
2018-12-11 16:17:24 -                     y + 
2018-12-11 16:17:24 -                     q + 
2018-12-11 16:17:24 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:17:24 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:17:24 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:17:24 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:17:24 -     let mutable lastY = ys |> List.last
2018-12-11 16:17:24 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:17:24 -     let mutable Qs = fourQ
2018-12-11 16:17:24 -     for i in 5 .. (N - 1) do
2018-12-11 16:17:24 -         lastY <- Ys |> List.last
2018-12-11 16:17:24 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:17:24 -         let table = finiteDifferencesTable Qs
2018-12-11 16:17:24 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:17:24 -     Ys
2018-12-11 16:17:24 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:17:24 - Parameter name: n
2018-12-11 16:17:24 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:17:24 - Parameter name: n
2018-12-11 16:17:24 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:17:24 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:17:24 -   at FSI_0117.new_y@2-3 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:17:24 -   at <StartupCode$FSI_0117>.$FSI_0117.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:17:24 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:17:24 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:19:17 - let first4Table = finiteDifferencesTable fourQ
2018-12-11 16:19:17 - first4Table
2018-12-11 16:20:07 - let adams =
2018-12-11 16:20:07 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:07 -                     y + 
2018-12-11 16:20:07 -                     q + 
2018-12-11 16:20:07 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:07 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:07 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:07 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:07 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:07 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:07 -     let mutable Qs = fourQ
2018-12-11 16:20:07 -     let mutable i = 5
2018-12-11 16:20:07 -     while i < N do
2018-12-11 16:20:07 -         lastY <- Ys |> List.last
2018-12-11 16:20:07 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:07 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:07 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:07 -         i <- i + 1
2018-12-11 16:20:07 -     Ys
2018-12-11 16:20:07 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:07 - Parameter name: n
2018-12-11 16:20:07 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:07 - Parameter name: n
2018-12-11 16:20:07 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:07 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:07 -   at FSI_0120.new_y@2-4 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:07 -   at <StartupCode$FSI_0120>.$FSI_0120.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:07 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:07 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:20:13 - let adams =
2018-12-11 16:20:13 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:13 -                     y + 
2018-12-11 16:20:13 -                     q + 
2018-12-11 16:20:13 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:13 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:13 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:13 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:13 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:13 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:13 -     let mutable Qs = fourQ
2018-12-11 16:20:13 -     let mutable i = 5
2018-12-11 16:20:13 -     while i < N - 1 do
2018-12-11 16:20:13 -         lastY <- Ys |> List.last
2018-12-11 16:20:13 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:13 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:13 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:13 -         i <- i + 1
2018-12-11 16:20:13 -     Ys
2018-12-11 16:20:13 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:13 - Parameter name: n
2018-12-11 16:20:13 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:13 - Parameter name: n
2018-12-11 16:20:13 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:13 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:13 -   at FSI_0121.new_y@2-5 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:13 -   at <StartupCode$FSI_0121>.$FSI_0121.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:13 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:13 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:20:16 - let adams =
2018-12-11 16:20:16 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:16 -                     y + 
2018-12-11 16:20:16 -                     q + 
2018-12-11 16:20:16 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:16 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:16 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:16 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:16 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:16 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:16 -     let mutable Qs = fourQ
2018-12-11 16:20:16 -     let mutable i = 5
2018-12-11 16:20:16 -     while i < N - 2 do
2018-12-11 16:20:16 -         lastY <- Ys |> List.last
2018-12-11 16:20:16 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:16 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:16 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:16 -         i <- i + 1
2018-12-11 16:20:16 -     Ys
2018-12-11 16:20:16 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:16 - Parameter name: n
2018-12-11 16:20:16 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:16 - Parameter name: n
2018-12-11 16:20:16 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:16 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:16 -   at FSI_0122.new_y@2-6 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:16 -   at <StartupCode$FSI_0122>.$FSI_0122.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:16 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:16 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:20:18 - let adams =
2018-12-11 16:20:18 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:18 -                     y + 
2018-12-11 16:20:18 -                     q + 
2018-12-11 16:20:18 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:18 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:18 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:18 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:18 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:18 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:18 -     let mutable Qs = fourQ
2018-12-11 16:20:18 -     let mutable i = 5
2018-12-11 16:20:18 -     while i < N - 3 do
2018-12-11 16:20:18 -         lastY <- Ys |> List.last
2018-12-11 16:20:18 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:18 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:18 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:18 -         i <- i + 1
2018-12-11 16:20:18 -     Ys
2018-12-11 16:20:18 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:18 - Parameter name: n
2018-12-11 16:20:18 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:18 - Parameter name: n
2018-12-11 16:20:18 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:18 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:18 -   at FSI_0123.new_y@2-7 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:18 -   at <StartupCode$FSI_0123>.$FSI_0123.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:18 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:18 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:20:20 - let adams =
2018-12-11 16:20:20 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:20 -                     y + 
2018-12-11 16:20:20 -                     q + 
2018-12-11 16:20:20 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:20 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:20 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:20 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:20 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:20 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:20 -     let mutable Qs = fourQ
2018-12-11 16:20:20 -     let mutable i = 5
2018-12-11 16:20:20 -     while i < N - 4 do
2018-12-11 16:20:20 -         lastY <- Ys |> List.last
2018-12-11 16:20:20 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:20 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:20 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:20 -         i <- i + 1
2018-12-11 16:20:20 -     Ys
2018-12-11 16:20:20 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:20 - Parameter name: n
2018-12-11 16:20:20 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:20 - Parameter name: n
2018-12-11 16:20:20 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:20 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:20 -   at FSI_0124.new_y@2-8 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:20 -   at <StartupCode$FSI_0124>.$FSI_0124.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:20 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:20 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:20:23 - let adams =
2018-12-11 16:20:23 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:23 -                     y + 
2018-12-11 16:20:23 -                     q + 
2018-12-11 16:20:23 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:23 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:23 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:23 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:23 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:23 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:23 -     let mutable Qs = fourQ
2018-12-11 16:20:23 -     let mutable i = 5
2018-12-11 16:20:23 -     while i < N - 5 do
2018-12-11 16:20:23 -         lastY <- Ys |> List.last
2018-12-11 16:20:23 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:23 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:23 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:23 -         i <- i + 1
2018-12-11 16:20:23 -     Ys
2018-12-11 16:20:23 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:23 - Parameter name: n
2018-12-11 16:20:23 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:23 - Parameter name: n
2018-12-11 16:20:23 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:23 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:23 -   at FSI_0125.new_y@2-9 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:23 -   at <StartupCode$FSI_0125>.$FSI_0125.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:23 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:23 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:20:26 - let adams =
2018-12-11 16:20:26 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:26 -                     y + 
2018-12-11 16:20:26 -                     q + 
2018-12-11 16:20:26 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:26 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:26 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:26 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:26 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:26 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:26 -     let mutable Qs = fourQ
2018-12-11 16:20:26 -     let mutable i = 5
2018-12-11 16:20:26 -     while i < N - 6 do
2018-12-11 16:20:26 -         lastY <- Ys |> List.last
2018-12-11 16:20:26 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:26 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:26 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:26 -         i <- i + 1
2018-12-11 16:20:26 -     Ys
2018-12-11 16:20:26 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:26 - Parameter name: n
2018-12-11 16:20:26 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:26 - Parameter name: n
2018-12-11 16:20:26 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:26 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:26 -   at FSI_0126.new_y@2-10 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:26 -   at <StartupCode$FSI_0126>.$FSI_0126.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:26 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:26 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:20:34 - let adams =
2018-12-11 16:20:34 -     let new_y y q (table : float list list) i = 
2018-12-11 16:20:34 -                     y + 
2018-12-11 16:20:34 -                     q + 
2018-12-11 16:20:34 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:20:34 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:20:34 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:20:34 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:20:34 -     let mutable lastY = ys |> List.last
2018-12-11 16:20:34 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:20:34 -     let mutable Qs = fourQ
2018-12-11 16:20:34 -     let mutable i = 5
2018-12-11 16:20:34 -     while i < N do
2018-12-11 16:20:34 -         lastY <- Ys |> List.last
2018-12-11 16:20:34 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:20:34 -         let table = finiteDifferencesTable Qs
2018-12-11 16:20:34 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:20:34 -         i <- i + 1
2018-12-11 16:20:34 -     Ys
2018-12-11 16:20:34 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:20:34 - Parameter name: n
2018-12-11 16:20:34 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:20:34 - Parameter name: n
2018-12-11 16:20:34 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:34 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:20:34 -   at FSI_0127.new_y@2-11 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:34 -   at <StartupCode$FSI_0127>.$FSI_0127.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:20:34 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:20:34 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:22:33 - let ys = firstKPoints 5
2018-12-11 16:22:33 - let fourQ = points |> List.take 5 |> List.map2 (q) (ys)
2018-12-11 16:22:33 - let finiteDifferencesTable (Qs : float list) = 
2018-12-11 16:22:33 -     let rec computeCells y acc = 
2018-12-11 16:22:33 -         let computeCol (prevCol : float list) =
2018-12-11 16:22:33 -             let rec computeColInternal x acc =
2018-12-11 16:22:33 -                 match x with
2018-12-11 16:22:33 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:22:33 -                 | _ -> acc
2018-12-11 16:22:33 -             computeColInternal y [] 
2018-12-11 16:22:33 -         match y with
2018-12-11 16:22:33 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:22:33 -         |_ -> List.rev acc
2018-12-11 16:22:33 -     computeCells (Qs.Length - 1) [Qs]
2018-12-11 16:22:34 - let first4Table = finiteDifferencesTable fourQ
2018-12-11 16:22:34 - first4Table
2018-12-11 16:22:36 - let adams =
2018-12-11 16:22:36 -     let new_y y q (table : float list list) i = 
2018-12-11 16:22:36 -                     y + 
2018-12-11 16:22:36 -                     q + 
2018-12-11 16:22:36 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:22:36 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:22:36 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:22:36 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:22:36 -     let mutable lastY = ys |> List.last
2018-12-11 16:22:36 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:22:36 -     let mutable Qs = fourQ
2018-12-11 16:22:36 -     let mutable i = 5
2018-12-11 16:22:36 -     while i < N do
2018-12-11 16:22:36 -         lastY <- Ys |> List.last
2018-12-11 16:22:36 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:22:36 -         let table = finiteDifferencesTable Qs
2018-12-11 16:22:36 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:22:36 -         i <- i + 1
2018-12-11 16:22:36 -     Ys
2018-12-11 16:22:41 - adams
2018-12-11 16:23:32 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:23:32 -         (points |> List.skip 1)
2018-12-11 16:23:32 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:23:32 - list1 is 1 element shorter than list2
2018-12-11 16:23:32 - Parameter name: list1
2018-12-11 16:23:32 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:23:32 - list1 is 1 element shorter than list2
2018-12-11 16:23:32 - Parameter name: list1
2018-12-11 16:23:32 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:23:32 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:23:32 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:23:32 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:23:32 -   at <StartupCode$FSI_0135>.$FSI_0135.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:23:32 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:23:32 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:23:40 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:23:40 -         points
2018-12-11 16:23:53 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:23:53 -         points |> Util.Table
2018-12-11 16:25:26 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 16:25:26 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 16:25:26 - For help type #help;;
2018-12-11 16:25:26 - > val it :
2018-12-11 16:25:26 -   ResizeArray<System.Type *
2018-12-11 16:25:26 -               (obj ->
2018-12-11 16:25:26 -                  seq<string *
2018-12-11 16:25:26 -                      string> *
2018-12-11 16:25:26 -                  string)>
2018-12-11 16:25:26 - = seq []
2018-12-11 16:25:26 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 16:25:26 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 16:25:26 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 16:25:27 - Reporting 0 opened comms
2018-12-11 16:26:08 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-11 16:26:08 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-11 16:26:08 - For help type #help;;
2018-12-11 16:26:08 - > val it :
2018-12-11 16:26:08 -   ResizeArray<System.Type *
2018-12-11 16:26:08 -               (obj ->
2018-12-11 16:26:08 -                  seq<string *
2018-12-11 16:26:08 -                      string> *
2018-12-11 16:26:08 -                  string)>
2018-12-11 16:26:08 - = seq []
2018-12-11 16:26:08 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-11 16:26:08 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-11 16:26:08 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-11 16:26:09 - Reporting 0 opened comms
2018-12-11 16:30:34 - let f (x : float) (y : float) = (x + y) / (y - x)
2018-12-11 16:30:34 - let x0 = 0.
2018-12-11 16:30:34 - let y0 = 1.
2018-12-11 16:30:34 - let a = x0
2018-12-11 16:30:34 - let b = x0 + 1.
2018-12-11 16:30:34 - let N = 100
2018-12-11 16:30:34 - let h = (b - a) / float N
2018-12-11 16:30:34 - let points = [a .. h .. b]
2018-12-11 16:30:35 - let exact x = sqrt(1. + 2. * x ** 2.) + x
2018-12-11 16:30:35 - type tableRow = {Точка: float; Значение: float; Погрешность: float}
2018-12-11 16:30:35 - let euler1 = 
2018-12-11 16:30:35 -     points 
2018-12-11 16:30:35 -     |> List.take (points.Length - 1)
2018-12-11 16:30:35 -     |> List.mapFold (fun acc x -> 
2018-12-11 16:30:35 -                         let res = acc + h * f x acc
2018-12-11 16:30:35 -                         (res, res)) y0
2018-12-11 16:30:35 -     |> fst
2018-12-11 16:30:35 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-11 16:30:35 -         (points |> List.skip 1)
2018-12-11 16:30:36 - euler1 |> Util.Table
2018-12-11 16:30:36 - let euler2 = 
2018-12-11 16:30:36 -     points 
2018-12-11 16:30:36 -     |> List.take (points.Length - 1)
2018-12-11 16:30:36 -     |> List.mapFold (fun acc x -> 
2018-12-11 16:30:36 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-11 16:30:36 -                         (res, res)) y0
2018-12-11 16:30:36 -     |> fst
2018-12-11 16:30:36 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:30:36 -         (points |> List.skip 1)
2018-12-11 16:30:36 - euler2 |> Util.Table
2018-12-11 16:30:36 - let euler3 = 
2018-12-11 16:30:36 -     let overY x y = y + h * f x y
2018-12-11 16:30:36 -     let rec euler3Internal acc l = 
2018-12-11 16:30:36 -         match l with
2018-12-11 16:30:36 -         | first :: second :: t -> 
2018-12-11 16:30:36 -             let y = List.head acc
2018-12-11 16:30:36 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-11 16:30:36 -             euler3Internal newAcc (second :: t)
2018-12-11 16:30:36 -         |[] |[_] -> acc |> List.rev |> List.skip 1
2018-12-11 16:30:36 -     euler3Internal [y0] points
2018-12-11 16:30:36 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:30:36 -         (points |> List.skip 1)
2018-12-11 16:30:36 - euler3 |> Util.Table
2018-12-11 16:30:37 - let rungekut = 
2018-12-11 16:30:37 -     points 
2018-12-11 16:30:37 -     |> List.take (points.Length - 1)
2018-12-11 16:30:37 -     |> List.mapFold (fun acc x -> 
2018-12-11 16:30:37 -                         let k1 = h * f x acc
2018-12-11 16:30:37 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-11 16:30:37 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-11 16:30:37 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-11 16:30:37 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-11 16:30:37 -                         (res, res)) y0
2018-12-11 16:30:37 -     |> fst
2018-12-11 16:30:37 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:30:37 -         (points |> List.skip 1)
2018-12-11 16:30:37 - rungekut |> Util.Table
2018-12-11 16:30:37 - let q x y = h * f x y
2018-12-11 16:30:37 - let firstKPoints k =
2018-12-11 16:30:37 -     y0 :: (points 
2018-12-11 16:30:37 -     |> List.take (k - 1)
2018-12-11 16:30:37 -     |> List.mapFold (fun acc x -> 
2018-12-11 16:30:37 -                         let k1 = h * f x acc
2018-12-11 16:30:37 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-11 16:30:37 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-11 16:30:37 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-11 16:30:37 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-11 16:30:37 -                         (res, res)) y0
2018-12-11 16:30:37 -     |> fst)
2018-12-11 16:30:37 - let ys = firstKPoints 5
2018-12-11 16:30:37 - let fourQ = points |> List.take 5 |> List.map2 (q) (ys)
2018-12-11 16:30:38 - let finiteDifferencesTable (Qs : float list) = 
2018-12-11 16:30:38 -     let rec computeCells y acc = 
2018-12-11 16:30:38 -         let computeCol (prevCol : float list) =
2018-12-11 16:30:38 -             let rec computeColInternal x acc =
2018-12-11 16:30:38 -                 match x with
2018-12-11 16:30:38 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:30:38 -                 | _ -> acc
2018-12-11 16:30:38 -             computeColInternal y [] 
2018-12-11 16:30:38 -         match y with
2018-12-11 16:30:38 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:30:38 -         |_ -> List.rev acc
2018-12-11 16:30:38 -     computeCells (Qs.Length - 1) [Qs]
2018-12-11 16:30:38 - let first4Table = finiteDifferencesTable fourQ
2018-12-11 16:30:38 - first4Table
2018-12-11 16:30:38 - let adams =
2018-12-11 16:30:38 -     let new_y y q (table : float list list) i = 
2018-12-11 16:30:38 -                     y + 
2018-12-11 16:30:38 -                     q + 
2018-12-11 16:30:38 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:30:38 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:30:38 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:30:38 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:30:38 -     let mutable lastY = ys |> List.last
2018-12-11 16:30:38 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:30:38 -     let mutable Qs = fourQ
2018-12-11 16:30:38 -     let mutable i = 5
2018-12-11 16:30:38 -     while i < N do
2018-12-11 16:30:38 -         lastY <- Ys |> List.last
2018-12-11 16:30:38 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:30:38 -         let table = finiteDifferencesTable Qs
2018-12-11 16:30:38 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:30:38 -         i <- i + 1
2018-12-11 16:30:38 -     Ys
2018-12-11 16:30:38 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:30:38 -         points |> Util.Table
2018-12-11 16:35:47 - ys
2018-12-11 16:37:00 - let adams =
2018-12-11 16:37:00 -     let new_y y q (table : float list list) i = 
2018-12-11 16:37:00 -                     y + 
2018-12-11 16:37:00 -                     q + 
2018-12-11 16:37:00 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:37:00 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:37:00 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:37:00 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:37:00 -     let mutable lastY = ys |> List.last
2018-12-11 16:37:00 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 5]
2018-12-11 16:37:00 -     let mutable Qs = fourQ
2018-12-11 16:37:00 -     let mutable i = 6
2018-12-11 16:37:00 -     while i < N do
2018-12-11 16:37:00 -         lastY <- Ys |> List.last
2018-12-11 16:37:00 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:37:00 -         let table = finiteDifferencesTable Qs
2018-12-11 16:37:00 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:37:00 -         i <- i + 1
2018-12-11 16:37:00 -     Ys
2018-12-11 16:37:00 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:37:00 - Parameter name: n
2018-12-11 16:37:00 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:37:00 - Parameter name: n
2018-12-11 16:37:00 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:37:00 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:37:00 -   at FSI_0167.new_y@2-14 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:37:00 -   at <StartupCode$FSI_0167>.$FSI_0167.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:37:00 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:37:00 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:40:45 - let adams =
2018-12-11 16:40:45 -     let new_y y q (table : float list list) i = 
2018-12-11 16:40:45 -                     y + 
2018-12-11 16:40:45 -                     q + 
2018-12-11 16:40:45 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:40:45 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:40:45 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:40:45 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:40:45 -     let mutable lastY = ys |> List.last
2018-12-11 16:40:45 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:40:45 -     let mutable Qs = fourQ
2018-12-11 16:40:45 -     let mutable i = 5
2018-12-11 16:40:45 -     while i < N do
2018-12-11 16:40:45 -         lastY <- Ys |> List.last
2018-12-11 16:40:45 -         Qs <- Qs @ [q points.[i - 1] lastY]
2018-12-11 16:40:45 -         let table = finiteDifferencesTable Qs
2018-12-11 16:40:45 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:40:45 -         i <- i + 1
2018-12-11 16:40:45 -     Ys
2018-12-11 16:40:46 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:40:46 -         points |> Util.Table
2018-12-11 16:40:55 - let adams =
2018-12-11 16:40:55 -     let new_y y q (table : float list list) i = 
2018-12-11 16:40:55 -                     y + 
2018-12-11 16:40:55 -                     q + 
2018-12-11 16:40:55 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:40:55 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:40:55 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:40:55 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:40:55 -     let mutable lastY = ys |> List.last
2018-12-11 16:40:55 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:40:55 -     let mutable Qs = fourQ
2018-12-11 16:40:55 -     let mutable i = 5
2018-12-11 16:40:55 -     while i < N do
2018-12-11 16:40:55 -         lastY <- Ys |> List.last
2018-12-11 16:40:55 -         Qs <- Qs @ [q points.[i + 1] lastY]
2018-12-11 16:40:55 -         let table = finiteDifferencesTable Qs
2018-12-11 16:40:55 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:40:55 -         i <- i + 1
2018-12-11 16:40:55 -     Ys
2018-12-11 16:40:55 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:40:55 -         points |> Util.Table
2018-12-11 16:41:18 - let adams =
2018-12-11 16:41:18 -     let new_y y q (table : float list list) i = 
2018-12-11 16:41:18 -                     y + 
2018-12-11 16:41:18 -                     q + 
2018-12-11 16:41:18 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:41:18 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:41:18 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:41:18 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:41:18 -     let mutable lastY = ys |> List.last
2018-12-11 16:41:18 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:41:18 -     let mutable Qs = fourQ
2018-12-11 16:41:18 -     let mutable i = 5
2018-12-11 16:41:18 -     while i < N do
2018-12-11 16:41:18 -         lastY <- Ys |> List.last
2018-12-11 16:41:18 -         Qs <- Qs @ [q points.[i -1] lastY]
2018-12-11 16:41:18 -         let table = finiteDifferencesTable Qs
2018-12-11 16:41:18 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:41:18 -         i <- i + 1
2018-12-11 16:41:18 -     Ys
2018-12-11 16:41:18 - This value is not a function and cannot be applied.
2018-12-11 16:41:19 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:41:19 -         points |> Util.Table
2018-12-11 16:41:23 - let adams =
2018-12-11 16:41:23 -     let new_y y q (table : float list list) i = 
2018-12-11 16:41:23 -                     y + 
2018-12-11 16:41:23 -                     q + 
2018-12-11 16:41:23 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:41:23 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:41:23 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:41:23 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:41:23 -     let mutable lastY = ys |> List.last
2018-12-11 16:41:23 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:41:23 -     let mutable Qs = fourQ
2018-12-11 16:41:23 -     let mutable i = 5
2018-12-11 16:41:23 -     while i < N do
2018-12-11 16:41:23 -         lastY <- Ys |> List.last
2018-12-11 16:41:23 -         Qs <- Qs @ [q points.[i - 1] lastY]
2018-12-11 16:41:23 -         let table = finiteDifferencesTable Qs
2018-12-11 16:41:23 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:41:23 -         i <- i + 1
2018-12-11 16:41:23 -     Ys
2018-12-11 16:41:24 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:41:24 -         points |> Util.Table
2018-12-11 16:41:33 - let adams =
2018-12-11 16:41:33 -     let new_y y q (table : float list list) i = 
2018-12-11 16:41:33 -                     y + 
2018-12-11 16:41:33 -                     q + 
2018-12-11 16:41:33 -                     1. / 2. * table.[1].[i - 1] +
2018-12-11 16:41:33 -                     5. / 12. * table.[2].[i - 2] +
2018-12-11 16:41:33 -                     3. / 8. * table.[3].[i - 3] +
2018-12-11 16:41:33 -                     251. / 720. * table.[4].[i - 4]
2018-12-11 16:41:33 -     let mutable lastY = ys |> List.last
2018-12-11 16:41:33 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:41:33 -     let mutable Qs = fourQ
2018-12-11 16:41:33 -     let mutable i = 5
2018-12-11 16:41:33 -     while i < N do
2018-12-11 16:41:33 -         lastY <- Ys |> List.last
2018-12-11 16:41:33 -         Qs <- Qs @ [q points.[i + 1] lastY]
2018-12-11 16:41:33 -         let table = finiteDifferencesTable Qs
2018-12-11 16:41:33 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:41:33 -         i <- i + 1
2018-12-11 16:41:33 -     Ys
2018-12-11 16:41:33 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:41:33 -         points |> Util.Table
2018-12-11 16:45:13 - let adams =
2018-12-11 16:45:13 -     let new_y y q (table : float list list) i = 
2018-12-11 16:45:13 -                     y + 
2018-12-11 16:45:13 -                     q + 
2018-12-11 16:45:13 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:45:13 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:45:13 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:45:13 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:45:13 -     let mutable lastY = ys |> List.last
2018-12-11 16:45:13 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:45:13 -     let mutable Qs = fourQ
2018-12-11 16:45:13 -     let mutable i = 5
2018-12-11 16:45:13 -     while i < N do
2018-12-11 16:45:13 -         lastY <- Ys |> List.last
2018-12-11 16:45:13 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:45:13 -         let table = finiteDifferencesTable Qs
2018-12-11 16:45:13 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:45:13 -         i <- i + 1
2018-12-11 16:45:13 -     Ys
2018-12-11 16:45:13 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:45:13 - Parameter name: n
2018-12-11 16:45:13 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:45:13 - Parameter name: n
2018-12-11 16:45:13 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:45:13 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:45:13 -   at FSI_0183.new_y@2-19 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:45:13 -   at <StartupCode$FSI_0183>.$FSI_0183.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:45:13 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:45:13 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:47:02 - let firstKPoints k =
2018-12-11 16:47:02 -     y0 :: (points 
2018-12-11 16:47:02 -     |> List.take (k - 1)
2018-12-11 16:47:02 -     |> List.mapFold (fun acc x -> 
2018-12-11 16:47:02 -                         let k1 = h * f x acc
2018-12-11 16:47:02 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-11 16:47:02 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-11 16:47:02 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-11 16:47:02 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-11 16:47:02 -                         (res, res)) y0
2018-12-11 16:47:02 -     |> fst)
2018-12-11 16:47:02 - let ys = firstKPoints 4
2018-12-11 16:47:02 - let fourQ = points |> List.take 4 |> List.map2 (q) (ys)
2018-12-11 16:47:02 - let finiteDifferencesTable (Qs : float list) = 
2018-12-11 16:47:02 -     let rec computeCells y acc = 
2018-12-11 16:47:02 -         let computeCol (prevCol : float list) =
2018-12-11 16:47:02 -             let rec computeColInternal x acc =
2018-12-11 16:47:02 -                 match x with
2018-12-11 16:47:02 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:47:02 -                 | _ -> acc
2018-12-11 16:47:02 -             computeColInternal y [] 
2018-12-11 16:47:02 -         match y with
2018-12-11 16:47:02 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:47:02 -         |_ -> List.rev acc
2018-12-11 16:47:02 -     computeCells (Qs.Length - 1) [Qs]
2018-12-11 16:47:03 - let first4Table = finiteDifferencesTable fourQ
2018-12-11 16:47:03 - first4Table
2018-12-11 16:47:07 - ys
2018-12-11 16:47:17 - let adams =
2018-12-11 16:47:17 -     let new_y y q (table : float list list) i = 
2018-12-11 16:47:17 -                     y + 
2018-12-11 16:47:17 -                     q + 
2018-12-11 16:47:17 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:47:17 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:47:17 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:47:17 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:47:17 -     let mutable lastY = ys |> List.last
2018-12-11 16:47:17 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:47:17 -     let mutable Qs = fourQ
2018-12-11 16:47:17 -     let mutable i = 5
2018-12-11 16:47:17 -     while i < N do
2018-12-11 16:47:17 -         lastY <- Ys |> List.last
2018-12-11 16:47:17 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:47:17 -         let table = finiteDifferencesTable Qs
2018-12-11 16:47:17 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:47:17 -         i <- i + 1
2018-12-11 16:47:17 -     Ys
2018-12-11 16:47:17 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:47:17 - Parameter name: n
2018-12-11 16:47:17 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:47:17 - Parameter name: n
2018-12-11 16:47:17 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:47:17 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:47:17 -   at FSI_0191.new_y@2-20 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:47:17 -   at <StartupCode$FSI_0191>.$FSI_0191.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:47:17 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:47:17 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:48:48 - let ys = firstKPoints 5
2018-12-11 16:48:48 - let fourQ = points |> List.take 5 |> List.map2 (q) (ys)
2018-12-11 16:48:48 - let finiteDifferencesTable (Qs : float list) = 
2018-12-11 16:48:48 -     let rec computeCells y acc = 
2018-12-11 16:48:48 -         let computeCol (prevCol : float list) =
2018-12-11 16:48:48 -             let rec computeColInternal x acc =
2018-12-11 16:48:48 -                 match x with
2018-12-11 16:48:48 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:48:48 -                 | _ -> acc
2018-12-11 16:48:48 -             computeColInternal y [] 
2018-12-11 16:48:48 -         match y with
2018-12-11 16:48:48 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:48:48 -         |_ -> List.rev acc
2018-12-11 16:48:48 -     computeCells (Qs.Length - 1) [Qs]
2018-12-11 16:48:48 - let first4Table = finiteDifferencesTable fourQ
2018-12-11 16:48:48 - first4Table
2018-12-11 16:49:45 - let adams =
2018-12-11 16:49:45 -     let new_y y q (table : float list list) i = 
2018-12-11 16:49:45 -                     y + 
2018-12-11 16:49:45 -                     q + 
2018-12-11 16:49:45 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:49:45 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:49:45 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:49:45 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:49:45 -     let mutable lastY = ys |> List.last
2018-12-11 16:49:45 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 4]
2018-12-11 16:49:45 -     let mutable Qs = fourQ
2018-12-11 16:49:45 -     let mutable i = 5
2018-12-11 16:49:45 -     while i < N do
2018-12-11 16:49:45 -         lastY <- Ys |> List.last
2018-12-11 16:49:45 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:49:45 -         let table = finiteDifferencesTable Qs
2018-12-11 16:49:45 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:49:45 -         i <- i + 1
2018-12-11 16:49:45 -     Ys
2018-12-11 16:49:45 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:49:45 - Parameter name: n
2018-12-11 16:49:45 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:49:45 - Parameter name: n
2018-12-11 16:49:45 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:49:45 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:49:45 -   at FSI_0196.new_y@2-21 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:49:45 -   at <StartupCode$FSI_0196>.$FSI_0196.main@ () [0x00028] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:49:45 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:49:45 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:49:46 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:49:46 -         points |> Util.Table
2018-12-11 16:50:16 - let adams =
2018-12-11 16:50:16 -     let new_y y q (table : float list list) i = 
2018-12-11 16:50:16 -                     y + 
2018-12-11 16:50:16 -                     q + 
2018-12-11 16:50:16 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:50:16 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:50:16 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:50:16 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:50:16 -     let mutable lastY = ys |> List.last
2018-12-11 16:50:16 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:50:16 -     let mutable Qs = fourQ
2018-12-11 16:50:16 -     let mutable i = 5
2018-12-11 16:50:16 -     while i < N do
2018-12-11 16:50:16 -         lastY <- Ys |> List.last
2018-12-11 16:50:16 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:50:16 -         let table = finiteDifferencesTable Qs
2018-12-11 16:50:16 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:50:16 -         i <- i + 1
2018-12-11 16:50:16 -     Ys
2018-12-11 16:50:16 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-11 16:50:16 - Parameter name: n
2018-12-11 16:50:16 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-11 16:50:16 - Parameter name: n
2018-12-11 16:50:16 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:50:16 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:50:16 -   at FSI_0199.new_y@2-22 (System.Double y, System.Double q, Microsoft.FSharp.Collections.FSharpList`1[T] table, System.Int32 i) [0x0002a] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:50:16 -   at <StartupCode$FSI_0199>.$FSI_0199.main@ () [0x000eb] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:50:16 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:50:16 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:50:25 - let adams =
2018-12-11 16:50:25 -     let new_y y q (table : float list list) i = 
2018-12-11 16:50:25 -                     y + 
2018-12-11 16:50:25 -                     q + 
2018-12-11 16:50:25 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:50:25 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:50:25 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:50:25 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:50:25 -     let mutable lastY = ys |> List.last
2018-12-11 16:50:25 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:50:25 -     let mutable Qs = fourQ
2018-12-11 16:50:25 -     let mutable i = 4
2018-12-11 16:50:25 -     while i < N do
2018-12-11 16:50:25 -         lastY <- Ys |> List.last
2018-12-11 16:50:25 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:50:25 -         let table = finiteDifferencesTable Qs
2018-12-11 16:50:25 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:50:25 -         i <- i + 1
2018-12-11 16:50:25 -     Ys
2018-12-11 16:50:26 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:50:26 -         points |> Util.Table
2018-12-11 16:50:26 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:50:26 - list1 is 1 element shorter than list2
2018-12-11 16:50:26 - Parameter name: list1
2018-12-11 16:50:26 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:50:26 - list1 is 1 element shorter than list2
2018-12-11 16:50:26 - Parameter name: list1
2018-12-11 16:50:26 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:50:26 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:50:26 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:50:26 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:50:26 -   at <StartupCode$FSI_0201>.$FSI_0201.main@ () [0x0000f] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:50:26 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:50:26 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:51:23 - let adams =
2018-12-11 16:51:23 -     let new_y y q (table : float list list) i = 
2018-12-11 16:51:23 -                     y + 
2018-12-11 16:51:23 -                     q + 
2018-12-11 16:51:23 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:51:23 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:51:23 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:51:23 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:51:23 -     let mutable lastY = ys |> List.last
2018-12-11 16:51:23 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:51:23 -     let mutable Qs = fourQ
2018-12-11 16:51:23 -     let mutable i = 4
2018-12-11 16:51:23 -     while i < N do
2018-12-11 16:51:23 -         lastY <- Ys |> List.last
2018-12-11 16:51:23 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:51:23 -         let table = finiteDifferencesTable Qs
2018-12-11 16:51:23 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:51:23 -         i <- i + 1
2018-12-11 16:51:23 -     Ys |> List.take (N - 1)
2018-12-11 16:51:24 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:51:24 -         points |>  |> Util.Table
2018-12-11 16:51:24 - Unexpected infix operator in expression
2018-12-11 16:51:24 - parse error
2018-12-11 16:51:28 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:51:28 -         points |> Util.Table
2018-12-11 16:51:28 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:51:28 - list2 is 2 elements shorter than list1
2018-12-11 16:51:28 - Parameter name: list2
2018-12-11 16:51:28 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:51:28 - list2 is 2 elements shorter than list1
2018-12-11 16:51:28 - Parameter name: list2
2018-12-11 16:51:28 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:28 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00024] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:28 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:28 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:28 -   at <StartupCode$FSI_0203>.$FSI_0203.main@ () [0x0000f] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:51:28 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:51:28 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:51:39 - let adams =
2018-12-11 16:51:39 -     let new_y y q (table : float list list) i = 
2018-12-11 16:51:39 -                     y + 
2018-12-11 16:51:39 -                     q + 
2018-12-11 16:51:39 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:51:39 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:51:39 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:51:39 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:51:39 -     let mutable lastY = ys |> List.last
2018-12-11 16:51:39 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:51:39 -     let mutable Qs = fourQ
2018-12-11 16:51:39 -     let mutable i = 4
2018-12-11 16:51:39 -     while i < N do
2018-12-11 16:51:39 -         lastY <- Ys |> List.last
2018-12-11 16:51:39 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:51:39 -         let table = finiteDifferencesTable Qs
2018-12-11 16:51:39 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:51:39 -         i <- i + 1
2018-12-11 16:51:39 -     Ys |> List.take (N)
2018-12-11 16:51:39 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:51:39 -         points |> Util.Table
2018-12-11 16:51:39 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:51:39 - list2 is 1 element shorter than list1
2018-12-11 16:51:39 - Parameter name: list2
2018-12-11 16:51:39 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:51:39 - list2 is 1 element shorter than list1
2018-12-11 16:51:39 - Parameter name: list2
2018-12-11 16:51:39 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:39 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00024] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:39 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:39 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:51:39 -   at <StartupCode$FSI_0205>.$FSI_0205.main@ () [0x0000f] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:51:39 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:51:39 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:52:00 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:52:00 -         (points |> List.skip 1) |> Util.Table
2018-12-11 16:52:13 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:52:13 -         (points |> List.take N - 1) |> Util.Table
2018-12-11 16:52:13 - The type 'int' does not match the type 'obj list -> obj list'
2018-12-11 16:52:18 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:52:18 -         (points |> List.take (N - 1)) |> Util.Table
2018-12-11 16:52:18 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:52:18 - list1 is 1 element shorter than list2
2018-12-11 16:52:18 - Parameter name: list1
2018-12-11 16:52:18 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:52:18 - list1 is 1 element shorter than list2
2018-12-11 16:52:18 - Parameter name: list1
2018-12-11 16:52:18 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:18 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:18 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:18 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:18 -   at <StartupCode$FSI_0209>.$FSI_0209.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:52:18 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:52:18 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:52:32 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:52:32 -         (points |> List.take (N - 2)) |> Util.Table
2018-12-11 16:52:32 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:52:32 - list1 is 2 elements shorter than list2
2018-12-11 16:52:32 - Parameter name: list1
2018-12-11 16:52:32 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:52:32 - list1 is 2 elements shorter than list2
2018-12-11 16:52:32 - Parameter name: list1
2018-12-11 16:52:32 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:32 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:32 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:32 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:52:32 -   at <StartupCode$FSI_0210>.$FSI_0210.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:52:32 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:52:32 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:52:35 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:52:35 -         (points |> List.take (N)) |> Util.Table
2018-12-11 16:52:59 - let adams =
2018-12-11 16:52:59 -     let new_y y q (table : float list list) i = 
2018-12-11 16:52:59 -                     y + 
2018-12-11 16:52:59 -                     q + 
2018-12-11 16:52:59 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:52:59 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:52:59 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:52:59 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:52:59 -     let mutable lastY = ys |> List.last
2018-12-11 16:52:59 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:52:59 -     let mutable Qs = fourQ
2018-12-11 16:52:59 -     let mutable i = 4
2018-12-11 16:52:59 -     while i < N do
2018-12-11 16:52:59 -         lastY <- Ys |> List.last
2018-12-11 16:52:59 -         Qs <- Qs @ [q points.[i + 1] lastY]
2018-12-11 16:52:59 -         let table = finiteDifferencesTable Qs
2018-12-11 16:52:59 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:52:59 -         i <- i + 1
2018-12-11 16:52:59 -     Ys
2018-12-11 16:53:00 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:53:00 -         (points |> List.take (N)) |> Util.Table
2018-12-11 16:53:00 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:53:00 - list1 is 2 elements shorter than list2
2018-12-11 16:53:00 - Parameter name: list1
2018-12-11 16:53:00 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:53:00 - list1 is 2 elements shorter than list2
2018-12-11 16:53:00 - Parameter name: list1
2018-12-11 16:53:00 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:00 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:00 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:00 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:00 -   at <StartupCode$FSI_0214>.$FSI_0214.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:53:00 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:53:00 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:53:10 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:53:10 -         points |> Util.Table
2018-12-11 16:53:10 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:53:10 - list1 is 1 element shorter than list2
2018-12-11 16:53:10 - Parameter name: list1
2018-12-11 16:53:10 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:53:10 - list1 is 1 element shorter than list2
2018-12-11 16:53:10 - Parameter name: list1
2018-12-11 16:53:10 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:10 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:10 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:10 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:10 -   at <StartupCode$FSI_0215>.$FSI_0215.main@ () [0x0000f] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:53:10 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:53:10 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:53:22 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:53:22 -         (points |> List.take (N - 1)) |> Util.Table
2018-12-11 16:53:22 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:53:22 - list1 is 3 elements shorter than list2
2018-12-11 16:53:22 - Parameter name: list1
2018-12-11 16:53:22 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:53:22 - list1 is 3 elements shorter than list2
2018-12-11 16:53:22 - Parameter name: list1
2018-12-11 16:53:22 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:22 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:22 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:22 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:22 -   at <StartupCode$FSI_0216>.$FSI_0216.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:53:22 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:53:22 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:53:37 - let adams =
2018-12-11 16:53:37 -     let new_y y q (table : float list list) i = 
2018-12-11 16:53:37 -                     y + 
2018-12-11 16:53:37 -                     q + 
2018-12-11 16:53:37 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:53:37 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:53:37 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:53:37 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:53:37 -     let mutable lastY = ys |> List.last
2018-12-11 16:53:37 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:53:37 -     let mutable Qs = fourQ
2018-12-11 16:53:37 -     let mutable i = 4
2018-12-11 16:53:37 -     while i < N do
2018-12-11 16:53:37 -         lastY <- Ys |> List.last
2018-12-11 16:53:37 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:53:37 -         let table = finiteDifferencesTable Qs
2018-12-11 16:53:37 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:53:37 -         i <- i + 1
2018-12-11 16:53:37 -     Ys
2018-12-11 16:53:49 - let adams =
2018-12-11 16:53:49 -     let new_y y q (table : float list list) i = 
2018-12-11 16:53:49 -                     y + 
2018-12-11 16:53:49 -                     q + 
2018-12-11 16:53:49 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:53:49 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:53:49 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:53:49 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:53:49 -     let mutable lastY = ys |> List.last
2018-12-11 16:53:49 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:53:49 -     let mutable Qs = fourQ
2018-12-11 16:53:49 -     let mutable i = 4
2018-12-11 16:53:49 -     while i < N do
2018-12-11 16:53:49 -         lastY <- Ys |> List.last
2018-12-11 16:53:49 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:53:49 -         let table = finiteDifferencesTable Qs
2018-12-11 16:53:49 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:53:49 -         i <- i + 1
2018-12-11 16:53:49 -     Ys
2018-12-11 16:53:55 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:53:55 -         (points |> List.take (N - 1)) |> Util.Table
2018-12-11 16:53:55 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:53:55 - list1 is 3 elements shorter than list2
2018-12-11 16:53:55 - Parameter name: list1
2018-12-11 16:53:55 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:53:55 - list1 is 3 elements shorter than list2
2018-12-11 16:53:55 - Parameter name: list1
2018-12-11 16:53:55 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:55 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:55 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:55 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:53:55 -   at <StartupCode$FSI_0219>.$FSI_0219.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:53:55 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:53:55 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:54:05 - ys
2018-12-11 16:54:05 - let adams =
2018-12-11 16:54:05 -     let new_y y q (table : float list list) i = 
2018-12-11 16:54:05 -                     y + 
2018-12-11 16:54:05 -                     q + 
2018-12-11 16:54:05 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:54:05 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:54:05 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:54:05 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:54:05 -     let mutable lastY = ys |> List.last
2018-12-11 16:54:05 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:54:05 -     let mutable Qs = fourQ
2018-12-11 16:54:05 -     let mutable i = 4
2018-12-11 16:54:05 -     while i < N do
2018-12-11 16:54:05 -         lastY <- Ys |> List.last
2018-12-11 16:54:05 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:54:05 -         let table = finiteDifferencesTable Qs
2018-12-11 16:54:05 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:54:05 -         i <- i + 1
2018-12-11 16:54:05 -     Ys
2018-12-11 16:54:05 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:54:05 -         (points |> List.take (N - 1)) |> Util.Table
2018-12-11 16:54:05 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:54:05 - list1 is 3 elements shorter than list2
2018-12-11 16:54:05 - Parameter name: list1
2018-12-11 16:54:05 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:54:05 - list1 is 3 elements shorter than list2
2018-12-11 16:54:05 - Parameter name: list1
2018-12-11 16:54:05 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:05 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:05 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:05 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:05 -   at <StartupCode$FSI_0223>.$FSI_0223.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:54:05 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:54:05 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:54:11 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:54:11 -         (points |> List.take (N) |> Util.Table
2018-12-11 16:54:11 - Unmatched '('
2018-12-11 16:54:15 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:54:15 -         (points |> List.take N) |> Util.Table
2018-12-11 16:54:15 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:54:15 - list1 is 2 elements shorter than list2
2018-12-11 16:54:15 - Parameter name: list1
2018-12-11 16:54:15 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:54:15 - list1 is 2 elements shorter than list2
2018-12-11 16:54:15 - Parameter name: list1
2018-12-11 16:54:15 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:15 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:15 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:15 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:15 -   at <StartupCode$FSI_0225>.$FSI_0225.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:54:15 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:54:15 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:54:21 - let finiteDifferencesTable (Qs : float list) = 
2018-12-11 16:54:21 -     let rec computeCells y acc = 
2018-12-11 16:54:21 -         let computeCol (prevCol : float list) =
2018-12-11 16:54:21 -             let rec computeColInternal x acc =
2018-12-11 16:54:21 -                 match x with
2018-12-11 16:54:21 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-11 16:54:21 -                 | _ -> acc
2018-12-11 16:54:21 -             computeColInternal y [] 
2018-12-11 16:54:21 -         match y with
2018-12-11 16:54:21 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-11 16:54:21 -         |_ -> List.rev acc
2018-12-11 16:54:21 -     computeCells (Qs.Length - 1) [Qs]
2018-12-11 16:54:22 - let first4Table = finiteDifferencesTable fourQ
2018-12-11 16:54:22 - first4Table
2018-12-11 16:54:22 - ys
2018-12-11 16:54:22 - let adams =
2018-12-11 16:54:22 -     let new_y y q (table : float list list) i = 
2018-12-11 16:54:22 -                     y + 
2018-12-11 16:54:22 -                     q + 
2018-12-11 16:54:22 -                     1. / 2. * table.[1].[i] +
2018-12-11 16:54:22 -                     5. / 12. * table.[2].[i - 1] +
2018-12-11 16:54:22 -                     3. / 8. * table.[3].[i - 2] +
2018-12-11 16:54:22 -                     251. / 720. * table.[4].[i - 3]
2018-12-11 16:54:22 -     let mutable lastY = ys |> List.last
2018-12-11 16:54:22 -     let mutable Ys = ys @ [new_y lastY (fourQ |> List.last) first4Table 3]
2018-12-11 16:54:22 -     let mutable Qs = fourQ
2018-12-11 16:54:22 -     let mutable i = 4
2018-12-11 16:54:22 -     while i < N do
2018-12-11 16:54:22 -         lastY <- Ys |> List.last
2018-12-11 16:54:22 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-11 16:54:22 -         let table = finiteDifferencesTable Qs
2018-12-11 16:54:22 -         Ys <- Ys @ [new_y lastY (Qs |> List.last) table i]
2018-12-11 16:54:22 -         i <- i + 1
2018-12-11 16:54:22 -     Ys
2018-12-11 16:54:23 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:54:23 -         (points |> List.take N) |> Util.Table
2018-12-11 16:54:23 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:54:23 - list1 is 2 elements shorter than list2
2018-12-11 16:54:23 - Parameter name: list1
2018-12-11 16:54:23 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:54:23 - list1 is 2 elements shorter than list2
2018-12-11 16:54:23 - Parameter name: list1
2018-12-11 16:54:23 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:23 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:23 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:23 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:23 -   at <StartupCode$FSI_0232>.$FSI_0232.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:54:23 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:54:23 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:54:51 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:54:51 -         points |> Util.Table
2018-12-11 16:54:51 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:54:51 - list1 is 1 element shorter than list2
2018-12-11 16:54:51 - Parameter name: list1
2018-12-11 16:54:51 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:54:51 - list1 is 1 element shorter than list2
2018-12-11 16:54:51 - Parameter name: list1
2018-12-11 16:54:51 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:51 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:51 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:51 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:54:51 -   at <StartupCode$FSI_0233>.$FSI_0233.main@ () [0x0000f] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:54:51 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:54:51 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:55:14 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:55:14 -         (points |> List.take N) |> Util.Table
2018-12-11 16:55:14 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:55:14 - list1 is 2 elements shorter than list2
2018-12-11 16:55:14 - Parameter name: list1
2018-12-11 16:55:14 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:55:14 - list1 is 2 elements shorter than list2
2018-12-11 16:55:14 - Parameter name: list1
2018-12-11 16:55:14 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:14 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:14 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:14 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:14 -   at <StartupCode$FSI_0234>.$FSI_0234.main@ () [0x00019] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:55:14 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:55:14 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:55:20 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:55:20 -         (points |> List.take ) |> Util.Table
2018-12-11 16:55:20 - Type mismatch. Expecting a
2018-12-11 16:55:20 -     'float list -> float list'    
2018-12-11 16:55:20 - but given a
2018-12-11 16:55:20 -     'int -> obj list -> obj list'    
2018-12-11 16:55:20 - The type 'float list' does not match the type 'int'
2018-12-11 16:55:26 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:55:26 -         points |> Util.Table
2018-12-11 16:55:26 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:55:26 - list1 is 1 element shorter than list2
2018-12-11 16:55:26 - Parameter name: list1
2018-12-11 16:55:26 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:55:26 - list1 is 1 element shorter than list2
2018-12-11 16:55:26 - Parameter name: list1
2018-12-11 16:55:26 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:26 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:26 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:26 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:26 -   at <StartupCode$FSI_0236>.$FSI_0236.main@ () [0x0000f] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:55:26 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:55:26 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:55:39 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-11 16:55:39 -         points |> List.skip 1 |> Util.Table
2018-12-11 16:55:39 - Expression evaluation failed: The lists had different lengths.
2018-12-11 16:55:39 - list1 is 1 element shorter than list2
2018-12-11 16:55:39 - Parameter name: list1
2018-12-11 16:55:39 - ArgumentExceptionThe lists had different lengths.
2018-12-11 16:55:39 - list1 is 1 element shorter than list2
2018-12-11 16:55:39 - Parameter name: list1
2018-12-11 16:55:39 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:39 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:39 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:39 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-11 16:55:39 -   at <StartupCode$FSI_0237>.$FSI_0237.main@ () [0x00014] in <b74b6ec0fce549349c62711e55ad9b68>:0 
2018-12-11 16:55:39 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-11 16:55:39 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-11 16:58:14 - let ts = [-0.906179845938664; -0.538469310105683; 0.; 0.538469310105683; 0.906179845938664]
2018-12-11 16:58:14 - let As = [0.236926885056189; 0.478628670499366; 0.568888888888889; 0.478628670499366; 0.236926885056189]
2018-12-11 16:58:14 - let a = 0.
2018-12-11 16:58:14 - let b = 1.
2018-12-11 16:58:14 - let N = 2
2018-12-11 16:58:14 - let h = (b - a) / 2. / float N
2018-12-11 16:58:14 - let n = 5
2018-12-11 16:58:14 - let f x = 1. / (x ** 2. + 4.)
2018-12-11 16:58:14 - let gauss = (b - a) / 2. * (List.fold2 (fun acc t A -> acc + A * f ((b - a) / 2. * t + (b + a) / 2.)) 0. ts As)
2018-12-11 16:58:15 - let exact = atan (1. / 2.) / 2.
2018-12-11 16:58:15 - abs (exact - gauss)
2018-12-11 16:58:25 - let xk k = a + k * h
2018-12-11 16:58:25 - let simpson = 
2018-12-11 16:58:25 -     let term n =
2018-12-11 16:58:25 -         match n % 2 = 0 with
2018-12-11 16:58:25 -         | true  -> 2. * f (xk (float n))
2018-12-11 16:58:25 -         | false -> 4. * f (xk (float n))
2018-12-11 16:58:25 -     h / 3. * (f (xk 0.) + f (xk (2. * (float N))) 
2018-12-11 16:58:25 -         + ([1 .. 2 * N - 1] |> List.fold (fun acc k -> acc + term k) 0.))
2018-12-11 16:58:26 - abs (exact - simpson)
2018-12-11 16:59:04 - let f x = exp(x)*sqrt(1. - x)
2018-12-11 16:59:04 - let realAnswer = 1.030078469278704975539089925665950448932564589318472524730
2018-12-11 16:59:04 - let xs = [0.; 0.5; 1.]
2018-12-11 16:59:04 - let As = [0.171429; 4. / 3.; 0.0380952]
2018-12-11 16:59:04 - let interpol = List.fold2 (fun acc A x -> acc + A * f x) 0. As xs
2018-12-11 16:59:05 - abs (realAnswer - interpol)
2018-12-11 16:59:06 - let xs = [0.099194; 0.45013; 0.83529]
2018-12-11 16:59:06 - let As = [0.233281; 0.307603; 0.125783]
2018-12-11 16:59:07 - let greatAST = List.fold2 (fun acc A x -> acc + A * f x) 0. As xs
2018-12-11 16:59:07 - abs (realAnswer - greatAST)
2018-12-11 18:08:11 - shutdown request
2018-12-11 18:08:12 - shutdown request
2018-12-11 18:08:16 - shutdown request
2018-12-11 18:08:17 - shutdown request
2018-12-13 09:50:18 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-13 09:50:18 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-13 09:50:18 - For help type #help;;
2018-12-13 09:50:18 - > val it :
2018-12-13 09:50:18 -   ResizeArray<System.Type *
2018-12-13 09:50:18 -               (obj ->
2018-12-13 09:50:18 -                  seq<string *
2018-12-13 09:50:18 -                      string> *
2018-12-13 09:50:18 -                  string)>
2018-12-13 09:50:18 - = seq []
2018-12-13 09:50:18 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-13 09:50:18 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-13 09:50:18 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-13 09:50:19 - Reporting 0 opened comms
2018-12-13 09:51:51 - let f (x : float) (y : float) = (x + y) / (y - x)
2018-12-13 09:51:51 - let x0 = 0.
2018-12-13 09:51:51 - let y0 = 1.
2018-12-13 09:51:51 - let a = x0
2018-12-13 09:51:51 - let b = x0 + 1.
2018-12-13 09:51:52 - let N = 100
2018-12-13 09:51:52 - let h = (b - a) / float N
2018-12-13 09:51:52 - let points = [a .. h .. b]
2018-12-13 09:51:54 - let exact x = sqrt(1. + 2. * x ** 2.) + x
2018-12-13 09:51:55 - type tableRow = {Точка: float; Значение: float; Погрешность: float}
2018-12-13 09:51:55 - let euler1 = 
2018-12-13 09:51:55 -     points 
2018-12-13 09:51:55 -     |> List.take (points.Length - 1)
2018-12-13 09:51:55 -     |> List.mapFold (fun acc x -> 
2018-12-13 09:51:55 -                         let res = acc + h * f x acc
2018-12-13 09:51:55 -                         (res, res)) y0
2018-12-13 09:51:55 -     |> fst
2018-12-13 09:51:55 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-13 09:51:55 -         (points |> List.skip 1)
2018-12-13 09:51:55 - euler1 |> Util.Table
2018-12-13 09:51:57 - let euler2 = 
2018-12-13 09:51:57 -     points 
2018-12-13 09:51:57 -     |> List.take (points.Length - 1)
2018-12-13 09:51:57 -     |> List.mapFold (fun acc x -> 
2018-12-13 09:51:57 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-13 09:51:57 -                         (res, res)) y0
2018-12-13 09:51:57 -     |> fst
2018-12-13 09:51:57 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 09:51:57 -         (points |> List.skip 1)
2018-12-13 09:51:58 - euler2 |> Util.Table
2018-12-13 09:51:59 - let euler3 = 
2018-12-13 09:51:59 -     let overY x y = y + h * f x y
2018-12-13 09:51:59 -     let rec euler3Internal acc l = 
2018-12-13 09:51:59 -         match l with
2018-12-13 09:51:59 -         | first :: second :: t -> 
2018-12-13 09:51:59 -             let y = List.head acc
2018-12-13 09:51:59 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-13 09:51:59 -             euler3Internal newAcc (second :: t)
2018-12-13 09:51:59 -         |[] |[_] -> acc |> List.rev |> List.skip 1
2018-12-13 09:51:59 -     euler3Internal [y0] points
2018-12-13 09:51:59 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 09:51:59 -         (points |> List.skip 1)
2018-12-13 09:52:00 - euler3 |> Util.Table
2018-12-13 09:52:02 - let rungekut = 
2018-12-13 09:52:02 -     points 
2018-12-13 09:52:02 -     |> List.take (points.Length - 1)
2018-12-13 09:52:02 -     |> List.mapFold (fun acc x -> 
2018-12-13 09:52:02 -                         let k1 = h * f x acc
2018-12-13 09:52:02 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-13 09:52:02 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-13 09:52:02 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-13 09:52:02 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-13 09:52:02 -                         (res, res)) y0
2018-12-13 09:52:02 -     |> fst
2018-12-13 09:52:02 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 09:52:02 -         (points |> List.skip 1)
2018-12-13 09:52:02 - rungekut |> Util.Table
2018-12-13 09:54:19 - let q x y = h * f x y
2018-12-13 09:54:20 - let firstKPoints k =
2018-12-13 09:54:20 -     y0 :: (points 
2018-12-13 09:54:20 -     |> List.take (k - 1)
2018-12-13 09:54:20 -     |> List.mapFold (fun acc x -> 
2018-12-13 09:54:20 -                         let k1 = h * f x acc
2018-12-13 09:54:20 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-13 09:54:20 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-13 09:54:20 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-13 09:54:20 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-13 09:54:20 -                         (res, res)) y0
2018-12-13 09:54:20 -     |> fst)
2018-12-13 09:54:23 - let ys = firstKPoints 5
2018-12-13 09:54:23 - let fourQ = points |> List.take 5 |> List.map2 (q) (ys)
2018-12-13 09:54:24 - let finiteDifferencesTable (Qs : float list) = 
2018-12-13 09:54:24 -     let rec computeCells y acc = 
2018-12-13 09:54:24 -         let computeCol (prevCol : float list) =
2018-12-13 09:54:24 -             let rec computeColInternal x acc =
2018-12-13 09:54:24 -                 match x with
2018-12-13 09:54:24 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-13 09:54:24 -                 | _ -> acc
2018-12-13 09:54:24 -             computeColInternal y [] 
2018-12-13 09:54:24 -         match y with
2018-12-13 09:54:24 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-13 09:54:24 -         |_ -> List.rev acc
2018-12-13 09:54:24 -     computeCells (Qs.Length - 1) [Qs]
2018-12-13 09:54:25 - let first4Table = finiteDifferencesTable fourQ
2018-12-13 09:54:25 - first4Table
2018-12-13 09:58:53 - ys
2018-12-13 09:58:54 - let adams =
2018-12-13 09:58:54 -     let new_y y (table : float list list) = 
2018-12-13 09:58:54 -                     y + 
2018-12-13 09:58:54 -                     (table.[0] |> List.last) + 
2018-12-13 09:58:54 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-13 09:58:54 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-13 09:58:54 -                     3. / 8. * (table.[3] |> List.last) +
2018-12-13 09:58:54 -                     251. / 720. * (table.[4] |> List.last)
2018-12-13 09:58:54 -     let mutable lastY = ys |> List.last
2018-12-13 09:58:54 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-13 09:58:54 -     let mutable Qs = fourQ
2018-12-13 09:58:54 -     let mutable i = 4
2018-12-13 09:58:54 -     while i < N do
2018-12-13 09:58:54 -         lastY <- Ys |> List.last
2018-12-13 09:58:54 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-13 09:58:54 -         let table = finiteDifferencesTable Qs
2018-12-13 09:58:54 -         Ys <- Ys @ [new_y lastY table]
2018-12-13 09:58:54 -         i <- i + 1
2018-12-13 09:58:54 -     Ys
2018-12-13 09:58:58 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 09:58:58 -         points |> List.skip 1 |> Util.Table
2018-12-13 09:58:58 - Expression evaluation failed: The lists had different lengths.
2018-12-13 09:58:58 - list1 is 1 element shorter than list2
2018-12-13 09:58:58 - Parameter name: list1
2018-12-13 09:58:58 - ArgumentExceptionThe lists had different lengths.
2018-12-13 09:58:58 - list1 is 1 element shorter than list2
2018-12-13 09:58:58 - Parameter name: list1
2018-12-13 09:58:58 -   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?] (System.String arg1, System.String arg2, System.Int32 diff) [0x00064] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-13 09:58:58 -   at Microsoft.FSharp.Primitives.Basics.List.map2ToFreshConsTail[a,b,c] (Microsoft.FSharp.Collections.FSharpList`1[T] cons, Microsoft.FSharp.Core.OptimizedClosures+FSharpFunc`3[T1,T2,TResult] f, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x0009a] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-13 09:58:58 -   at Microsoft.FSharp.Primitives.Basics.List.map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] xs1, Microsoft.FSharp.Collections.FSharpList`1[T] xs2) [0x00065] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-13 09:58:58 -   at Microsoft.FSharp.Collections.ListModule.Map2[T1,T2,TResult] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] mapping, Microsoft.FSharp.Collections.FSharpList`1[T] list1, Microsoft.FSharp.Collections.FSharpList`1[T] list2) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-13 09:58:58 -   at <StartupCode$FSI_0029>.$FSI_0029.main@ () [0x00014] in <cc22cb8ea40c4f2fac294e649418fef4>:0 
2018-12-13 09:58:58 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-13 09:58:58 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-13 09:59:11 - let adams =
2018-12-13 09:59:11 -     let new_y y (table : float list list) = 
2018-12-13 09:59:11 -                     y + 
2018-12-13 09:59:11 -                     (table.[0] |> List.last) + 
2018-12-13 09:59:11 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-13 09:59:11 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-13 09:59:11 -                     3. / 8. * (table.[3] |> List.last) +
2018-12-13 09:59:11 -                     251. / 720. * (table.[4] |> List.last)
2018-12-13 09:59:11 -     let mutable lastY = ys |> List.last
2018-12-13 09:59:11 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-13 09:59:11 -     let mutable Qs = fourQ
2018-12-13 09:59:11 -     let mutable i = 5
2018-12-13 09:59:11 -     while i < N do
2018-12-13 09:59:11 -         lastY <- Ys |> List.last
2018-12-13 09:59:11 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-13 09:59:11 -         let table = finiteDifferencesTable Qs
2018-12-13 09:59:11 -         Ys <- Ys @ [new_y lastY table]
2018-12-13 09:59:11 -         i <- i + 1
2018-12-13 09:59:11 -     Ys
2018-12-13 09:59:12 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 09:59:12 -         points |> List.skip 1 |> Util.Table
2018-12-13 10:01:29 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 10:01:29 -         points |> Util.Table
2018-12-13 10:53:42 - (ys |> List.last) + 
2018-12-13 10:53:42 - (first4Table.[0] |> List.last) + 
2018-12-13 10:53:42 - 1. / 2. * (first4Table.[1] |> List.last) +
2018-12-13 10:53:42 - 5. / 12. * (first4Table.[2] |> List.last) +
2018-12-13 10:53:42 - 3. / 8. * (first4Table.[3] |> List.last) +
2018-12-13 10:53:42 - 251. / 720. * (first4Table.[4] |> List.last)
2018-12-13 10:54:40 - let ys = firstKPoints 6
2018-12-13 10:54:40 - let fourQ = points |> List.take 6 |> List.map2 (q) (ys)
2018-12-13 10:54:41 - let finiteDifferencesTable (Qs : float list) = 
2018-12-13 10:54:41 -     let rec computeCells y acc = 
2018-12-13 10:54:41 -         let computeCol (prevCol : float list) =
2018-12-13 10:54:41 -             let rec computeColInternal x acc =
2018-12-13 10:54:41 -                 match x with
2018-12-13 10:54:41 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-13 10:54:41 -                 | _ -> acc
2018-12-13 10:54:41 -             computeColInternal y [] 
2018-12-13 10:54:41 -         match y with
2018-12-13 10:54:41 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-13 10:54:41 -         |_ -> List.rev acc
2018-12-13 10:54:41 -     computeCells (Qs.Length - 1) [Qs]
2018-12-13 10:54:42 - let first4Table = finiteDifferencesTable fourQ
2018-12-13 10:54:42 - first4Table
2018-12-13 10:54:46 - (ys |> List.last) + 
2018-12-13 10:54:46 - (first4Table.[0] |> List.last) + 
2018-12-13 10:54:46 - 1. / 2. * (first4Table.[1] |> List.last) +
2018-12-13 10:54:46 - 5. / 12. * (first4Table.[2] |> List.last) +
2018-12-13 10:54:46 - 3. / 8. * (first4Table.[3] |> List.last) +
2018-12-13 10:54:46 - 251. / 720. * (first4Table.[4] |> List.last)
2018-12-13 10:54:58 - let adams =
2018-12-13 10:54:58 -     let new_y y (table : float list list) = 
2018-12-13 10:54:58 -                     y + 
2018-12-13 10:54:58 -                     (table.[0] |> List.last) + 
2018-12-13 10:54:58 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-13 10:54:58 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-13 10:54:58 -                     3. / 8. * (table.[3] |> List.last) +
2018-12-13 10:54:58 -                     251. / 720. * (table.[4] |> List.last)
2018-12-13 10:54:58 -     let mutable lastY = ys |> List.last
2018-12-13 10:54:58 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-13 10:54:58 -     let mutable Qs = fourQ
2018-12-13 10:54:58 -     let mutable i = 6
2018-12-13 10:54:58 -     while i < N do
2018-12-13 10:54:58 -         lastY <- Ys |> List.last
2018-12-13 10:54:58 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-13 10:54:58 -         let table = finiteDifferencesTable Qs
2018-12-13 10:54:58 -         Ys <- Ys @ [new_y lastY table]
2018-12-13 10:54:58 -         i <- i + 1
2018-12-13 10:54:58 -     Ys
2018-12-13 10:54:59 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 10:54:59 -         points |> Util.Table
2018-12-13 10:55:37 - let ys = firstKPoints 4
2018-12-13 10:55:37 - let fourQ = points |> List.take 4 |> List.map2 (q) (ys)
2018-12-13 10:55:39 - let finiteDifferencesTable (Qs : float list) = 
2018-12-13 10:55:39 -     let rec computeCells y acc = 
2018-12-13 10:55:39 -         let computeCol (prevCol : float list) =
2018-12-13 10:55:39 -             let rec computeColInternal x acc =
2018-12-13 10:55:39 -                 match x with
2018-12-13 10:55:39 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-13 10:55:39 -                 | _ -> acc
2018-12-13 10:55:39 -             computeColInternal y [] 
2018-12-13 10:55:39 -         match y with
2018-12-13 10:55:39 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-13 10:55:39 -         |_ -> List.rev acc
2018-12-13 10:55:39 -     computeCells (Qs.Length - 1) [Qs]
2018-12-13 10:55:40 - let first4Table = finiteDifferencesTable fourQ
2018-12-13 10:55:40 - first4Table
2018-12-13 10:57:01 - let ys = firstKPoints 4
2018-12-13 10:57:01 - let fourQ = points |> List.take 4 |> List.map2 (q) (ys)
2018-12-13 10:57:04 - let finiteDifferencesTable (Qs : float list) = 
2018-12-13 10:57:04 -     let rec computeCells y acc = 
2018-12-13 10:57:04 -         let computeCol (prevCol : float list) =
2018-12-13 10:57:04 -             let rec computeColInternal x acc =
2018-12-13 10:57:04 -                 match x with
2018-12-13 10:57:04 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-13 10:57:04 -                 | _ -> acc
2018-12-13 10:57:04 -             computeColInternal y [] 
2018-12-13 10:57:04 -         match y with
2018-12-13 10:57:04 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-13 10:57:04 -         |_ -> List.rev acc
2018-12-13 10:57:04 -     computeCells (Qs.Length - 1) [Qs]
2018-12-13 10:57:05 - let first4Table = finiteDifferencesTable fourQ
2018-12-13 10:57:05 - first4Table
2018-12-13 10:57:37 - (ys |> List.last) + 
2018-12-13 10:57:37 - (first4Table.[0] |> List.last) + 
2018-12-13 10:57:37 - 1. / 2. * (first4Table.[1] |> List.last) +
2018-12-13 10:57:37 - 5. / 12. * (first4Table.[2] |> List.last) +
2018-12-13 10:57:37 - 3. / 8. * (first4Table.[3] |> List.last)
2018-12-13 10:57:43 - let adams =
2018-12-13 10:57:43 -     let new_y y (table : float list list) = 
2018-12-13 10:57:43 -                     y + 
2018-12-13 10:57:43 -                     (table.[0] |> List.last) + 
2018-12-13 10:57:43 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-13 10:57:43 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-13 10:57:43 -                     3. / 8. * (table.[3] |> List.last) +
2018-12-13 10:57:43 -                     251. / 720. * (table.[4] |> List.last)
2018-12-13 10:57:43 -     let mutable lastY = ys |> List.last
2018-12-13 10:57:43 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-13 10:57:43 -     let mutable Qs = fourQ
2018-12-13 10:57:43 -     let mutable i = 4
2018-12-13 10:57:43 -     while i < N do
2018-12-13 10:57:43 -         lastY <- Ys |> List.last
2018-12-13 10:57:43 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-13 10:57:43 -         let table = finiteDifferencesTable Qs
2018-12-13 10:57:43 -         Ys <- Ys @ [new_y lastY table]
2018-12-13 10:57:43 -         i <- i + 1
2018-12-13 10:57:43 -     Ys
2018-12-13 10:57:43 - Expression evaluation failed: The index was outside the range of elements in the list.
2018-12-13 10:57:43 - Parameter name: n
2018-12-13 10:57:43 - ArgumentExceptionThe index was outside the range of elements in the list.
2018-12-13 10:57:43 - Parameter name: n
2018-12-13 10:57:43 -   at Microsoft.FSharp.Collections.PrivateListHelpers.nth[a] (Microsoft.FSharp.Collections.FSharpList`1[T] l, System.Int32 n) [0x0005e] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-13 10:57:43 -   at Microsoft.FSharp.Collections.FSharpList`1[T].get_Item (System.Int32 index) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-12-13 10:57:43 -   at FSI_0056.new_y@2-3 (System.Double y, Microsoft.FSharp.Collections.FSharpList`1[T] table) [0x0008e] in <cc22cb8ea40c4f2fac294e649418fef4>:0 
2018-12-13 10:57:43 -   at <StartupCode$FSI_0056>.$FSI_0056.main@ () [0x0001e] in <cc22cb8ea40c4f2fac294e649418fef4>:0 
2018-12-13 10:57:43 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-12-13 10:57:43 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0003b] in <0f8aeac9d63d4b8aa575761bb4e65b79>:0 
2018-12-13 10:57:48 - let adams =
2018-12-13 10:57:48 -     let new_y y (table : float list list) = 
2018-12-13 10:57:48 -                     y + 
2018-12-13 10:57:48 -                     (table.[0] |> List.last) + 
2018-12-13 10:57:48 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-13 10:57:48 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-13 10:57:48 -                     3. / 8. * (table.[3] |> List.last)
2018-12-13 10:57:48 -     let mutable lastY = ys |> List.last
2018-12-13 10:57:48 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-13 10:57:48 -     let mutable Qs = fourQ
2018-12-13 10:57:48 -     let mutable i = 4
2018-12-13 10:57:48 -     while i < N do
2018-12-13 10:57:48 -         lastY <- Ys |> List.last
2018-12-13 10:57:48 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-13 10:57:48 -         let table = finiteDifferencesTable Qs
2018-12-13 10:57:48 -         Ys <- Ys @ [new_y lastY table]
2018-12-13 10:57:48 -         i <- i + 1
2018-12-13 10:57:48 -     Ys
2018-12-13 10:57:49 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 10:57:49 -         points |> Util.Table
2018-12-13 10:58:49 - let ys = firstKPoints 6
2018-12-13 10:58:49 - let fourQ = points |> List.take 6 |> List.map2 (q) (ys)
2018-12-13 10:58:51 - let finiteDifferencesTable (Qs : float list) = 
2018-12-13 10:58:51 -     let rec computeCells y acc = 
2018-12-13 10:58:51 -         let computeCol (prevCol : float list) =
2018-12-13 10:58:51 -             let rec computeColInternal x acc =
2018-12-13 10:58:51 -                 match x with
2018-12-13 10:58:51 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-13 10:58:51 -                 | _ -> acc
2018-12-13 10:58:51 -             computeColInternal y [] 
2018-12-13 10:58:51 -         match y with
2018-12-13 10:58:51 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-13 10:58:51 -         |_ -> List.rev acc
2018-12-13 10:58:51 -     computeCells (Qs.Length - 1) [Qs]
2018-12-13 10:58:51 - let first4Table = finiteDifferencesTable fourQ
2018-12-13 10:58:51 - first4Table
2018-12-13 10:58:56 - (ys |> List.last) + 
2018-12-13 10:58:56 - (first4Table.[0] |> List.last) + 
2018-12-13 10:58:56 - 1. / 2. * (first4Table.[1] |> List.last) +
2018-12-13 10:58:56 - 5. / 12. * (first4Table.[2] |> List.last) +
2018-12-13 10:58:56 - 3. / 8. * (first4Table.[3] |> List.last) +
2018-12-13 10:58:56 - 251. / 720. * (first4Table.[4] |> List.last)
2018-12-13 10:59:19 - ys
2018-12-13 11:03:13 - let ys = firstKPoints 5
2018-12-13 11:03:13 - let fourQ = ys |> List.map2 (q) (points |> List.take 5)
2018-12-13 11:03:16 - let finiteDifferencesTable (Qs : float list) = 
2018-12-13 11:03:16 -     let rec computeCells y acc = 
2018-12-13 11:03:16 -         let computeCol (prevCol : float list) =
2018-12-13 11:03:16 -             let rec computeColInternal x acc =
2018-12-13 11:03:16 -                 match x with
2018-12-13 11:03:16 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-13 11:03:16 -                 | _ -> acc
2018-12-13 11:03:16 -             computeColInternal y [] 
2018-12-13 11:03:16 -         match y with
2018-12-13 11:03:16 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-13 11:03:16 -         |_ -> List.rev acc
2018-12-13 11:03:16 -     computeCells (Qs.Length - 1) [Qs]
2018-12-13 11:03:17 - let first4Table = finiteDifferencesTable fourQ
2018-12-13 11:03:17 - first4Table
2018-12-13 11:03:21 - ys
2018-12-13 11:03:25 - (ys |> List.last) + 
2018-12-13 11:03:25 - (first4Table.[0] |> List.last) + 
2018-12-13 11:03:25 - 1. / 2. * (first4Table.[1] |> List.last) +
2018-12-13 11:03:25 - 5. / 12. * (first4Table.[2] |> List.last) +
2018-12-13 11:03:25 - 3. / 8. * (first4Table.[3] |> List.last) +
2018-12-13 11:03:25 - 251. / 720. * (first4Table.[4] |> List.last)
2018-12-13 11:03:32 - let adams =
2018-12-13 11:03:32 -     let new_y y (table : float list list) = 
2018-12-13 11:03:32 -                     y + 
2018-12-13 11:03:32 -                     (table.[0] |> List.last) + 
2018-12-13 11:03:32 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-13 11:03:32 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-13 11:03:32 -                     3. / 8. * (table.[3] |> List.last) +
2018-12-13 11:03:32 -                     251. / 720. * (table.[4] |> List.last)
2018-12-13 11:03:32 -     let mutable lastY = ys |> List.last
2018-12-13 11:03:32 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-13 11:03:32 -     let mutable Qs = fourQ
2018-12-13 11:03:32 -     let mutable i = 5
2018-12-13 11:03:32 -     while i < N do
2018-12-13 11:03:32 -         lastY <- Ys |> List.last
2018-12-13 11:03:32 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-13 11:03:32 -         let table = finiteDifferencesTable Qs
2018-12-13 11:03:32 -         Ys <- Ys @ [new_y lastY table]
2018-12-13 11:03:32 -         i <- i + 1
2018-12-13 11:03:32 -     Ys
2018-12-13 11:03:33 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 11:03:33 -         points |> Util.Table
2018-12-13 12:46:37 - shutdown request
2018-12-13 12:46:50 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-13 12:46:50 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-13 12:46:50 - For help type #help;;
2018-12-13 12:46:50 - > val it :
2018-12-13 12:46:50 -   ResizeArray<System.Type *
2018-12-13 12:46:50 -               (obj ->
2018-12-13 12:46:50 -                  seq<string *
2018-12-13 12:46:50 -                      string> *
2018-12-13 12:46:50 -                  string)>
2018-12-13 12:46:50 - = seq []
2018-12-13 12:46:50 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-13 12:46:50 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-13 12:46:50 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-13 12:46:51 - Reporting 0 opened comms
2018-12-13 12:50:00 - type Result = {Метод : string; Количество итераций: int; Погрешность: float}
2018-12-13 12:50:00 - Unexpected identifier in field declaration. Expected ':' or other token.
2018-12-13 12:50:14 - type Result = {Метод : string; `Количество итераций`: int; Погрешность: float}
2018-12-13 12:50:14 - Unexpected reserved keyword in field declaration. Expected identifier or other token.
2018-12-13 12:50:34 - type Result = {Метод : string; ``Количество итераций``: int; Погрешность: float}
2018-12-13 13:01:20 - let printStat a b e exact = 
2018-12-13 13:01:20 -     let getRes meth name = 
2018-12-13 13:01:20 -         let prediction, iters = meth a b e
2018-12-13 13:01:20 -         {Метод = name; ``Количество итераций`` = iters; Погрешность = abs(prediction - exact)}
2018-12-13 13:01:20 -     [getRes newton1 "Метод касательных";
2018-12-13 13:01:20 -     getRes newton2 "Метод секущих";
2018-12-13 13:01:20 -     getRes newton3 "Метод хорд";
2018-12-13 13:01:20 -     getRes iter "Метод простой итерации"] |> Util.Table
2018-12-13 13:01:20 - The value or constructor 'newton1' is not defined.
2018-12-13 13:01:20 - The value or constructor 'newton2' is not defined.
2018-12-13 13:01:20 - The value or constructor 'newton3' is not defined.
2018-12-13 13:01:20 - The value or constructor 'iter' is not defined. Maybe you want one of the following:
2018-12-13 13:01:20 -    Interop
2018-12-13 13:01:20 -    it
2018-12-13 13:01:20 -    Internal
2018-12-13 13:01:26 - let f(x)   = exp(x) - 6.*x - 3.
2018-12-13 13:01:26 - let f'(x)  = exp(x) - 6.
2018-12-13 13:01:26 - let f''(x) = exp(x)
2018-12-13 13:01:27 - #load "XPlot.Plotly.Paket.fsx"
2018-12-13 13:01:27 - #load "XPlot.Plotly.fsx"
2018-12-13 13:01:27 - open XPlot.Plotly
2018-12-13 13:01:27 - open System
2018-12-13 13:01:31 - let x = [-1. .. 0.01 .. 3.5]
2018-12-13 13:01:31 - let trace1 =
2018-12-13 13:01:31 -     let y = x |> List.map f
2018-12-13 13:01:31 -     Scatter(
2018-12-13 13:01:31 -         x = x,
2018-12-13 13:01:31 -         y = y,
2018-12-13 13:01:31 -         name = "Исходная функция"
2018-12-13 13:01:31 -     )        
2018-12-13 13:01:31 - [trace1]
2018-12-13 13:01:31 - |> Chart.Plot
2018-12-13 13:01:31 - |> Chart.WithWidth 1000
2018-12-13 13:01:31 - |> Chart.WithHeight 700
2018-12-13 13:01:31 - let newton meth a b e =
2018-12-13 13:01:31 -     let x0 = 
2018-12-13 13:01:31 -         match f(a) * f''(a) > 0. with
2018-12-13 13:01:31 -         |true -> a
2018-12-13 13:01:31 -         |false -> b
2018-12-13 13:01:31 -     let rec newtonInternal pred cur i =
2018-12-13 13:01:31 -         match abs (cur - pred) < e with
2018-12-13 13:01:31 -         |true -> (cur, i)
2018-12-13 13:01:31 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-13 13:01:31 -     newtonInternal 0. x0 0
2018-12-13 13:01:31 - let newton1 = (fun pred _ -> pred - f pred / f' pred) |> newton
2018-12-13 13:01:31 - newton1 -0.5 0. 0.00000000001
2018-12-13 13:01:31 - let newton2 = (fun pred cur -> cur - f cur * (cur - pred) / (f cur - f pred)) |> newton
2018-12-13 13:01:31 - newton2 -0.5 0. 0.00000000001
2018-12-13 13:01:31 - let newton3 a b e =
2018-12-13 13:01:31 -     let func = 
2018-12-13 13:01:31 -         match f b > 0. with 
2018-12-13 13:01:31 -         |true -> (fun _ cur -> cur - f cur * (b + 2. * e - cur) / (f (b + 2. * e) - f cur))
2018-12-13 13:01:31 -         |false -> (fun _ cur -> cur - f cur * (cur - (a - 2. * e)) / (f cur - f (a - 2. * e)))
2018-12-13 13:01:31 -     newton func a b e
2018-12-13 13:01:32 - newton3 -0.5 0. 0.00000000001
2018-12-13 13:01:34 - let iter a b e =
2018-12-13 13:01:34 -     let list_f' = [a .. 0.01 .. b] |> List.map f'
2018-12-13 13:01:34 -     let m1 = list_f' |> List.minBy (abs)
2018-12-13 13:01:34 -     let M1 = list_f' |> List.maxBy (abs)
2018-12-13 13:01:34 -     let q = 1. - m1 / M1
2018-12-13 13:01:34 -     let fi x = x - f x / M1
2018-12-13 13:01:34 -     let rec iterInternal pred cur i =
2018-12-13 13:01:34 -         match q * abs (cur - pred) / (1. - q) < e with
2018-12-13 13:01:34 -         |true -> (cur, i)
2018-12-13 13:01:34 -         |false -> iterInternal cur (fi cur) (i + 1)
2018-12-13 13:01:34 -     iterInternal b (fi b) 1
2018-12-13 13:01:34 - iter -0.5 0. 0.00000000001
2018-12-13 13:01:35 - type Result = {Метод : string; ``Количество итераций``: int; Погрешность: float}
2018-12-13 13:01:36 - let printStat a b e exact = 
2018-12-13 13:01:36 -     let getRes meth name = 
2018-12-13 13:01:36 -         let prediction, iters = meth a b e
2018-12-13 13:01:36 -         {Метод = name; ``Количество итераций`` = iters; Погрешность = abs(prediction - exact)}
2018-12-13 13:01:36 -     [getRes newton1 "Метод касательных";
2018-12-13 13:01:36 -     getRes newton2 "Метод секущих";
2018-12-13 13:01:36 -     getRes newton3 "Метод хорд";
2018-12-13 13:01:36 -     getRes iter "Метод простой итерации"] |> Util.Table
2018-12-13 13:02:31 - printStat -0.5 0. 0.001 -0.386795
2018-12-13 13:03:40 - printStat 3. 3.5 0.001 3.0621135
2018-12-13 13:04:17 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-13 13:04:17 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-13 13:04:17 - For help type #help;;
2018-12-13 13:04:17 - > val it :
2018-12-13 13:04:17 -   ResizeArray<System.Type *
2018-12-13 13:04:17 -               (obj ->
2018-12-13 13:04:17 -                  seq<string *
2018-12-13 13:04:17 -                      string> *
2018-12-13 13:04:17 -                  string)>
2018-12-13 13:04:17 - = seq []
2018-12-13 13:04:17 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-13 13:04:17 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-13 13:04:17 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-13 13:12:07 - let f(x)   = exp(x) - 6.*x - 3.
2018-12-13 13:12:07 - let f'(x)  = exp(x) - 6.
2018-12-13 13:12:07 - let f''(x) = exp(x)
2018-12-13 13:12:07 - #load "XPlot.Plotly.Paket.fsx"
2018-12-13 13:12:07 - #load "XPlot.Plotly.fsx"
2018-12-13 13:12:07 - open XPlot.Plotly
2018-12-13 13:12:07 - open System
2018-12-13 13:12:10 - let x = [-1. .. 0.01 .. 3.5]
2018-12-13 13:12:10 - let trace1 =
2018-12-13 13:12:10 -     let y = x |> List.map f
2018-12-13 13:12:10 -     Scatter(
2018-12-13 13:12:10 -         x = x,
2018-12-13 13:12:10 -         y = y,
2018-12-13 13:12:10 -         name = "Исходная функция"
2018-12-13 13:12:10 -     )        
2018-12-13 13:12:10 - [trace1]
2018-12-13 13:12:10 - |> Chart.Plot
2018-12-13 13:12:10 - |> Chart.WithWidth 1000
2018-12-13 13:12:10 - |> Chart.WithHeight 700
2018-12-13 13:12:10 - let newton meth a b e =
2018-12-13 13:12:10 -     let x0 = 
2018-12-13 13:12:10 -         match f(a) * f''(a) > 0. with
2018-12-13 13:12:10 -         |true -> a
2018-12-13 13:12:10 -         |false -> b
2018-12-13 13:12:10 -     let rec newtonInternal pred cur i =
2018-12-13 13:12:10 -         match abs (cur - pred) < e with
2018-12-13 13:12:10 -         |true -> (cur, i)
2018-12-13 13:12:10 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-13 13:12:10 -     newtonInternal 0. x0 0
2018-12-13 13:12:10 - let newton1 = (fun pred _ -> pred - f pred / f' pred) |> newton
2018-12-13 13:12:10 - newton1 -0.5 0. 0.00000000001
2018-12-13 13:12:10 - let newton2 = (fun pred cur -> cur - f cur * (cur - pred) / (f cur - f pred)) |> newton
2018-12-13 13:12:11 - newton2 -0.5 0. 0.00000000001
2018-12-13 13:12:12 - let newton3 a b e =
2018-12-13 13:12:12 -     let func = 
2018-12-13 13:12:12 -         match f b > 0. with 
2018-12-13 13:12:12 -         | true -> (fun _ cur -> cur - f cur * (b - 2. * e - cur) / (f (b - 2. * e) - f cur))
2018-12-13 13:12:12 -         | false -> (fun _ cur -> cur - f cur * (cur - (a - 2. * e)) / (f cur - f (a - 2. * e)))
2018-12-13 13:12:12 -     newton func a b e
2018-12-13 13:12:13 - newton3 -0.5 0. 0.00000000001
2018-12-13 13:12:14 - let iter a b e =
2018-12-13 13:12:14 -     let list_f' = [a .. 0.01 .. b] |> List.map f'
2018-12-13 13:12:14 -     let m1 = list_f' |> List.minBy (abs)
2018-12-13 13:12:14 -     let M1 = list_f' |> List.maxBy (abs)
2018-12-13 13:12:14 -     let q = 1. - m1 / M1
2018-12-13 13:12:14 -     let fi x = x - f x / M1
2018-12-13 13:12:14 -     let rec iterInternal pred cur i =
2018-12-13 13:12:14 -         match q * abs (cur - pred) / (1. - q) < e with
2018-12-13 13:12:14 -         |true -> (cur, i)
2018-12-13 13:12:14 -         |false -> iterInternal cur (fi cur) (i + 1)
2018-12-13 13:12:14 -     iterInternal b (fi b) 1
2018-12-13 13:12:15 - iter -0.5 0. 0.00000000001
2018-12-13 13:12:15 - type Result = {Метод : string; ``Количество итераций``: int; Погрешность: float}
2018-12-13 13:12:16 - let printStat a b e exact = 
2018-12-13 13:12:16 -     let getRes meth name = 
2018-12-13 13:12:16 -         let prediction, iters = meth a b e
2018-12-13 13:12:16 -         {Метод = name; ``Количество итераций`` = iters; Погрешность = abs(prediction - exact)}
2018-12-13 13:12:16 -     [getRes newton1 "Метод касательных";
2018-12-13 13:12:16 -     getRes newton2 "Метод секущих";
2018-12-13 13:12:16 -     getRes newton3 "Метод хорд";
2018-12-13 13:12:16 -     getRes iter "Метод простой итерации"] |> Util.Table
2018-12-13 13:12:17 - printStat -0.5 0. 0.001 -0.386795
2018-12-13 13:12:17 - printStat 3. 3.5 0.001 3.0621135
2018-12-13 13:13:02 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-13 13:13:02 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-13 13:13:02 - For help type #help;;
2018-12-13 13:13:02 - > val it :
2018-12-13 13:13:02 -   ResizeArray<System.Type *
2018-12-13 13:13:02 -               (obj ->
2018-12-13 13:13:02 -                  seq<string *
2018-12-13 13:13:02 -                      string> *
2018-12-13 13:13:02 -                  string)>
2018-12-13 13:13:02 - = seq []
2018-12-13 13:13:02 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-13 13:13:02 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-13 13:13:02 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-13 13:15:00 - newton2 3. 3.5 0.001
2018-12-13 13:15:00 - The value or constructor 'newton2' is not defined.
2018-12-13 13:15:04 - let f(x)   = exp(x) - 6.*x - 3.
2018-12-13 13:15:04 - let f'(x)  = exp(x) - 6.
2018-12-13 13:15:04 - let f''(x) = exp(x)
2018-12-13 13:15:05 - #load "XPlot.Plotly.Paket.fsx"
2018-12-13 13:15:05 - #load "XPlot.Plotly.fsx"
2018-12-13 13:15:05 - open XPlot.Plotly
2018-12-13 13:15:05 - open System
2018-12-13 13:15:08 - let x = [-1. .. 0.01 .. 3.5]
2018-12-13 13:15:08 - let trace1 =
2018-12-13 13:15:08 -     let y = x |> List.map f
2018-12-13 13:15:08 -     Scatter(
2018-12-13 13:15:08 -         x = x,
2018-12-13 13:15:08 -         y = y,
2018-12-13 13:15:08 -         name = "Исходная функция"
2018-12-13 13:15:08 -     )        
2018-12-13 13:15:08 - [trace1]
2018-12-13 13:15:08 - |> Chart.Plot
2018-12-13 13:15:08 - |> Chart.WithWidth 1000
2018-12-13 13:15:08 - |> Chart.WithHeight 700
2018-12-13 13:15:08 - let newton meth a b e =
2018-12-13 13:15:08 -     let x0 = 
2018-12-13 13:15:08 -         match f(a) * f''(a) > 0. with
2018-12-13 13:15:08 -         |true -> a
2018-12-13 13:15:08 -         |false -> b
2018-12-13 13:15:08 -     let rec newtonInternal pred cur i =
2018-12-13 13:15:08 -         match abs (cur - pred) < e with
2018-12-13 13:15:08 -         |true -> (cur, i)
2018-12-13 13:15:08 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-13 13:15:08 -     newtonInternal 0. x0 0
2018-12-13 13:15:08 - let newton1 = (fun pred _ -> pred - f pred / f' pred) |> newton
2018-12-13 13:15:12 - newton1 -0.5 0. 0.00000000001
2018-12-13 13:15:13 - let newton2 = (fun pred cur -> cur - f cur * (cur - pred) / (f cur - f pred)) |> newton
2018-12-13 13:15:13 - newton2 -0.5 0. 0.00000000001
2018-12-13 13:15:13 - newton2 3. 3.5 0.001
2018-12-13 13:15:47 - let newton3 a b e =
2018-12-13 13:15:47 -     let func = 
2018-12-13 13:15:47 -         match f b > 0. with 
2018-12-13 13:15:47 -         | true -> (fun _ cur -> cur - f cur * (b - 2. * e - cur) / (f (b - 2. * e) - f cur))
2018-12-13 13:15:47 -         | false -> (fun _ cur -> cur - f cur * (cur - (a - 2. * e)) / (f cur - f (a - 2. * e)))
2018-12-13 13:15:47 -     newton func a b e
2018-12-13 13:15:48 - newton3 -0.5 0. 0.00000000001
2018-12-13 13:15:52 - newton3 3. 3.5 0.001
2018-12-13 13:15:55 - newton2 3. 3.5 0.001
2018-12-13 13:16:10 - newton1 3. 3.5 0.001
2018-12-13 13:16:23 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-13 13:16:23 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-13 13:16:23 - For help type #help;;
2018-12-13 13:16:23 - > val it :
2018-12-13 13:16:23 -   ResizeArray<System.Type *
2018-12-13 13:16:23 -               (obj ->
2018-12-13 13:16:23 -                  seq<string *
2018-12-13 13:16:23 -                      string> *
2018-12-13 13:16:23 -                  string)>
2018-12-13 13:16:23 - = seq []
2018-12-13 13:16:23 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-13 13:16:23 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-13 13:16:23 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-13 13:24:35 - let f(x)   = exp(x) - 6.*x - 3.
2018-12-13 13:24:35 - let f'(x)  = exp(x) - 6.
2018-12-13 13:24:35 - let f''(x) = exp(x)
2018-12-13 13:24:35 - #load "XPlot.Plotly.Paket.fsx"
2018-12-13 13:24:35 - #load "XPlot.Plotly.fsx"
2018-12-13 13:24:35 - open XPlot.Plotly
2018-12-13 13:24:35 - open System
2018-12-13 13:24:38 - let x = [-1. .. 0.01 .. 3.5]
2018-12-13 13:24:38 - let trace1 =
2018-12-13 13:24:38 -     let y = x |> List.map f
2018-12-13 13:24:38 -     Scatter(
2018-12-13 13:24:38 -         x = x,
2018-12-13 13:24:38 -         y = y,
2018-12-13 13:24:38 -         name = "Исходная функция"
2018-12-13 13:24:38 -     )        
2018-12-13 13:24:38 - [trace1]
2018-12-13 13:24:38 - |> Chart.Plot
2018-12-13 13:24:38 - |> Chart.WithWidth 1000
2018-12-13 13:24:38 - |> Chart.WithHeight 700
2018-12-13 13:24:38 - let newton meth a b e =
2018-12-13 13:24:38 -     let x0 = 
2018-12-13 13:24:38 -         match f(a) * f''(a) > 0. with
2018-12-13 13:24:38 -         |true -> a
2018-12-13 13:24:38 -         |false -> b
2018-12-13 13:24:38 -     let rec newtonInternal pred cur i =
2018-12-13 13:24:38 -         match abs (cur - pred) < e with
2018-12-13 13:24:38 -         |true -> (cur, i)
2018-12-13 13:24:38 -         |false -> newtonInternal cur (meth pred cur) (i + 1)
2018-12-13 13:24:38 -     newtonInternal 0. x0 0
2018-12-13 13:24:38 - let newton1 = (fun _ cur -> cur - f cur / f' cur) |> newton
2018-12-13 13:24:38 - newton1 -0.5 0. 0.00000000001
2018-12-13 13:24:41 - newton1 3. 3.5 0.001
2018-12-13 13:24:44 - let newton2 a b e = 
2018-12-13 13:24:44 -     let x0 = 
2018-12-13 13:24:44 -         match f(a) * f''(a) > 0. with
2018-12-13 13:24:44 -         |true -> a
2018-12-13 13:24:44 -         |false -> b
2018-12-13 13:24:44 -     let rec newtonInternal pred cur i =
2018-12-13 13:24:44 -         match abs (cur - pred) < e with
2018-12-13 13:24:44 -         |true -> (cur, i)
2018-12-13 13:24:44 -         |false -> newtonInternal cur (cur - f cur * (cur - pred) / (f cur - f pred)) (i + 1)
2018-12-13 13:24:44 -     newtonInternal x0 (x0 - f x0 / f' x0) 1
2018-12-13 13:24:45 - newton2 -0.5 0. 0.00000000001
2018-12-13 13:24:46 - newton2 3. 3.5 0.001
2018-12-13 13:24:52 - let newton3 a b e =
2018-12-13 13:24:52 -     let func = 
2018-12-13 13:24:52 -         match f b > 0. with 
2018-12-13 13:24:52 -         | true -> (fun _ cur -> cur - f cur * (b - 2. * e - cur) / (f (b - 2. * e) - f cur))
2018-12-13 13:24:52 -         | false -> (fun _ cur -> cur - f cur * (cur - (a - 2. * e)) / (f cur - f (a - 2. * e)))
2018-12-13 13:24:52 -     newton func a b e
2018-12-13 13:24:53 - newton3 -0.5 0. 0.00000000001
2018-12-13 13:24:53 - newton3 3. 3.5 0.001
2018-12-13 13:24:56 - let iter a b e =
2018-12-13 13:24:56 -     let list_f' = [a .. 0.01 .. b] |> List.map f'
2018-12-13 13:24:56 -     let m1 = list_f' |> List.minBy (abs)
2018-12-13 13:24:56 -     let M1 = list_f' |> List.maxBy (abs)
2018-12-13 13:24:56 -     let q = 1. - m1 / M1
2018-12-13 13:24:56 -     let fi x = x - f x / M1
2018-12-13 13:24:56 -     let rec iterInternal pred cur i =
2018-12-13 13:24:56 -         match q * abs (cur - pred) / (1. - q) < e with
2018-12-13 13:24:56 -         |true -> (cur, i)
2018-12-13 13:24:56 -         |false -> iterInternal cur (fi cur) (i + 1)
2018-12-13 13:24:56 -     iterInternal b (fi b) 1
2018-12-13 13:24:56 - iter -0.5 0. 0.00000000001
2018-12-13 13:24:57 - type Result = {Метод : string; ``Количество итераций``: int; Погрешность: float}
2018-12-13 13:24:57 - let printStat a b e exact = 
2018-12-13 13:24:57 -     let getRes meth name = 
2018-12-13 13:24:57 -         let prediction, iters = meth a b e
2018-12-13 13:24:57 -         {Метод = name; ``Количество итераций`` = iters; Погрешность = abs(prediction - exact)}
2018-12-13 13:24:57 -     [getRes newton1 "Метод касательных";
2018-12-13 13:24:57 -     getRes newton2 "Метод секущих";
2018-12-13 13:24:57 -     getRes newton3 "Метод хорд";
2018-12-13 13:24:57 -     getRes iter "Метод простой итерации"] |> Util.Table
2018-12-13 13:24:58 - printStat -0.5 0. 0.001 -0.386795
2018-12-13 13:24:58 - printStat 3. 3.5 0.001 3.0621135
2018-12-13 13:25:58 - printStat 3. 3.5 0.0001 3.0621135
2018-12-13 13:47:31 - Reporting 0 opened comms
2018-12-13 14:05:38 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-13 14:05:38 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-13 14:05:38 - For help type #help;;
2018-12-13 14:05:38 - > val it :
2018-12-13 14:05:38 -   ResizeArray<System.Type *
2018-12-13 14:05:38 -               (obj ->
2018-12-13 14:05:38 -                  seq<string *
2018-12-13 14:05:38 -                      string> *
2018-12-13 14:05:38 -                  string)>
2018-12-13 14:05:38 - = seq []
2018-12-13 14:05:38 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-13 14:05:38 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-13 14:05:38 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-13 14:05:39 - Reporting 0 opened comms
2018-12-13 14:08:00 - let f (x : float) (y : float) = (x + y) / (y - x)
2018-12-13 14:08:00 - let x0 = 0.
2018-12-13 14:08:00 - let y0 = 1.
2018-12-13 14:08:00 - let a = x0
2018-12-13 14:08:00 - let b = x0 + 1.
2018-12-13 14:08:00 - let N = 100
2018-12-13 14:08:00 - let h = (b - a) / float N
2018-12-13 14:08:00 - let points = [a .. h .. b]
2018-12-13 14:08:00 - let exact x = sqrt(1. + 2. * x ** 2.) + x
2018-12-13 14:08:00 - type TableRow = {Точка: float; Значение: float; Погрешность: float}
2018-12-13 14:08:00 - let euler1 = 
2018-12-13 14:08:00 -     points 
2018-12-13 14:08:00 -     |> List.take (points.Length - 1)
2018-12-13 14:08:00 -     |> List.mapFold (fun acc x -> 
2018-12-13 14:08:00 -                         let res = acc + h * f x acc
2018-12-13 14:08:00 -                         (res, res)) y0
2018-12-13 14:08:00 -     |> fst
2018-12-13 14:08:00 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-13 14:08:00 -         (points |> List.skip 1)
2018-12-13 14:08:00 - euler1 |> Util.Table
2018-12-13 14:08:00 - let euler2 = 
2018-12-13 14:08:00 -     points 
2018-12-13 14:08:00 -     |> List.take (points.Length - 1)
2018-12-13 14:08:00 -     |> List.mapFold (fun acc x -> 
2018-12-13 14:08:00 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-13 14:08:00 -                         (res, res)) y0
2018-12-13 14:08:00 -     |> fst
2018-12-13 14:08:00 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 14:08:00 -         (points |> List.skip 1)
2018-12-13 14:08:00 - euler2 |> Util.Table
2018-12-13 14:08:00 - let euler3 = 
2018-12-13 14:08:00 -     let overY x y = y + h * f x y
2018-12-13 14:08:00 -     let rec euler3Internal acc l = 
2018-12-13 14:08:00 -         match l with
2018-12-13 14:08:00 -         | first :: second :: t -> 
2018-12-13 14:08:00 -             let y = List.head acc
2018-12-13 14:08:00 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-13 14:08:00 -             euler3Internal newAcc (second :: t)
2018-12-13 14:08:00 -         |[] |[_] -> acc |> List.rev |> List.skip 1
2018-12-13 14:08:00 -     euler3Internal [y0] points
2018-12-13 14:08:00 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 14:08:00 -         (points |> List.skip 1)
2018-12-13 14:08:00 - euler3 |> Util.Table
2018-12-13 14:08:00 - let rungekut = 
2018-12-13 14:08:00 -     points 
2018-12-13 14:08:00 -     |> List.take (points.Length - 1)
2018-12-13 14:08:00 -     |> List.mapFold (fun acc x -> 
2018-12-13 14:08:00 -                         let k1 = h * f x acc
2018-12-13 14:08:00 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-13 14:08:00 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-13 14:08:00 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-13 14:08:00 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-13 14:08:00 -                         (res, res)) y0
2018-12-13 14:08:00 -     |> fst
2018-12-13 14:08:00 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 14:08:00 -         (points |> List.skip 1)
2018-12-13 14:08:00 - rungekut |> Util.Table
2018-12-13 14:08:01 - let q x y = h * f x y
2018-12-13 14:08:01 - let firstKPoints k =
2018-12-13 14:08:01 -     y0 :: (points 
2018-12-13 14:08:01 -     |> List.take (k - 1)
2018-12-13 14:08:01 -     |> List.mapFold (fun acc x -> 
2018-12-13 14:08:01 -                         let k1 = h * f x acc
2018-12-13 14:08:01 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-13 14:08:01 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-13 14:08:01 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-13 14:08:01 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-13 14:08:01 -                         (res, res)) y0
2018-12-13 14:08:01 -     |> fst)
2018-12-13 14:08:01 - let ys = firstKPoints 5
2018-12-13 14:08:01 - let fourQ = ys |> List.map2 (q) (points |> List.take 5)
2018-12-13 14:08:01 - let finiteDifferencesTable (Qs : float list) = 
2018-12-13 14:08:01 -     let rec computeCells y acc = 
2018-12-13 14:08:01 -         let computeCol (prevCol : float list) =
2018-12-13 14:08:01 -             let rec computeColInternal x acc =
2018-12-13 14:08:01 -                 match x with
2018-12-13 14:08:01 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-13 14:08:01 -                 | _ -> acc
2018-12-13 14:08:01 -             computeColInternal y [] 
2018-12-13 14:08:01 -         match y with
2018-12-13 14:08:01 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-13 14:08:01 -         |_ -> List.rev acc
2018-12-13 14:08:01 -     computeCells (Qs.Length - 1) [Qs]
2018-12-13 14:08:01 - let first4Table = finiteDifferencesTable fourQ
2018-12-13 14:08:01 - first4Table
2018-12-13 14:08:01 - ys
2018-12-13 14:08:01 - (ys |> List.last) + 
2018-12-13 14:08:01 - (first4Table.[0] |> List.last) + 
2018-12-13 14:08:01 - 1. / 2. * (first4Table.[1] |> List.last) +
2018-12-13 14:08:01 - 5. / 12. * (first4Table.[2] |> List.last) +
2018-12-13 14:08:01 - 3. / 8. * (first4Table.[3] |> List.last) +
2018-12-13 14:08:01 - 251. / 720. * (first4Table.[4] |> List.last)
2018-12-13 14:08:01 - let adams =
2018-12-13 14:08:01 -     let new_y y (table : float list list) = 
2018-12-13 14:08:01 -                     y + 
2018-12-13 14:08:01 -                     (table.[0] |> List.last) + 
2018-12-13 14:08:01 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-13 14:08:01 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-13 14:08:01 -                     3. / 8. * (table.[3] |> List.last) +
2018-12-13 14:08:01 -                     251. / 720. * (table.[4] |> List.last)
2018-12-13 14:08:01 -     let mutable lastY = ys |> List.last
2018-12-13 14:08:01 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-13 14:08:01 -     let mutable Qs = fourQ
2018-12-13 14:08:01 -     let mutable i = 5
2018-12-13 14:08:01 -     while i < N do
2018-12-13 14:08:01 -         lastY <- Ys |> List.last
2018-12-13 14:08:01 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-13 14:08:01 -         let table = finiteDifferencesTable Qs
2018-12-13 14:08:01 -         Ys <- Ys @ [new_y lastY table]
2018-12-13 14:08:01 -         i <- i + 1
2018-12-13 14:08:01 -     Ys
2018-12-13 14:08:01 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-13 14:08:01 -         points |> Util.Table
2018-12-13 14:53:07 - printStat 3. 3.5 0.001 3.0621135
2018-12-18 11:34:14 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-18 11:34:14 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-18 11:34:14 - For help type #help;;
2018-12-18 11:34:14 - > val it :
2018-12-18 11:34:14 -   ResizeArray<System.Type *
2018-12-18 11:34:14 -               (obj ->
2018-12-18 11:34:14 -                  seq<string *
2018-12-18 11:34:14 -                      string> *
2018-12-18 11:34:14 -                  string)>
2018-12-18 11:34:14 - = seq []
2018-12-18 11:34:14 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-18 11:34:14 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-18 11:34:14 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-18 11:34:16 - Reporting 0 opened comms
2018-12-18 11:34:47 - let f (x : float) (y : float) = (x + y) / (y - x)
2018-12-18 11:34:47 - let x0 = 0.
2018-12-18 11:34:47 - let y0 = 1.
2018-12-18 11:34:47 - let a = x0
2018-12-18 11:34:47 - let b = x0 + 1.
2018-12-18 11:34:47 - let N = 100
2018-12-18 11:34:47 - let h = (b - a) / float N
2018-12-18 11:34:47 - let points = [a .. h .. b]
2018-12-18 11:34:47 - let exact x = sqrt(1. + 2. * x ** 2.) + x
2018-12-18 11:34:47 - type TableRow = {Точка: float; Значение: float; Погрешность: float}
2018-12-18 11:34:47 - let euler1 = 
2018-12-18 11:34:47 -     points 
2018-12-18 11:34:47 -     |> List.take (points.Length - 1)
2018-12-18 11:34:47 -     |> List.mapFold (fun acc x -> 
2018-12-18 11:34:47 -                         let res = acc + h * f x acc
2018-12-18 11:34:47 -                         (res, res)) y0
2018-12-18 11:34:47 -     |> fst
2018-12-18 11:34:47 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-18 11:34:47 -         (points |> List.skip 1)
2018-12-18 11:34:47 - euler1 |> Util.Table
2018-12-18 11:34:48 - let euler2 = 
2018-12-18 11:34:48 -     points 
2018-12-18 11:34:48 -     |> List.take (points.Length - 1)
2018-12-18 11:34:48 -     |> List.mapFold (fun acc x -> 
2018-12-18 11:34:48 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-18 11:34:48 -                         (res, res)) y0
2018-12-18 11:34:48 -     |> fst
2018-12-18 11:34:48 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:34:48 -         (points |> List.skip 1)
2018-12-18 11:34:48 - euler2 |> Util.Table
2018-12-18 11:34:48 - let euler3 = 
2018-12-18 11:34:48 -     let overY x y = y + h * f x y
2018-12-18 11:34:48 -     let rec euler3Internal acc l = 
2018-12-18 11:34:48 -         match l with
2018-12-18 11:34:48 -         | first :: second :: t -> 
2018-12-18 11:34:48 -             let y = List.head acc
2018-12-18 11:34:48 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-18 11:34:48 -             euler3Internal newAcc (second :: t)
2018-12-18 11:34:48 -         |[] |[_] -> acc |> List.rev |> List.skip 1
2018-12-18 11:34:48 -     euler3Internal [y0] points
2018-12-18 11:34:48 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:34:48 -         (points |> List.skip 1)
2018-12-18 11:34:48 - euler3 |> Util.Table
2018-12-18 11:34:48 - let rungekut = 
2018-12-18 11:34:48 -     points 
2018-12-18 11:34:48 -     |> List.take (points.Length - 1)
2018-12-18 11:34:48 -     |> List.mapFold (fun acc x -> 
2018-12-18 11:34:48 -                         let k1 = h * f x acc
2018-12-18 11:34:48 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-18 11:34:48 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-18 11:34:48 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-18 11:34:48 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-18 11:34:48 -                         (res, res)) y0
2018-12-18 11:34:48 -     |> fst
2018-12-18 11:34:48 -     |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:34:48 -         (points |> List.skip 1)
2018-12-18 11:34:48 - rungekut |> Util.Table
2018-12-18 11:34:48 - let q x y = h * f x y
2018-12-18 11:34:48 - let firstKPoints k =
2018-12-18 11:34:48 -     y0 :: (points 
2018-12-18 11:34:48 -     |> List.take (k - 1)
2018-12-18 11:34:48 -     |> List.mapFold (fun acc x -> 
2018-12-18 11:34:48 -                         let k1 = h * f x acc
2018-12-18 11:34:48 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-18 11:34:48 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-18 11:34:48 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-18 11:34:48 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-18 11:34:48 -                         (res, res)) y0
2018-12-18 11:34:48 -     |> fst)
2018-12-18 11:34:48 - let ys = firstKPoints 5
2018-12-18 11:34:48 - let fourQ = ys |> List.map2 (q) (points |> List.take 5)
2018-12-18 11:34:48 - let finiteDifferencesTable (Qs : float list) = 
2018-12-18 11:34:48 -     let rec computeCells y acc = 
2018-12-18 11:34:48 -         let computeCol (prevCol : float list) =
2018-12-18 11:34:48 -             let rec computeColInternal x acc =
2018-12-18 11:34:48 -                 match x with
2018-12-18 11:34:48 -                 | _ when x > 0 -> computeColInternal (x - 1) ((prevCol.[x] - prevCol.[x - 1]) :: acc)
2018-12-18 11:34:48 -                 | _ -> acc
2018-12-18 11:34:48 -             computeColInternal y [] 
2018-12-18 11:34:48 -         match y with
2018-12-18 11:34:48 -         |_ when y > 0 -> computeCells (y - 1) ((computeCol acc.[0]) :: acc)
2018-12-18 11:34:48 -         |_ -> List.rev acc
2018-12-18 11:34:48 -     computeCells (Qs.Length - 1) [Qs]
2018-12-18 11:34:48 - let first4Table = finiteDifferencesTable fourQ
2018-12-18 11:34:48 - first4Table
2018-12-18 11:34:48 - ys
2018-12-18 11:34:48 - (ys |> List.last) + 
2018-12-18 11:34:48 - (first4Table.[0] |> List.last) + 
2018-12-18 11:34:48 - 1. / 2. * (first4Table.[1] |> List.last) +
2018-12-18 11:34:48 - 5. / 12. * (first4Table.[2] |> List.last) +
2018-12-18 11:34:48 - 3. / 8. * (first4Table.[3] |> List.last) +
2018-12-18 11:34:48 - 251. / 720. * (first4Table.[4] |> List.last)
2018-12-18 11:34:48 - let adams =
2018-12-18 11:34:48 -     let new_y y (table : float list list) = 
2018-12-18 11:34:48 -                     y + 
2018-12-18 11:34:48 -                     (table.[0] |> List.last) + 
2018-12-18 11:34:48 -                     1. / 2. * (table.[1] |> List.last) +
2018-12-18 11:34:48 -                     5. / 12. * (table.[2] |> List.last) +
2018-12-18 11:34:48 -                     3. / 8. * (table.[3] |> List.last) +
2018-12-18 11:34:48 -                     251. / 720. * (table.[4] |> List.last)
2018-12-18 11:34:48 -     let mutable lastY = ys |> List.last
2018-12-18 11:34:48 -     let mutable Ys = ys @ [new_y lastY first4Table]
2018-12-18 11:34:48 -     let mutable Qs = fourQ
2018-12-18 11:34:48 -     let mutable i = 5
2018-12-18 11:34:48 -     while i < N do
2018-12-18 11:34:48 -         lastY <- Ys |> List.last
2018-12-18 11:34:48 -         Qs <- Qs @ [q points.[i] lastY]
2018-12-18 11:34:48 -         let table = finiteDifferencesTable Qs
2018-12-18 11:34:48 -         Ys <- Ys @ [new_y lastY table]
2018-12-18 11:34:48 -         i <- i + 1
2018-12-18 11:34:48 -     Ys
2018-12-18 11:34:48 - adams |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:34:48 -         points |> Util.Table
2018-12-18 11:43:53 - euler1 |> Util.Table
2018-12-18 11:43:53 - euler2 |> Util.Table
2018-12-18 11:45:46 - (euler1, euler2) |> Util.Table
2018-12-18 11:45:46 - Type constraint mismatch. The type 
2018-12-18 11:45:46 -     'TableRow list * TableRow list'    
2018-12-18 11:45:46 - is not compatible with type
2018-12-18 11:45:46 -     'seq<'a>'    
2018-12-18 11:46:08 - euler1 |> Util.Table, euler2 |> Util.Table
2018-12-18 11:46:39 - (euler1 |> Util.Table), (euler2 |> Util.Table)
2018-12-18 11:48:03 - euler1 |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-18 11:48:03 -         (points |> List.skip 1) |> Util.Table
2018-12-18 11:48:03 - This expression was expected to have type
2018-12-18 11:48:03 -     'float'    
2018-12-18 11:48:03 - but here has type
2018-12-18 11:48:03 -     'TableRow'    
2018-12-18 11:48:03 - The type 'float' does not match the type 'TableRow'
2018-12-18 11:48:05 - let euler1 = 
2018-12-18 11:48:05 -     points 
2018-12-18 11:48:05 -     |> List.take (points.Length - 1)
2018-12-18 11:48:05 -     |> List.mapFold (fun acc x -> 
2018-12-18 11:48:05 -                         let res = acc + h * f x acc
2018-12-18 11:48:05 -                         (res, res)) y0
2018-12-18 11:48:05 -     |> fst
2018-12-18 11:48:05 - euler1 |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)})
2018-12-18 11:48:05 -         (points |> List.skip 1) |> Util.Table
2018-12-18 11:48:23 - let euler2 = 
2018-12-18 11:48:23 -     points 
2018-12-18 11:48:23 -     |> List.take (points.Length - 1)
2018-12-18 11:48:23 -     |> List.mapFold (fun acc x -> 
2018-12-18 11:48:23 -                         let res = acc + h * f (x + h / 2.) (acc + h / 2. * f x acc)
2018-12-18 11:48:23 -                         (res, res)) y0
2018-12-18 11:48:23 -     |> fst
2018-12-18 11:48:30 - euler2 |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:48:30 -         (points |> List.skip 1) |> Util.Table
2018-12-18 11:48:41 - euler3 |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:48:41 -         (points |> List.skip 1) |> Util.Table
2018-12-18 11:48:41 - This expression was expected to have type
2018-12-18 11:48:41 -     'float'    
2018-12-18 11:48:41 - but here has type
2018-12-18 11:48:41 -     'TableRow'    
2018-12-18 11:48:41 - The type 'float' does not match the type 'TableRow'
2018-12-18 11:49:17 - let euler3 = 
2018-12-18 11:49:17 -     let overY x y = y + h * f x y
2018-12-18 11:49:17 -     let rec euler3Internal acc l = 
2018-12-18 11:49:17 -         match l with
2018-12-18 11:49:17 -         | first :: second :: t -> 
2018-12-18 11:49:17 -             let y = List.head acc
2018-12-18 11:49:17 -             let newAcc = (y + h / 2. * (f first y + f second (overY first y))) :: acc
2018-12-18 11:49:17 -             euler3Internal newAcc (second :: t)
2018-12-18 11:49:17 -         |[] |[_] -> acc |> List.rev |> List.skip 1
2018-12-18 11:49:17 -     euler3Internal [y0] points
2018-12-18 11:49:17 - euler3 |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:49:17 -         (points |> List.skip 1) |> Util.Table
2018-12-18 11:49:25 - let rungekut = 
2018-12-18 11:49:25 -     points 
2018-12-18 11:49:25 -     |> List.take (points.Length - 1)
2018-12-18 11:49:25 -     |> List.mapFold (fun acc x -> 
2018-12-18 11:49:25 -                         let k1 = h * f x acc
2018-12-18 11:49:25 -                         let k2 = h * f (x + h / 2.) (acc + k1 / 2.)
2018-12-18 11:49:25 -                         let k3 = h * f (x + h / 2.) (acc + k2 / 2.)
2018-12-18 11:49:25 -                         let k4 = h * f (x + h) (acc + k3)
2018-12-18 11:49:25 -                         let res = acc + (k1 + 2. * k2 + 2. * k3 + k4) / 6. 
2018-12-18 11:49:25 -                         (res, res)) y0
2018-12-18 11:49:25 -     |> fst
2018-12-18 11:49:28 - rungekut |> List.map2 (fun x y -> {Точка = x; Значение = y; Погрешность = abs(y - exact x)}) 
2018-12-18 11:49:28 -         (points |> List.skip 1) |> Util.Table
2018-12-18 11:52:07 - type AbsTableRow = {Точка : float; ``Погрешность метода Эйлера 1``: float; ``Погрешность метода Эйлера 2``: float; 
2018-12-18 11:52:07 -     ``Погрешность метода Эйлера 3``: float; ``Погрешность метода Рунге-Кутта``: float; ``Погрешность экстрополяционного метода Адамса``: float}
2018-12-18 12:00:06 - let printInfo =
2018-12-18 12:00:06 -     let rec printInfoInternal xs e1 e2 e3 rk a acc =
2018-12-18 12:00:06 -         match xs, e1, e2, e3, rk, a with
2018-12-18 12:00:06 -         |(hxs, he1, he2, he3, hrk, ha) :: (txs, te1, te2, te3, trk, ta) -> 
2018-12-18 12:00:06 -             printInfoInternal txs te1 te2 te3 trk ta 
2018-12-18 12:00:06 -                 ({Точка = hxs; 
2018-12-18 12:00:06 -                 ``Погрешность метода Эйлера 1``= abs(he1 - exact hxs); 
2018-12-18 12:00:06 -                 ``Погрешность метода Эйлера 2``= abs(he2 - exact hxs); 
2018-12-18 12:00:06 -                 ``Погрешность метода Эйлера 3``= abs(he3 - exact hxs); 
2018-12-18 12:00:06 -                 ``Погрешность метода Рунге-Кутта``= abs(hrk - exact hxs); 
2018-12-18 12:00:06 -                 ``Погрешность экстрополяционного метода Адамса``= abs(ha - exact hxs)} :: acc)
2018-12-18 12:00:06 -         | _ -> List.rev acc
2018-12-18 12:00:06 -     printInfoInternal (points |> List.skip 1) euler1 euler2 euler3 rungekut (adams |> List.skip 1)
2018-12-18 12:00:06 -     
2018-12-18 12:00:06 - This expression was expected to have type
2018-12-18 12:00:06 -     ''a * 'b * 'c * 'd * 'e * 'f'    
2018-12-18 12:00:06 - but here has type
2018-12-18 12:00:06 -     ''g list'    
2018-12-18 12:00:19 - let printInfo =
2018-12-18 12:00:19 -     let rec printInfoInternal xs e1 e2 e3 rk a acc =
2018-12-18 12:00:19 -         match xs, e1, e2, e3, rk, a with
2018-12-18 12:00:19 -         |(hxs, he1, he2, he3, hrk, ha) :: (txs, te1, te2, te3, trk, ta) -> 
2018-12-18 12:00:19 -             printInfoInternal txs te1 te2 te3 trk ta 
2018-12-18 12:00:19 -                 ({Точка = hxs; 
2018-12-18 12:00:19 -                 ``Погрешность метода Эйлера 1``= abs(he1 - exact hxs); 
2018-12-18 12:00:19 -                 ``Погрешность метода Эйлера 2``= abs(he2 - exact hxs); 
2018-12-18 12:00:19 -                 ``Погрешность метода Эйлера 3``= abs(he3 - exact hxs); 
2018-12-18 12:00:19 -                 ``Погрешность метода Рунге-Кутта``= abs(hrk - exact hxs); 
2018-12-18 12:00:19 -                 ``Погрешность экстрополяционного метода Адамса``= abs(ha - exact hxs)} :: acc)
2018-12-18 12:00:19 -         | _ -> List.rev acc
2018-12-18 12:00:19 -     printInfoInternal (points |> List.skip 1) euler1 euler2 euler3 rungekut (adams |> List.skip 1) []
2018-12-18 12:00:19 -     
2018-12-18 12:00:19 - This expression was expected to have type
2018-12-18 12:00:19 -     ''a * 'b * 'c * 'd * 'e * 'f'    
2018-12-18 12:00:19 - but here has type
2018-12-18 12:00:19 -     ''g list'    
2018-12-18 12:01:45 - let printInfo =
2018-12-18 12:01:45 -     let rec printInfoInternal xs e1 e2 e3 rk a acc =
2018-12-18 12:01:45 -         match xs, e1, e2, e3, rk, a with
2018-12-18 12:01:45 -         |(hxs :: txs, he1 :: te1, he2 :: te2, he3 :: te3, hrk :: trk, ha :: ta) -> 
2018-12-18 12:01:45 -             printInfoInternal txs te1 te2 te3 trk ta 
2018-12-18 12:01:45 -                 ({Точка = hxs; 
2018-12-18 12:01:45 -                 ``Погрешность метода Эйлера 1``= abs(he1 - exact hxs); 
2018-12-18 12:01:45 -                 ``Погрешность метода Эйлера 2``= abs(he2 - exact hxs); 
2018-12-18 12:01:45 -                 ``Погрешность метода Эйлера 3``= abs(he3 - exact hxs); 
2018-12-18 12:01:45 -                 ``Погрешность метода Рунге-Кутта``= abs(hrk - exact hxs); 
2018-12-18 12:01:45 -                 ``Погрешность экстрополяционного метода Адамса``= abs(ha - exact hxs)} :: acc)
2018-12-18 12:01:45 -         | _ -> List.rev acc
2018-12-18 12:01:45 -     printInfoInternal (points |> List.skip 1) euler1 euler2 euler3 rungekut (adams |> List.skip 1) []
2018-12-18 12:01:45 -     
2018-12-18 12:01:51 - printInfo
2018-12-18 12:01:58 - printInfo |> Utils.Table
2018-12-18 12:01:58 - The value, namespace, type or module 'Utils' is not defined. Maybe you want one of the following:
2018-12-18 12:01:58 -    Util
2018-12-18 12:02:01 - printInfo |> Util.Table
2018-12-18 13:02:31 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-12-18 13:02:31 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-12-18 13:02:31 - For help type #help;;
2018-12-18 13:02:31 - > val it :
2018-12-18 13:02:31 -   ResizeArray<System.Type *
2018-12-18 13:02:31 -               (obj ->
2018-12-18 13:02:31 -                  seq<string *
2018-12-18 13:02:31 -                      string> *
2018-12-18 13:02:31 -                  string)>
2018-12-18 13:02:31 - = seq []
2018-12-18 13:02:31 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2018-12-18 13:02:31 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-12-18 13:02:31 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2018-12-18 13:02:33 - Reporting 0 opened comms
2018-12-18 13:02:51 - shutdown request
2019-04-01 22:04:07 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2019-04-01 22:04:07 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-04-01 22:04:07 - For help type #help;;
2019-04-01 22:04:07 - > val it :
2019-04-01 22:04:07 -   ResizeArray<System.Type *
2019-04-01 22:04:07 -               (obj ->
2019-04-01 22:04:07 -                  seq<string *
2019-04-01 22:04:07 -                      string> *
2019-04-01 22:04:07 -                  string)>
2019-04-01 22:04:07 - = seq []
2019-04-01 22:04:07 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2019-04-01 22:04:07 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-04-01 22:04:07 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2019-04-01 22:04:09 - Reporting 0 opened comms
2019-05-31 20:48:14 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2019-05-31 20:48:14 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-05-31 20:48:14 - For help type #help;;
2019-05-31 20:48:14 - > val it :
2019-05-31 20:48:14 -   ResizeArray<System.Type *
2019-05-31 20:48:14 -               (obj ->
2019-05-31 20:48:14 -                  seq<string *
2019-05-31 20:48:14 -                      string> *
2019-05-31 20:48:14 -                  string)>
2019-05-31 20:48:14 - = seq []
2019-05-31 20:48:14 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2019-05-31 20:48:14 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-05-31 20:48:14 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2019-05-31 20:48:15 - Reporting 0 opened comms
2019-05-31 23:09:03 - shutdown request
2019-06-01 17:27:01 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2019-06-01 17:27:01 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-06-01 17:27:01 - For help type #help;;
2019-06-01 17:27:01 - > val it :
2019-06-01 17:27:01 -   ResizeArray<System.Type *
2019-06-01 17:27:01 -               (obj ->
2019-06-01 17:27:01 -                  seq<string *
2019-06-01 17:27:01 -                      string> *
2019-06-01 17:27:01 -                  string)>
2019-06-01 17:27:01 - = seq []
2019-06-01 17:27:01 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2019-06-01 17:27:01 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-06-01 17:27:01 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2019-06-01 17:27:02 - Reporting 0 opened comms
2019-06-01 17:27:16 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2019-06-01 17:27:16 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-06-01 17:27:16 - For help type #help;;
2019-06-01 17:27:16 - > val it :
2019-06-01 17:27:16 -   ResizeArray<System.Type *
2019-06-01 17:27:16 -               (obj ->
2019-06-01 17:27:16 -                  seq<string *
2019-06-01 17:27:16 -                      string> *
2019-06-01 17:27:16 -                  string)>
2019-06-01 17:27:16 - = seq []
2019-06-01 17:27:16 - --> Added '/home/max/dev/IfSharp.v3.0.1' to library include path
2019-06-01 17:27:16 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-06-01 17:27:16 - --> Referenced '/home/max/dev/IfSharp.v3.0.1/NetMQ.dll' (file may be locked by F# Interactive process)
2019-06-01 17:27:18 - Reporting 0 opened comms
2019-06-01 18:27:15 - shutdown request
